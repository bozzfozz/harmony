===== .github/workflows/autopush.yml =====
name: CI

on:
  push:
    branches: [ main ]
  pull_request:

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
      - name: Run tests
        run: pytest

===== .gitignore =====
__pycache__/
*.pyc
harmony.db

===== .pytest_cache/.gitignore =====
# Created by pytest automatically.
*

===== .pytest_cache/CACHEDIR.TAG =====
Signature: 8a477f597d28d172789f06886806bc55
# This file is a cache directory tag created by pytest.
# For information about cache directory tags, see:
#	https://bford.info/cachedir/spec.html

===== .pytest_cache/README.md =====
# pytest cache directory #

This directory contains data from the pytest's cache plugin,
which provides the `--lf` and `--ff` options, as well as the `cache` fixture.

**Do not** commit this to version control.

See [the docs](https://docs.pytest.org/en/stable/how-to/cache.html) for more information.

===== .pytest_cache/v/cache/nodeids =====
[
  "tests/test_beets.py::TestAvailability::test_available",
  "tests/test_beets.py::TestAvailability::test_not_available",
  "tests/test_beets.py::TestEnvironment::test_env_passed",
  "tests/test_beets.py::TestFields::test_failure",
  "tests/test_beets.py::TestFields::test_fields",
  "tests/test_beets.py::TestFields::test_timeout",
  "tests/test_beets.py::TestImportFile::test_called_process_error",
  "tests/test_beets.py::TestImportFile::test_options",
  "tests/test_beets.py::TestImportFile::test_success",
  "tests/test_beets.py::TestImportFile::test_unexpected_error",
  "tests/test_beets.py::TestListAlbums::test_failure",
  "tests/test_beets.py::TestListAlbums::test_success",
  "tests/test_beets.py::TestListTracks::test_failure",
  "tests/test_beets.py::TestListTracks::test_success",
  "tests/test_beets.py::TestMove::test_failure",
  "tests/test_beets.py::TestMove::test_timeout",
  "tests/test_beets.py::TestMove::test_with_query",
  "tests/test_beets.py::TestMove::test_without_query",
  "tests/test_beets.py::TestQuery::test_failure",
  "tests/test_beets.py::TestQuery::test_invalid_query",
  "tests/test_beets.py::TestQuery::test_query",
  "tests/test_beets.py::TestQuery::test_timeout",
  "tests/test_beets.py::TestRemove::test_empty_query",
  "tests/test_beets.py::TestRemove::test_failure",
  "tests/test_beets.py::TestRemove::test_force",
  "tests/test_beets.py::TestRemove::test_success",
  "tests/test_beets.py::TestRemove::test_timeout",
  "tests/test_beets.py::TestRouterFields::test_fields",
  "tests/test_beets.py::TestRouterImport::test_import_options",
  "tests/test_beets.py::TestRouterMove::test_move_client_error",
  "tests/test_beets.py::TestRouterMove::test_move_with_query",
  "tests/test_beets.py::TestRouterMove::test_move_without_query",
  "tests/test_beets.py::TestRouterQuery::test_query",
  "tests/test_beets.py::TestRouterQuery::test_query_invalid",
  "tests/test_beets.py::TestRouterRemove::test_remove",
  "tests/test_beets.py::TestRouterRemove::test_remove_empty_query",
  "tests/test_beets.py::TestRouterRemove::test_remove_invalid_query",
  "tests/test_beets.py::TestRouterWrite::test_write_with_query",
  "tests/test_beets.py::TestRouterWrite::test_write_without_query",
  "tests/test_beets.py::TestStats::test_failure",
  "tests/test_beets.py::TestStats::test_success",
  "tests/test_beets.py::TestStats::test_timeout",
  "tests/test_beets.py::TestUpdate::test_failure",
  "tests/test_beets.py::TestUpdate::test_success",
  "tests/test_beets.py::TestUpdate::test_with_path",
  "tests/test_beets.py::TestWrite::test_failure",
  "tests/test_beets.py::TestWrite::test_timeout",
  "tests/test_beets.py::TestWrite::test_with_query",
  "tests/test_beets.py::TestWrite::test_without_query",
  "tests/test_matching.py::test_album_matching_engine",
  "tests/test_matching.py::test_match_confidence",
  "tests/test_matching.py::test_matching_api_album",
  "tests/test_matching.py::test_matching_api_plex",
  "tests/test_matching.py::test_matching_api_soulseek",
  "tests/test_plex.py::test_devices_and_livetv",
  "tests/test_plex.py::test_library_endpoints",
  "tests/test_plex.py::test_notifications",
  "tests/test_plex.py::test_playlists_and_playqueue",
  "tests/test_plex.py::test_plex_status",
  "tests/test_plex.py::test_rating_and_tags",
  "tests/test_plex.py::test_scan_worker_updates_status",
  "tests/test_plex.py::test_session_endpoints",
  "tests/test_plex.py::test_timeline_and_scrobble",
  "tests/test_settings.py::test_settings_history_tracking",
  "tests/test_soulseek.py::test_soulseek_download_cancellation",
  "tests/test_soulseek.py::test_soulseek_download_flow",
  "tests/test_soulseek.py::test_soulseek_download_management_endpoints",
  "tests/test_soulseek.py::test_soulseek_enqueue_endpoint",
  "tests/test_soulseek.py::test_soulseek_search",
  "tests/test_soulseek.py::test_soulseek_status",
  "tests/test_soulseek.py::test_soulseek_upload_endpoints",
  "tests/test_soulseek.py::test_soulseek_user_endpoints",
  "tests/test_spotify.py::test_audio_features_endpoints",
  "tests/test_spotify.py::test_playlist_items_endpoint",
  "tests/test_spotify.py::test_playlist_sync_worker_persists_playlists",
  "tests/test_spotify.py::test_recommendations_endpoint",
  "tests/test_spotify.py::test_save_and_remove_tracks"
]
===== CHANGELOG.md =====
# Changelog

Alle nennenswerten Änderungen dieses Projekts werden in dieser Datei dokumentiert.

## v1.4.0 – Spotify API Vollintegration
- Vollständige Spotify-Integration inkl. Playlist-Sync, Audio-Features, Recommendations und Benutzerbibliothek.
- Erweiterter Spotify-Router mit neuen Endpunkten für Playlists (Add/Remove/Reorder), Profil, Top-Tracks/-Artists.
- PlaylistSyncWorker synchronisiert persistierte Playlists regelmäßig in die Datenbank.

## v1.3.0 – Persistente Playlists
- Neuer Playlist-Sync-Prozess speichert Playlists persistent und liefert Änderungszeitpunkte.
- `/spotify/playlists` gibt Track-Anzahl und Timestamps aus der Datenbank zurück.

## v1.2.0 – Soulseek Downloadstatus
- Soulseek-Downloads werden mit Fortschritt und Zeitstempeln in SQLite abgelegt.
- API liefert Statusabfragen inklusive Fortschritt; Downloads können abgebrochen werden.
- Hintergrund-SyncWorker pollt slskd und aktualisiert persistierte Einträge.

## v1.1.0 – Beets-Integration
- Beets CLI via `BeetsClient` angebunden (Import, Update, Remove, Move, Write, Query, Stats).
- Dockerfiles und Compose-Setup für konsistenten Start angepasst.

## v1.0.0 – Initiale Version
- FastAPI-Anwendung mit Spotify-, Plex- und Soulseek-Routern.
- SQLite + SQLAlchemy für Persistenz, inklusive Testabdeckung mittels Pytest.

===== CHANGES_REVIEW.md =====
# Code Review Zusammenfassung

## Router & API
- Alle Router binden nun konsistente JSON-Schemata ein und liefern eindeutige HTTP-Fehlercodes.
- Plex- und Soulseek-Router verwenden strukturierte Antwortmodelle und protokollieren API-Ausfälle.
- Matching-Router persistiert Ergebnisse transaktionssicher und gibt bei Datenbankfehlern klare Fehlermeldungen aus.
- Soulseek-Downloads lassen sich inklusive Fortschritt abrufen; Abbrüche markieren Einträge als `failed`.

## Datenbank & Worker
- `session_scope()` wird in allen Workern eingesetzt, um atomare Transaktionen und Rollbacks sicherzustellen.
- Verbesserte Logging-Ausgaben erleichtern das Debugging fehlgeschlagener Hintergrundjobs.
- `downloads`-Tabelle enthält Status, Fortschritt und Aktualisierungszeitpunkt; Sync-Worker pollt Soulseek für Updates.

## Dokumentation
- README um Neuerungen in v1.2.0 ergänzt.
- CHANGELOG auf Version 1.2.0 aktualisiert.
- Dokumentation und Changelog beschreiben den Soulseek-Download-Fortschritt.

===== Dockerfile =====
FROM python:3.11-slim

ENV PYTHONUNBUFFERED=1 \
    POETRY_VIRTUALENVS_CREATE=false \
    PIP_NO_CACHE_DIR=1

WORKDIR /app

COPY requirements.txt ./
RUN pip install --upgrade pip && pip install -r requirements.txt

COPY . .

EXPOSE 8000

# Standard: Production
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]

===== README.md =====
# Harmony Backend

Harmony ist ein FastAPI-Backend, das Spotify, Plex, Soulseek (slskd), Beets sowie eine eigene Matching-Engine und Hintergrund-Worker
zu einem gemeinsamen Musik-Hub kombiniert. Die Anwendung bündelt Bibliotheken, Downloads und Metadaten, synchronisiert sie zyklisch
und stellt einheitliche JSON-APIs für Automatisierungen und Frontend-Clients bereit.

## Features

- **Vollständige Spotify-Integration** für Suche, Playlists, Audio-Features, Empfehlungen und Benutzerbibliotheken.
- **Async Plex-Client** mit Zugriff auf Bibliotheken, Sessions, PlayQueues, Live-TV und Echtzeit-Benachrichtigungen.
- **Soulseek-Anbindung** inklusive Download-/Upload-Verwaltung, Warteschlangen und Benutzerinformationen.
- **Beets CLI Bridge** zum Importieren, Aktualisieren, Verschieben und Abfragen der lokalen Musikbibliothek.
- **Matching-Engine** zur Ermittlung der besten Kandidaten zwischen Spotify ↔ Plex/Soulseek inklusive Persistierung.
- **SQLite-Datenbank** mit SQLAlchemy-Modellen für Playlists, Downloads, Matches und Settings.
- **Hintergrund-Worker** für Soulseek-Synchronisation, Matching-Queue, Plex-Scans und Spotify-Playlist-Sync.
- **Docker & GitHub Actions** für reproduzierbare Builds, Tests und Continuous Integration.

## Architekturüberblick

Harmony folgt einer klar getrennten Schichten-Architektur:

- **Core**: Enthält API-Clients (`spotify_client.py`, `plex_client.py`, `soulseek_client.py`, `beets_client.py`) und die Matching-Engine.
- **Routers**: FastAPI-Router kapseln die öffentlich erreichbaren Endpunkte (Spotify, Plex, Soulseek, Matching, Settings, Beets).
- **Workers**: Asynchrone Tasks synchronisieren Playlists, Soulseek-Downloads, Plex-Statistiken und Matching-Jobs.
- **Datenbank-Layer**: `app/db.py`, SQLAlchemy-Modelle und -Schemas verwalten persistente Zustände.

Eine ausführliche Beschreibung der Komponenten findest du in [`docs/architecture.md`](docs/architecture.md).

## Setup-Anleitung

### Voraussetzungen

- Python 3.11
- SQLite (im Lieferumfang enthalten)
- Optional: Docker und Docker Compose

### Lokales Setup

```bash
python -m venv .venv
source .venv/bin/activate
pip install --upgrade pip
pip install -r requirements.txt
uvicorn app.main:app --reload
```

Konfiguriere erforderliche Umgebungsvariablen (siehe Tabelle unten), bevor du den Server startest.

### Docker

```bash
docker build -t harmony-backend .
docker run --env-file .env -p 8000:8000 harmony-backend
```

### Docker Compose

```bash
docker compose up --build
```

Das Dev-Override (`docker-compose.override.yml`) aktiviert Hot-Reloading und Debug-Logging.

### GitHub Actions

Der Workflow [`.github/workflows/autopush.yml`](.github/workflows/autopush.yml) führt bei jedem Push auf `main` sowie bei Pull
Requests die Test-Suite (`pytest`) unter Python 3.11 aus.

## Konfiguration

| Variable | Beschreibung |
| --- | --- |
| `SPOTIFY_CLIENT_ID` | Spotify OAuth Client ID |
| `SPOTIFY_CLIENT_SECRET` | Spotify OAuth Client Secret |
| `SPOTIFY_REDIRECT_URI` | Redirect URI für den OAuth-Flow |
| `SPOTIFY_SCOPE` | Optionaler Scope für Spotify Berechtigungen |
| `PLEX_BASE_URL` | Basis-URL des Plex-Servers |
| `PLEX_TOKEN` | Plex Auth Token |
| `PLEX_LIBRARY` | Name der Plex-Musikbibliothek |
| `SLSKD_URL` | Basis-URL des Soulseek-Daemons |
| `SLSKD_API_KEY` | API-Key für slskd (falls gesetzt) |
| `DATABASE_URL` | SQLAlchemy Verbindungsstring (Standard: `sqlite:///./harmony.db`) |
| `HARMONY_LOG_LEVEL` | Log-Level (`INFO`, `DEBUG`, …) |
| `HARMONY_DISABLE_WORKERS` | `1` deaktiviert alle Hintergrund-Worker (z. B. für Tests) |

## API-Endpoints

Eine vollständige Referenz der FastAPI-Routen befindet sich in [`docs/api.md`](docs/api.md). Die wichtigsten Gruppen im Überblick:

- **Spotify** (`/spotify`): Status, Suche, Track-Details, Audio-Features, Benutzerbibliothek, Playlists, Empfehlungen.
- **Plex** (`/plex`): Status & Statistiken, Bibliotheken, PlayQueues, Playlists, Timeline, Bewertungen, Benachrichtigungen.
- **Soulseek** (`/soulseek`): Status, Suche, Downloads/Uploads, Warteschlangen, Benutzerverzeichnisse und -infos.
- **Matching** (`/matching`): Spotify→Plex, Spotify→Soulseek sowie Album-Matching.
- **Settings** (`/settings`): Key-Value Einstellungen inkl. History.
- **Beets** (`/beets`): Import, Update, Query, Stats und Dateimanipulation via CLI.

## Tests & CI

```bash
pytest
```

Die Tests mocken externe Dienste und können lokal wie auch via GitHub Actions ausgeführt werden. Für deterministische
Runs sollten die Worker mit `HARMONY_DISABLE_WORKERS=1` deaktiviert werden.

## Lizenz

Das Projekt steht derzeit ohne explizite Lizenzdatei zur Verfügung. Ohne eine veröffentlichte Lizenz gelten sämtliche Rechte
als vorbehalten.

===== ToDo.md =====
# ToDo

- ✅ Backend-Struktur mit FastAPI, SQLAlchemy und SQLite aufbauen
- ✅ Core-Clients für Spotify, Plex und Soulseek implementieren
- ✅ Matching-Engine integrieren
- ✅ Tests mit Pytest erstellen
- ✅ Docker- und CI-Konfiguration hinzufügen
- ⬜️ Erweiterte Frontend-Integration

===== app/__init__.py =====

===== app/config.py =====
"""Application configuration utilities for Harmony."""
from __future__ import annotations

import os
from dataclasses import dataclass
from typing import Optional


@dataclass(slots=True)
class SpotifyConfig:
    client_id: Optional[str]
    client_secret: Optional[str]
    redirect_uri: Optional[str]
    scope: str


@dataclass(slots=True)
class PlexConfig:
    base_url: Optional[str]
    token: Optional[str]
    library_name: Optional[str]


@dataclass(slots=True)
class SoulseekConfig:
    base_url: str
    api_key: Optional[str]


@dataclass(slots=True)
class LoggingConfig:
    level: str


@dataclass(slots=True)
class DatabaseConfig:
    url: str


@dataclass(slots=True)
class AppConfig:
    spotify: SpotifyConfig
    plex: PlexConfig
    soulseek: SoulseekConfig
    logging: LoggingConfig
    database: DatabaseConfig


DEFAULT_DB_URL = "sqlite:///./harmony.db"
DEFAULT_SOULSEEK_URL = "http://localhost:5030"
DEFAULT_SPOTIFY_SCOPE = (
    "user-library-read playlist-read-private playlist-read-collaborative"
)


def load_config() -> AppConfig:
    """Load application configuration from environment variables."""

    spotify = SpotifyConfig(
        client_id=os.getenv("SPOTIFY_CLIENT_ID"),
        client_secret=os.getenv("SPOTIFY_CLIENT_SECRET"),
        redirect_uri=os.getenv("SPOTIFY_REDIRECT_URI"),
        scope=os.getenv("SPOTIFY_SCOPE", DEFAULT_SPOTIFY_SCOPE),
    )

    plex = PlexConfig(
        base_url=os.getenv("PLEX_BASE_URL") or os.getenv("PLEX_URL"),
        token=os.getenv("PLEX_TOKEN"),
        library_name=os.getenv("PLEX_LIBRARY"),
    )

    soulseek = SoulseekConfig(
        base_url=os.getenv("SLSKD_URL", DEFAULT_SOULSEEK_URL),
        api_key=os.getenv("SLSKD_API_KEY"),
    )

    logging = LoggingConfig(level=os.getenv("HARMONY_LOG_LEVEL", "INFO"))
    database = DatabaseConfig(url=os.getenv("DATABASE_URL", DEFAULT_DB_URL))

    return AppConfig(
        spotify=spotify,
        plex=plex,
        soulseek=soulseek,
        logging=logging,
        database=database,
    )

===== app/core/__init__.py =====

===== app/core/beets_client.py =====
from __future__ import annotations

from pathlib import Path
from typing import Mapping, Sequence
import os
import shlex
import subprocess
import re

from app.utils.logging_config import get_logger


class BeetsClientError(RuntimeError):
    """Raised when execution of a beets command fails."""


logger = get_logger("beets_client")


class BeetsClient:
    """Thin wrapper around the :mod:`beets` CLI."""

    def __init__(
        self,
        env: Mapping[str, str] | None = None,
        timeout: float = 60.0,
    ) -> None:
        self._env = {**os.environ, **env} if env else None
        self._timeout = timeout

    def _run(self, args: Sequence[str]) -> subprocess.CompletedProcess[str]:
        """Execute *args* with the ``beet`` CLI and return the process result."""

        command = " ".join(args)
        logger.info("Executing beets command: %s", command)

        try:
            run_kwargs = dict(capture_output=True, text=True, check=True)
            if self._env is not None:
                run_kwargs["env"] = self._env
            result = subprocess.run(list(args), timeout=self._timeout, **run_kwargs)
        except subprocess.TimeoutExpired as exc:
            logger.error("Beets command timed out: %s", command)
            raise BeetsClientError("Command timed out") from exc
        except subprocess.CalledProcessError as exc:
            stderr = (exc.stderr or "").strip()
            if stderr:
                logger.error("Beets command failed (%s): %s", command, stderr)
            else:
                logger.error("Beets command failed (%s)", command)
            raise BeetsClientError(stderr or f"Command '{command}' failed") from exc
        except Exception as exc:  # pragma: no cover - defensive
            logger.exception("Unexpected error while executing '%s'", command)
            raise BeetsClientError(f"Unexpected error running '{command}'") from exc

        stdout = (result.stdout or "").strip()
        if stdout:
            logger.info("Beets command output: %s", stdout)

        return result

    def import_file(
        self, path: str | Path, quiet: bool = True, autotag: bool = True
    ) -> str:
        """Import *path* into the beets library using ``beet import``."""

        args: list[str] = ["beet", "import"]
        if quiet:
            args.append("-q")
        if not autotag:
            args.append("-A")
        args.append(str(path))

        result = self._run(args)
        return (result.stdout or "").strip()

    def update(self, path: str | Path | None = None) -> str:
        """Run ``beet update`` optionally scoped to *path*."""

        args: list[str] = ["beet", "update"]
        if path is not None:
            args.append(str(path))

        result = self._run(args)
        return (result.stdout or "").strip()

    def list_albums(self) -> list[str]:
        """Return a list of album names from ``beet ls -a``."""

        result = self._run(["beet", "ls", "-a"])
        stdout = result.stdout or ""
        albums = [line for line in stdout.splitlines() if line.strip()]
        logger.debug("Parsed albums: %s", albums)
        return albums

    def list_tracks(self) -> list[str]:
        """Return a list of track titles from ``beet ls -f '$title'``."""

        result = self._run(["beet", "ls", "-f", "$title"])
        stdout = result.stdout or ""
        tracks = [line for line in stdout.splitlines() if line.strip()]
        logger.debug("Parsed tracks: %s", tracks)
        return tracks

    def stats(self) -> dict[str, str]:
        """Return parsed key/value pairs from ``beet stats``."""

        result = self._run(["beet", "stats"])
        stdout = result.stdout or ""
        stats: dict[str, str] = {}
        for line in stdout.splitlines():
            if ":" not in line:
                continue
            key, value = line.split(":", 1)
            key = key.strip()
            value = value.strip()
            if key:
                stats[key] = value
        logger.debug("Parsed stats: %s", stats)
        return stats

    def is_available(self) -> bool:
        """Return ``True`` when the ``beet`` CLI is reachable."""

        try:
            self._run(["beet", "version"])
        except BeetsClientError:
            return False
        return True

    def remove(self, query: str, force: bool = False) -> dict[str, object]:
        """Remove items matching *query* using ``beet remove``."""

        query_args = self._parse_query(query)
        args: list[str] = ["beet", "remove"]
        if force:
            args.append("-f")
        args.extend(query_args)

        result = self._run(args)
        parsed = self._parse_count_output(result.stdout, "Removed", "removed")
        logger.debug("Parsed remove output: %s", parsed)
        return parsed

    def move(self, query: str | None = None) -> dict[str, object]:
        """Move items in the library using ``beet move`` with an optional query."""

        args: list[str] = ["beet", "move"]
        if query:
            args.extend(self._parse_query(query))

        result = self._run(args)
        parsed = self._parse_count_output(result.stdout, "Moved", "moved")
        logger.debug("Parsed move output: %s", parsed)
        return parsed

    def write(self, query: str | None = None) -> dict[str, object]:
        """Write tags for items using ``beet write`` with an optional query."""

        args: list[str] = ["beet", "write"]
        if query:
            args.extend(self._parse_query(query))

        result = self._run(args)
        parsed = self._parse_count_output(result.stdout, "Wrote", "written")
        logger.debug("Parsed write output: %s", parsed)
        return parsed

    def fields(self) -> list[str]:
        """Return the list of available fields from ``beet fields``."""

        result = self._run(["beet", "fields"])
        stdout = result.stdout or ""
        fields = [line for line in stdout.splitlines() if line.strip()]
        logger.debug("Parsed fields: %s", fields)
        return fields

    def query(
        self, query: str, fmt: str = "$artist - $album - $title"
    ) -> list[str]:
        """Return formatted items for *query* via ``beet ls``."""

        query_args = self._parse_query(query)
        args: list[str] = ["beet", "ls", "-f", fmt]
        args.extend(query_args)

        result = self._run(args)
        stdout = result.stdout or ""
        results = [line for line in stdout.splitlines() if line.strip()]
        logger.debug("Parsed query results: %s", results)
        return results

    @staticmethod
    def _parse_query(query: str) -> list[str]:
        if not query or not query.strip():
            raise BeetsClientError("Query must not be empty")
        try:
            parts = shlex.split(query)
        except ValueError as exc:  # pragma: no cover - defensive
            raise BeetsClientError(f"Invalid query syntax: {exc}") from exc
        return parts

    @staticmethod
    def _parse_count_output(
        stdout: str | None, verb: str, key: str
    ) -> dict[str, object]:
        output = (stdout or "").strip()
        pattern = rf"{verb} (\d+) items"
        match = re.search(pattern, output)
        if match:
            count = int(match.group(1))
            return {"success": True, key: count}
        return {"success": True, "output": output}

===== app/core/matching_engine.py =====
"""Music matching logic used by Harmony."""
from __future__ import annotations

import re
import unicodedata
from difflib import SequenceMatcher
from typing import Dict, Iterable, Optional, Tuple


class MusicMatchingEngine:
    """Provides fuzzy matching utilities across Spotify, Plex and Soulseek."""

    def _normalize(self, value: Optional[str]) -> str:
        if not value:
            return ""
        normalized = unicodedata.normalize("NFKD", value)
        normalized = normalized.encode("ascii", "ignore").decode("ascii")
        normalized = re.sub(r"[^a-z0-9]+", " ", normalized.lower())
        return normalized.strip()

    def _ratio(self, a: Optional[str], b: Optional[str]) -> float:
        na, nb = self._normalize(a), self._normalize(b)
        if not na or not nb:
            return 0.0
        return SequenceMatcher(None, na, nb).ratio()

    def calculate_match_confidence(self, spotify_track: Dict[str, str], plex_track: Dict[str, str]) -> float:
        title_score = self._ratio(spotify_track.get("name"), plex_track.get("title"))
        artist_score = self._ratio(
            (spotify_track.get("artists") or [{}])[0].get("name") if isinstance(spotify_track.get("artists"), list) else spotify_track.get("artist"),
            plex_track.get("artist") or plex_track.get("grandparentTitle"),
        )
        album_score = self._ratio(
            (spotify_track.get("album") or {}).get("name") if isinstance(spotify_track.get("album"), dict) else spotify_track.get("album"),
            plex_track.get("album") or plex_track.get("parentTitle"),
        )
        duration_spotify = spotify_track.get("duration_ms")
        duration_plex = plex_track.get("duration")
        duration_score = 0.0
        if duration_spotify and duration_plex:
            duration_score = 1.0 - min(abs(duration_spotify - duration_plex) / max(duration_spotify, duration_plex), 1)

        return round((title_score * 0.5) + (artist_score * 0.3) + (album_score * 0.15) + (duration_score * 0.05), 4)

    def find_best_match(
        self, spotify_track: Dict[str, str], plex_candidates: Iterable[Dict[str, str]]
    ) -> Tuple[Optional[Dict[str, str]], float]:
        best_match: Optional[Dict[str, str]] = None
        best_score = 0.0
        for candidate in plex_candidates:
            score = self.calculate_match_confidence(spotify_track, candidate)
            if score > best_score:
                best_score = score
                best_match = candidate
        return best_match, best_score

    def calculate_slskd_match_confidence(
        self, spotify_track: Dict[str, str], soulseek_entry: Dict[str, str]
    ) -> float:
        title_score = self._ratio(spotify_track.get("name"), soulseek_entry.get("filename"))
        artist = (
            (spotify_track.get("artists") or [{}])[0].get("name")
            if isinstance(spotify_track.get("artists"), list)
            else spotify_track.get("artist")
        )
        artist_score = self._ratio(artist, soulseek_entry.get("username"))
        bitrate_score = 1.0 if soulseek_entry.get("bitrate", 0) >= 256 else 0.5
        return round((title_score * 0.6) + (artist_score * 0.2) + (bitrate_score * 0.2), 4)

    def _extract_album_artist(self, album: Dict[str, str]) -> Optional[str]:
        artists = album.get("artists")
        if isinstance(artists, list) and artists:
            primary_artist = artists[0]
            if isinstance(primary_artist, dict):
                return primary_artist.get("name")
            return str(primary_artist)
        return album.get("artist") or album.get("grandparentTitle")

    def _album_track_count(self, album: Dict[str, str]) -> Optional[int]:
        for key in ("total_tracks", "trackCount", "leafCount", "childCount", "track_count"):
            value = album.get(key)
            if isinstance(value, int):
                return value
            if isinstance(value, str) and value.isdigit():
                return int(value)
        tracks = album.get("tracks")
        if isinstance(tracks, dict):
            items = tracks.get("items")
            if isinstance(items, list):
                return len(items)
        if isinstance(tracks, list):
            return len(tracks)
        return None

    def _album_year(self, album: Dict[str, str]) -> Optional[int]:
        for key in ("year", "release_year"):
            value = album.get(key)
            if isinstance(value, int):
                return value
            if isinstance(value, str) and value.isdigit():
                return int(value)
        release_date = album.get("release_date")
        if isinstance(release_date, str) and release_date:
            if len(release_date) >= 4 and release_date[:4].isdigit():
                return int(release_date[:4])
        originally_available_at = album.get("originallyAvailableAt")
        if isinstance(originally_available_at, str) and originally_available_at:
            if originally_available_at[:4].isdigit():
                return int(originally_available_at[:4])
        return None

    def calculate_album_confidence(
        self, spotify_album: Dict[str, str], plex_album: Dict[str, str]
    ) -> float:
        """Calculate similarity score between Spotify and Plex albums."""

        name_score = self._ratio(spotify_album.get("name"), plex_album.get("title"))
        spotify_artist = self._extract_album_artist(spotify_album)
        plex_artist = self._extract_album_artist(plex_album) or plex_album.get("parentTitle")
        artist_score = self._ratio(spotify_artist, plex_artist)

        spotify_tracks = self._album_track_count(spotify_album)
        plex_tracks = self._album_track_count(plex_album)
        track_count_score = 0.0
        if spotify_tracks and plex_tracks:
            diff = abs(spotify_tracks - plex_tracks)
            max_count = max(spotify_tracks, plex_tracks)
            track_count_score = 1.0 - min(diff / max_count, 1)

        spotify_year = self._album_year(spotify_album)
        plex_year = self._album_year(plex_album)
        year_score = 0.0
        if spotify_year and plex_year:
            year_score = 1.0 if spotify_year == plex_year else 0.0

        score = (name_score * 0.4) + (artist_score * 0.4) + (track_count_score * 0.1) + (year_score * 0.1)
        return round(score, 4)

    def find_best_album_match(
        self, spotify_album: Dict[str, str], plex_albums: Iterable[Dict[str, str]]
    ) -> Tuple[Optional[Dict[str, str]], float]:
        """Find the highest scoring Plex album for the given Spotify album."""

        best_match: Optional[Dict[str, str]] = None
        best_score = 0.0
        for candidate in plex_albums:
            score = self.calculate_album_confidence(spotify_album, candidate)
            if score > best_score:
                best_score = score
                best_match = candidate
        return best_match, best_score

===== app/core/plex_client.py =====
"""Async Plex client built on top of the public Plex API."""
from __future__ import annotations

import asyncio
from contextlib import asynccontextmanager
from typing import Any, AsyncIterator, Dict, List

import aiohttp

from app.config import PlexConfig
from app.logging import get_logger

logger = get_logger(__name__)


class PlexClientError(RuntimeError):
    """Raised when the Plex API returns an error response."""


class PlexClient:
    """Asynchronous Plex API wrapper.

    The client intentionally exposes only the pieces of the API that are
    required by Harmony.  All HTTP communication is performed with
    :mod:`aiohttp` and a very small retry helper is used to increase
    robustness when Plex temporarily fails to respond.
    """

    _DEFAULT_TIMEOUT = aiohttp.ClientTimeout(total=30)
    _RETRY_ATTEMPTS = 3
    _RETRY_BASE_DELAY = 0.25

    def __init__(self, config: PlexConfig) -> None:
        if not (config.base_url and config.token):
            raise ValueError("Plex configuration is incomplete")
        self._base_url = config.base_url.rstrip("/")
        self._token = config.token
        self._session: aiohttp.ClientSession | None = None
        self._lock = asyncio.Lock()

    async def _ensure_session(self) -> aiohttp.ClientSession:
        async with self._lock:
            if self._session is None or self._session.closed:
                self._session = aiohttp.ClientSession(timeout=self._DEFAULT_TIMEOUT)
        assert self._session is not None
        return self._session

    def _build_url(self, path: str) -> str:
        if not path.startswith("/"):
            path = f"/{path}"
        return f"{self._base_url}{path}"

    def _build_headers(self) -> Dict[str, str]:
        return {"X-Plex-Token": self._token}

    async def _request(
        self,
        method: str,
        path: str,
        *,
        params: Dict[str, Any] | None = None,
        data: Dict[str, Any] | None = None,
        json_body: Dict[str, Any] | None = None,
        expect_json: bool = True,
    ) -> Any:
        url = self._build_url(path)
        attempt = 0
        last_exception: Exception | None = None
        while attempt < self._RETRY_ATTEMPTS:
            attempt += 1
            session = await self._ensure_session()
            try:
                async with session.request(
                    method,
                    url,
                    headers=self._build_headers(),
                    params=params,
                    data=data,
                    json=json_body,
                ) as response:
                    if response.status >= 400:
                        text = await response.text()
                        raise PlexClientError(
                            f"Plex {method} {url} failed with status {response.status}: {text}"
                        )
                    if expect_json:
                        return await response.json(content_type=None)
                    return await response.text()
            except Exception as exc:  # pragma: no cover - defensive logging
                last_exception = exc
                logger.warning(
                    "Plex request error (%s %s attempt %d/%d): %s",
                    method,
                    url,
                    attempt,
                    self._RETRY_ATTEMPTS,
                    exc,
                )
                if attempt >= self._RETRY_ATTEMPTS:
                    break
                await asyncio.sleep(self._RETRY_BASE_DELAY * attempt)
        assert last_exception is not None
        raise last_exception

    async def _get(self, path: str, params: Dict[str, Any] | None = None) -> Any:
        return await self._request("GET", path, params=params)

    async def _post(
        self,
        path: str,
        *,
        params: Dict[str, Any] | None = None,
        data: Dict[str, Any] | None = None,
        json_body: Dict[str, Any] | None = None,
        expect_json: bool = True,
    ) -> Any:
        return await self._request(
            "POST", path, params=params, data=data, json_body=json_body, expect_json=expect_json
        )

    async def _put(
        self,
        path: str,
        *,
        params: Dict[str, Any] | None = None,
        data: Dict[str, Any] | None = None,
        json_body: Dict[str, Any] | None = None,
    ) -> Any:
        return await self._request("PUT", path, params=params, data=data, json_body=json_body)

    async def _delete(self, path: str, params: Dict[str, Any] | None = None) -> Any:
        return await self._request("DELETE", path, params=params)

    async def get_libraries(self, params: Dict[str, Any] | None = None) -> Any:
        """Return all Plex library sections."""

        return await self._get("/library/sections", params=params)

    async def get_library_items(
        self, section_id: str, params: Dict[str, Any] | None = None
    ) -> Any:
        """Return items for a given library section."""

        return await self._get(f"/library/sections/{section_id}/all", params=params)

    async def get_metadata(self, item_id: str) -> Any:
        return await self._get(f"/library/metadata/{item_id}")

    async def get_sessions(self) -> Any:
        return await self._get("/status/sessions")

    async def get_session_history(self, params: Dict[str, Any] | None = None) -> Any:
        return await self._get("/status/sessions/history/all", params=params)

    async def get_timeline(self, params: Dict[str, Any] | None = None) -> Any:
        return await self._get("/:/timeline", params=params)

    async def update_timeline(self, data: Dict[str, Any]) -> Any:
        return await self._post("/:/timeline", data=data, expect_json=False)

    async def scrobble(self, data: Dict[str, Any]) -> Any:
        return await self._post("/:/scrobble", data=data, expect_json=False)

    async def unscrobble(self, data: Dict[str, Any]) -> Any:
        return await self._post("/:/unscrobble", data=data, expect_json=False)

    async def get_playlists(self) -> Any:
        return await self._get("/playlists")

    async def create_playlist(self, payload: Dict[str, Any]) -> Any:
        return await self._post("/playlists", json_body=payload)

    async def update_playlist(self, playlist_id: str, payload: Dict[str, Any]) -> Any:
        return await self._put(f"/playlists/{playlist_id}", json_body=payload)

    async def delete_playlist(self, playlist_id: str) -> Any:
        return await self._delete(f"/playlists/{playlist_id}")

    async def create_playqueue(self, payload: Dict[str, Any]) -> Any:
        return await self._post("/playQueues", json_body=payload)

    async def get_playqueue(self, playqueue_id: str) -> Any:
        return await self._get(f"/playQueues/{playqueue_id}")

    async def rate_item(self, item_id: str, rating: int) -> Any:
        payload = {"key": item_id, "rating": rating}
        return await self._post("/:/rate", data=payload, expect_json=False)

    async def sync_tags(self, item_id: str, tags: Dict[str, List[str]]) -> Any:
        payload = {"key": item_id, **tags}
        return await self._post("/:/settags", json_body=payload)

    async def get_devices(self) -> Any:
        return await self._get("/devices")

    async def get_dvr(self) -> Any:
        return await self._get("/livetv/dvrs")

    async def get_live_tv(self, params: Dict[str, Any] | None = None) -> Any:
        return await self._get("/livetv", params=params)

    async def get_library_statistics(self) -> Dict[str, int]:
        """Compute high level statistics for the Plex music library."""

        stats = {"artists": 0, "albums": 0, "tracks": 0}
        libraries = await self.get_libraries()
        container = libraries.get("MediaContainer", {}) if isinstance(libraries, dict) else {}
        for section in container.get("Directory", []):
            if section.get("type") != "artist":
                continue
            section_id = section.get("key")
            if not section_id:
                continue
            items = await self.get_library_items(section_id, params={"type": "10"})
            section_container = (
                items.get("MediaContainer", {}) if isinstance(items, dict) else {}
            )
            stats["artists"] += int(section_container.get("totalSize", 0))

            albums = await self.get_library_items(section_id, params={"type": "9"})
            album_container = (
                albums.get("MediaContainer", {}) if isinstance(albums, dict) else {}
            )
            stats["albums"] += int(album_container.get("totalSize", 0))

            tracks = await self.get_library_items(section_id, params={"type": "8"})
            track_container = (
                tracks.get("MediaContainer", {}) if isinstance(tracks, dict) else {}
            )
            stats["tracks"] += int(track_container.get("totalSize", 0))
        return stats

    @asynccontextmanager
    async def listen_notifications(self) -> AsyncIterator[aiohttp.ClientWebSocketResponse]:
        """Connect to the Plex websocket notification endpoint."""

        session = await self._ensure_session()
        url = self._build_url("/:/websocket/notifications")
        headers = self._build_headers()
        async with session.ws_connect(url, headers=headers) as websocket:
            yield websocket

    async def close(self) -> None:
        if self._session and not self._session.closed:
            await self._session.close()


===== app/core/soulseek_client.py =====
"""Async client for the slskd REST API."""
from __future__ import annotations

import asyncio
import time
from collections import deque
from typing import Any, Dict, List, Optional

import aiohttp

from app.config import SoulseekConfig
from app.logging import get_logger


logger = get_logger(__name__)


class SoulseekClientError(RuntimeError):
    pass


class SoulseekClient:
    RATE_LIMIT_COUNT = 35
    RATE_LIMIT_WINDOW = 220.0

    def __init__(
        self,
        config: SoulseekConfig,
        session: Optional[aiohttp.ClientSession] = None,
    ) -> None:
        self._config = config
        self._session = session
        self._session_owner = session is None
        self._timestamps: deque[float] = deque(maxlen=self.RATE_LIMIT_COUNT)
        self._lock = asyncio.Lock()
        self._max_retries = 3

    async def _ensure_session(self) -> aiohttp.ClientSession:
        if self._session is None or self._session.closed:
            self._session = aiohttp.ClientSession()
        return self._session

    def _build_url(self, path: str) -> str:
        base = self._config.base_url.rstrip("/")
        return f"{base}/api/v0/{path.lstrip('/')}"

    def _build_headers(self) -> Dict[str, str]:
        headers = {"Content-Type": "application/json"}
        if self._config.api_key:
            headers["X-API-Key"] = self._config.api_key
        return headers

    async def _respect_rate_limit(self) -> None:
        async with self._lock:
            now = time.monotonic()
            while self._timestamps and now - self._timestamps[0] > self.RATE_LIMIT_WINDOW:
                self._timestamps.popleft()
            if len(self._timestamps) >= self.RATE_LIMIT_COUNT:
                wait_time = self.RATE_LIMIT_WINDOW - (now - self._timestamps[0])
                if wait_time > 0:
                    await asyncio.sleep(wait_time)
            self._timestamps.append(time.monotonic())

    async def _request(self, method: str, path: str, **kwargs: Any) -> Any:
        await self._respect_rate_limit()
        session = await self._ensure_session()
        url = self._build_url(path)
        headers = kwargs.pop("headers", {})
        headers = {**self._build_headers(), **headers}

        backoff = 0.5
        for attempt in range(1, self._max_retries + 1):
            try:
                async with session.request(method, url, headers=headers, **kwargs) as response:
                    if response.status >= 400:
                        content = await response.text()
                        raise SoulseekClientError(
                            f"slskd error {response.status}: {content[:200]}"
                        )
                    if "application/json" in response.headers.get("Content-Type", ""):
                        return await response.json()
                    return await response.text()
            except (aiohttp.ClientError, SoulseekClientError) as exc:
                if attempt == self._max_retries:
                    logger.error("Soulseek request failed: %s", exc)
                    raise
                await asyncio.sleep(backoff)
                backoff *= 2

    async def close(self) -> None:
        if self._session_owner and self._session and not self._session.closed:
            await self._session.close()

    async def search(self, query: str) -> Dict[str, Any]:
        payload = {"searchText": query, "filterResponses": True}
        return await self._request("POST", "searches", json=payload)

    async def download(self, payload: Dict[str, Any]) -> Dict[str, Any]:
        username = payload.get("username")
        if not username:
            raise ValueError("username is required for download requests")
        downloads = payload.get("files")
        if not isinstance(downloads, list) or not downloads:
            raise ValueError("files must be a non-empty list")
        return await self._request("POST", f"transfers/downloads/{username}", json=downloads)

    async def get_download_status(self) -> Dict[str, Any]:
        return await self._request("GET", "transfers/downloads")

    async def cancel_download(self, download_id: str) -> Dict[str, Any]:
        return await self._request("DELETE", f"transfers/downloads/{download_id}")

    async def get_download(self, download_id: str) -> Dict[str, Any]:
        return await self._request("GET", f"transfers/downloads/{download_id}")

    async def get_all_downloads(self) -> List[Dict[str, Any]]:
        result = await self._request("GET", "transfers/downloads/all")
        if isinstance(result, list):
            return result
        if isinstance(result, dict) and "downloads" in result:
            payload = result["downloads"]
            return payload if isinstance(payload, list) else [payload]
        return [result]

    async def remove_completed_downloads(self) -> Dict[str, Any]:
        return await self._request("DELETE", "transfers/downloads/completed")

    async def get_queue_position(self, download_id: str) -> Dict[str, Any]:
        return await self._request("GET", f"transfers/downloads/{download_id}/queue")

    async def enqueue(self, username: str, files: List[Dict[str, Any]]) -> Dict[str, Any]:
        if not username:
            raise ValueError("username is required for enqueue requests")
        if not isinstance(files, list) or not files:
            raise ValueError("files must be a non-empty list")
        payload = {"username": username, "files": files}
        return await self._request("POST", "transfers/enqueue", json=payload)

    async def cancel_upload(self, upload_id: str) -> Dict[str, Any]:
        return await self._request("DELETE", f"transfers/uploads/{upload_id}")

    async def get_upload(self, upload_id: str) -> Dict[str, Any]:
        return await self._request("GET", f"transfers/uploads/{upload_id}")

    async def get_uploads(self) -> List[Dict[str, Any]]:
        result = await self._request("GET", "transfers/uploads")
        if isinstance(result, list):
            return result
        if isinstance(result, dict) and "uploads" in result:
            payload = result["uploads"]
            return payload if isinstance(payload, list) else [payload]
        return [result]

    async def get_all_uploads(self) -> List[Dict[str, Any]]:
        result = await self._request("GET", "transfers/uploads/all")
        if isinstance(result, list):
            return result
        if isinstance(result, dict) and "uploads" in result:
            payload = result["uploads"]
            return payload if isinstance(payload, list) else [payload]
        return [result]

    async def remove_completed_uploads(self) -> Dict[str, Any]:
        return await self._request("DELETE", "transfers/uploads/completed")

    async def user_address(self, username: str) -> Dict[str, Any]:
        return await self._request("GET", f"users/{username}/address")

    async def user_browse(self, username: str) -> Dict[str, Any]:
        return await self._request("GET", f"users/{username}/browse")

    async def user_browsing_status(self, username: str) -> Dict[str, Any]:
        return await self._request("GET", f"users/{username}/browsing-status")

    async def user_directory(self, username: str, path: str) -> Dict[str, Any]:
        return await self._request("GET", f"users/{username}/directory", params={"path": path})

    async def user_info(self, username: str) -> Dict[str, Any]:
        return await self._request("GET", f"users/{username}/info")

    async def user_status(self, username: str) -> Dict[str, Any]:
        return await self._request("GET", f"users/{username}/status")

===== app/core/spotify_client.py =====
"""Spotify client wrapper used by Harmony."""
from __future__ import annotations

import threading
import time
from typing import Any, Dict, List, Optional

from app.config import SpotifyConfig
from app.logging import get_logger

try:  # pragma: no cover - import guard
    import spotipy
    from spotipy import Spotify
    from spotipy.oauth2 import SpotifyOAuth
    from spotipy.exceptions import SpotifyException
except Exception:  # pragma: no cover - during tests we mock the client
    spotipy = None
    Spotify = Any  # type: ignore
    SpotifyOAuth = Any  # type: ignore

    class SpotifyException(Exception):  # type: ignore
        http_status: Optional[int] = None


logger = get_logger(__name__)


class SpotifyClient:
    """High level client around Spotipy with rate limiting and retries."""

    def __init__(
        self,
        config: SpotifyConfig,
        client: Optional[Spotify] = None,
        rate_limit_seconds: float = 0.2,
        max_retries: int = 3,
    ) -> None:
        self._config = config
        self._rate_limit_seconds = rate_limit_seconds
        self._max_retries = max_retries
        self._lock = threading.Lock()
        self._last_request_time = 0.0

        if client is not None:
            self._client = client
        else:
            if spotipy is None:
                raise RuntimeError("spotipy is required for SpotifyClient but is not installed")
            if not (config.client_id and config.client_secret and config.redirect_uri):
                raise ValueError("Spotify configuration is incomplete")

            auth_manager = SpotifyOAuth(
                client_id=config.client_id,
                client_secret=config.client_secret,
                redirect_uri=config.redirect_uri,
                scope=config.scope,
            )
            self._client = spotipy.Spotify(auth_manager=auth_manager)

    def _respect_rate_limit(self) -> None:
        with self._lock:
            now = time.monotonic()
            elapsed = now - self._last_request_time
            if elapsed < self._rate_limit_seconds:
                time.sleep(self._rate_limit_seconds - elapsed)
            self._last_request_time = time.monotonic()

    def _execute(self, func, *args, **kwargs):
        backoff = 0.5
        for attempt in range(1, self._max_retries + 1):
            self._respect_rate_limit()
            try:
                return func(*args, **kwargs)
            except SpotifyException as exc:  # pragma: no cover - network errors are mocked in tests
                status = getattr(exc, "http_status", None)
                if status not in {429, 502, 503} or attempt == self._max_retries:
                    logger.error("Spotify API request failed", exc_info=exc)
                    raise
                logger.warning("Retrying Spotify API request due to status %s", status)
                time.sleep(backoff)
                backoff *= 2
            except Exception as exc:  # pragma: no cover
                if attempt == self._max_retries:
                    raise
                logger.warning("Retrying Spotify API request due to %s", exc)
                time.sleep(backoff)
                backoff *= 2

    def is_authenticated(self) -> bool:
        try:
            profile = self._execute(self._client.current_user)
        except Exception:
            return False
        return bool(profile)

    def search_tracks(self, query: str, limit: int = 20) -> Dict[str, Any]:
        return self._execute(self._client.search, q=query, type="track", limit=limit)

    def search_artists(self, query: str, limit: int = 20) -> Dict[str, Any]:
        return self._execute(self._client.search, q=query, type="artist", limit=limit)

    def search_albums(self, query: str, limit: int = 20) -> Dict[str, Any]:
        return self._execute(self._client.search, q=query, type="album", limit=limit)

    def get_user_playlists(self, limit: int = 50) -> Dict[str, Any]:
        return self._execute(self._client.current_user_playlists, limit=limit)

    def get_track_details(self, track_id: str) -> Dict[str, Any]:
        return self._execute(self._client.track, track_id)

    def get_audio_features(self, track_id: str) -> Dict[str, Any]:
        features = self._execute(self._client.audio_features, [track_id]) or []
        return features[0] if features else {}

    def get_multiple_audio_features(self, track_ids: List[str]) -> Dict[str, Any]:
        features = self._execute(self._client.audio_features, track_ids)
        return {"audio_features": features or []}

    def get_playlist_items(self, playlist_id: str, limit: int = 100) -> Dict[str, Any]:
        return self._execute(self._client.playlist_items, playlist_id, limit=limit)

    def add_tracks_to_playlist(self, playlist_id: str, track_uris: List[str]) -> Dict[str, Any]:
        return self._execute(self._client.playlist_add_items, playlist_id, track_uris)

    def remove_tracks_from_playlist(self, playlist_id: str, track_uris: List[str]) -> Dict[str, Any]:
        return self._execute(
            self._client.playlist_remove_all_occurrences_of_items, playlist_id, track_uris
        )

    def reorder_playlist_items(
        self, playlist_id: str, range_start: int, insert_before: int
    ) -> Dict[str, Any]:
        return self._execute(
            self._client.playlist_reorder_items,
            playlist_id,
            range_start=range_start,
            insert_before=insert_before,
        )

    def get_saved_tracks(self, limit: int = 20) -> Dict[str, Any]:
        return self._execute(self._client.current_user_saved_tracks, limit=limit)

    def save_tracks(self, track_ids: List[str]) -> Dict[str, Any]:
        return self._execute(self._client.current_user_saved_tracks_add, track_ids)

    def remove_saved_tracks(self, track_ids: List[str]) -> Dict[str, Any]:
        return self._execute(self._client.current_user_saved_tracks_delete, track_ids)

    def get_current_user(self) -> Dict[str, Any]:
        return self._execute(self._client.current_user)

    def get_top_tracks(self, limit: int = 20) -> Dict[str, Any]:
        return self._execute(self._client.current_user_top_tracks, limit=limit)

    def get_top_artists(self, limit: int = 20) -> Dict[str, Any]:
        return self._execute(self._client.current_user_top_artists, limit=limit)

    def get_recommendations(
        self,
        seed_tracks: Optional[List[str]] = None,
        seed_artists: Optional[List[str]] = None,
        seed_genres: Optional[List[str]] = None,
        limit: int = 20,
    ) -> Dict[str, Any]:
        params: Dict[str, Any] = {"limit": limit}
        if seed_tracks:
            params["seed_tracks"] = seed_tracks
        if seed_artists:
            params["seed_artists"] = seed_artists
        if seed_genres:
            params["seed_genres"] = seed_genres
        return self._execute(self._client.recommendations, **params)

===== app/db.py =====
"""Database configuration and helper utilities."""
from __future__ import annotations

from contextlib import contextmanager
from pathlib import Path
from typing import Iterator, Optional

from sqlalchemy import Engine, create_engine
from sqlalchemy.engine import make_url
from sqlalchemy.orm import DeclarativeBase, Session, sessionmaker

from app.config import load_config


class Base(DeclarativeBase):
    pass


_engine: Optional[Engine] = None
SessionLocal: Optional[sessionmaker[Session]] = None
_configured_database_url: Optional[str] = None
_initializing_db: bool = False


def _build_engine(database_url: str) -> Engine:
    connect_args = {"check_same_thread": False} if database_url.startswith("sqlite") else {}
    return create_engine(database_url, connect_args=connect_args)


def _resolve_sqlite_path(database_url: str) -> Optional[Path]:
    try:
        url = make_url(database_url)
    except Exception:  # pragma: no cover - defensive parsing
        return None

    if url.get_backend_name() != "sqlite":
        return None

    database = url.database or ""
    if database in {":memory:", ""}:
        return None

    return Path(database)


def _ensure_engine(*, auto_init: bool = True) -> None:
    global _engine, SessionLocal, _configured_database_url, _initializing_db

    config = load_config()
    database_url = config.database.url
    sqlite_path = _resolve_sqlite_path(database_url)

    reuse_existing = False
    if _engine is not None and database_url == _configured_database_url:
        if sqlite_path is None or sqlite_path.exists() or not auto_init:
            reuse_existing = True

    if reuse_existing:
        return

    if _engine is not None:
        _engine.dispose()

    _engine = _build_engine(database_url)
    SessionLocal = sessionmaker(
        bind=_engine,
        autoflush=False,
        autocommit=False,
        expire_on_commit=False,
    )
    _configured_database_url = database_url

    if (
        auto_init
        and not _initializing_db
        and sqlite_path is not None
        and not sqlite_path.exists()
    ):
        init_db()


def get_session() -> Session:
    if SessionLocal is None:
        _ensure_engine()
    assert SessionLocal is not None  # For type checkers
    return SessionLocal()


@contextmanager
def session_scope() -> Iterator[Session]:
    session = get_session()
    try:
        yield session
        session.commit()
    except Exception:
        session.rollback()
        raise
    finally:
        session.close()


def init_db() -> None:
    global _initializing_db

    if _initializing_db:
        return

    _initializing_db = True
    try:
        _ensure_engine(auto_init=False)
        assert _engine is not None
        from app import models  # Import models for metadata

        Base.metadata.create_all(bind=_engine)
    finally:
        _initializing_db = False


def reset_engine_for_tests() -> None:
    """Reset the cached engine/session so tests get a clean database handle."""

    global _engine, SessionLocal, _configured_database_url, _initializing_db

    if _engine is not None:
        _engine.dispose()

    _engine = None
    SessionLocal = None
    _configured_database_url = None
    _initializing_db = False


__all__ = [
    "Base",
    "SessionLocal",
    "get_session",
    "session_scope",
    "init_db",
    "reset_engine_for_tests",
    "_engine",
]

===== app/dependencies.py =====
"""FastAPI dependency providers."""
from __future__ import annotations

from functools import lru_cache
from typing import Generator

from sqlalchemy.orm import Session

from app.config import AppConfig, load_config
from app.core.matching_engine import MusicMatchingEngine
from app.core.plex_client import PlexClient
from app.core.soulseek_client import SoulseekClient
from app.core.spotify_client import SpotifyClient
from app.db import get_session


@lru_cache()
def get_app_config() -> AppConfig:
    return load_config()


@lru_cache()
def get_spotify_client() -> SpotifyClient:
    return SpotifyClient(get_app_config().spotify)


@lru_cache()
def get_plex_client() -> PlexClient:
    return PlexClient(get_app_config().plex)


@lru_cache()
def get_soulseek_client() -> SoulseekClient:
    return SoulseekClient(get_app_config().soulseek)


@lru_cache()
def get_matching_engine() -> MusicMatchingEngine:
    return MusicMatchingEngine()


def get_db() -> Generator[Session, None, None]:
    session = get_session()
    try:
        yield session
    finally:
        session.close()

===== app/logging.py =====
"""Logging configuration utilities."""
from __future__ import annotations

import logging
import sys
from typing import Optional


LOG_FORMAT = "%(asctime)s [%(levelname)s] %(name)s: %(message)s"


def configure_logging(level: str = "INFO", log_file: Optional[str] = None) -> None:
    """Configure application wide logging handlers."""
    handlers: list[logging.Handler] = [logging.StreamHandler(sys.stdout)]
    if log_file:
        handlers.append(logging.FileHandler(log_file))

    logging.basicConfig(
        level=getattr(logging, level.upper(), logging.INFO),
        format=LOG_FORMAT,
        handlers=handlers,
        force=True,
    )


def get_logger(name: str) -> logging.Logger:
    return logging.getLogger(name)

===== app/main.py =====
"""Entry point for the Harmony FastAPI application."""
from __future__ import annotations

import os

import inspect

from fastapi import FastAPI

from app.dependencies import (
    get_app_config,
    get_matching_engine,
    get_plex_client,
    get_soulseek_client,
    get_spotify_client,
)
from app.db import init_db
from app.logging import configure_logging, get_logger
from app.routers import matching_router, plex_router, settings_router, soulseek_router, spotify_router
from app.workers import MatchingWorker, PlaylistSyncWorker, ScanWorker, SyncWorker

app = FastAPI(title="Harmony Backend", version="1.4.0")
logger = get_logger(__name__)

app.include_router(spotify_router, prefix="/spotify", tags=["Spotify"])
app.include_router(plex_router, prefix="/plex", tags=["Plex"])
app.include_router(soulseek_router, prefix="/soulseek", tags=["Soulseek"])
app.include_router(matching_router, prefix="/matching", tags=["Matching"])
app.include_router(settings_router, prefix="/settings", tags=["Settings"])


@app.on_event("startup")
async def startup_event() -> None:
    config = get_app_config()
    configure_logging(config.logging.level)
    init_db()
    logger.info("Database initialised")

    if os.getenv("HARMONY_DISABLE_WORKERS") not in {"1", "true", "TRUE"}:
        soulseek_client = get_soulseek_client()
        matching_engine = get_matching_engine()
        plex_client = get_plex_client()
        spotify_client = get_spotify_client()

        app.state.sync_worker = SyncWorker(soulseek_client)
        await app.state.sync_worker.start()

        app.state.matching_worker = MatchingWorker(matching_engine)
        await app.state.matching_worker.start()

        app.state.scan_worker = ScanWorker(plex_client)
        await app.state.scan_worker.start()

        app.state.playlist_worker = PlaylistSyncWorker(spotify_client)
        await app.state.playlist_worker.start()

    logger.info("Harmony application started")


@app.on_event("shutdown")
async def shutdown_event() -> None:
    if worker := getattr(app.state, "sync_worker", None):
        await worker.stop()
    if worker := getattr(app.state, "matching_worker", None):
        await worker.stop()
    if worker := getattr(app.state, "scan_worker", None):
        await worker.stop()
    if worker := getattr(app.state, "playlist_worker", None):
        await worker.stop()
    try:
        plex_client = get_plex_client()
    except ValueError:
        plex_client = None
    close_fn = getattr(plex_client, "close", None)
    if callable(close_fn):
        result = close_fn()
        if inspect.isawaitable(result):
            await result
    logger.info("Harmony application stopped")


@app.get("/")
async def root() -> dict[str, str]:
    return {"status": "ok", "version": app.version}

===== app/models.py =====
"""Database models for Harmony."""
from __future__ import annotations

from datetime import datetime

from sqlalchemy import Column, DateTime, Float, Integer, String, Text

from app.db import Base


class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    username = Column(String(255), unique=True, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)


class Playlist(Base):
    __tablename__ = "playlists"

    id = Column(String(128), primary_key=True)
    name = Column(String(512), nullable=False)
    track_count = Column(Integer, nullable=False, default=0)
    updated_at = Column(
        DateTime,
        default=datetime.utcnow,
        onupdate=datetime.utcnow,
        nullable=False,
    )


class Download(Base):
    __tablename__ = "downloads"

    id = Column(Integer, primary_key=True, index=True)
    filename = Column(String(1024), nullable=False)
    state = Column(String(50), nullable=False, default="queued")
    progress = Column(Float, nullable=False, default=0.0)
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(
        DateTime,
        default=datetime.utcnow,
        onupdate=datetime.utcnow,
        nullable=False,
    )


class Match(Base):
    __tablename__ = "matches"

    id = Column(Integer, primary_key=True, index=True)
    source = Column(String(50), nullable=False)
    spotify_track_id = Column(String(128), index=True, nullable=False)
    target_id = Column(String(128), nullable=True)
    confidence = Column(Float, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)


class Setting(Base):
    __tablename__ = "settings"

    id = Column(Integer, primary_key=True, index=True)
    key = Column(String(255), unique=True, nullable=False)
    value = Column(Text, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)


class SettingHistory(Base):
    __tablename__ = "settings_history"

    id = Column(Integer, primary_key=True, index=True)
    key = Column(String(255), nullable=False)
    old_value = Column(Text, nullable=True)
    new_value = Column(Text, nullable=True)
    changed_at = Column(DateTime, default=datetime.utcnow, nullable=False)

===== app/routers/__init__.py =====
"""Expose API routers."""
from .matching_router import router as matching_router
from .plex_router import router as plex_router
from .settings_router import router as settings_router
from .soulseek_router import router as soulseek_router
from .spotify_router import router as spotify_router

__all__ = [
    "matching_router",
    "plex_router",
    "settings_router",
    "soulseek_router",
    "spotify_router",
]

===== app/routers/beets_router.py =====
from typing import List, Optional

from fastapi import APIRouter, HTTPException
from fastapi.concurrency import run_in_threadpool
from pydantic import BaseModel

from app.core.beets_client import BeetsClient, BeetsClientError
from app.utils.logging_config import get_logger

logger = get_logger("beets_router")

router = APIRouter()
beets_client = BeetsClient()


# ----------------------------
# Request / Response Schemas
# ----------------------------


class ImportRequest(BaseModel):
    path: str
    quiet: bool = True
    autotag: bool = True


class ImportResponse(BaseModel):
    success: bool
    message: str


class UpdateRequest(BaseModel):
    path: Optional[str] = None


class UpdateResponse(BaseModel):
    success: bool
    message: str


class RemoveRequest(BaseModel):
    query: str
    force: bool = False


class RemoveResponse(BaseModel):
    success: bool
    removed: Optional[int] = None
    output: Optional[str] = None


class MoveRequest(BaseModel):
    query: Optional[str] = None


class MoveResponse(BaseModel):
    success: bool
    moved: Optional[int] = None
    output: Optional[str] = None


class WriteRequest(BaseModel):
    query: Optional[str] = None


class WriteResponse(BaseModel):
    success: bool
    written: Optional[int] = None
    output: Optional[str] = None


class ListAlbumsResponse(BaseModel):
    albums: List[str]


class ListTracksResponse(BaseModel):
    tracks: List[str]


class FieldsResponse(BaseModel):
    fields: List[str]


class QueryRequest(BaseModel):
    query: str
    format: str = "$artist - $album - $title"


class QueryResponse(BaseModel):
    results: List[str]


# ----------------------------
# Helper functions
# ----------------------------


async def _call_client(method, *args, **kwargs):
    try:
        return await run_in_threadpool(method, *args, **kwargs)
    except BeetsClientError as exc:
        detail = str(exc)
        if detail.startswith("Invalid query syntax"):
            logger.error("Invalid query syntax: %s", detail)
            raise HTTPException(status_code=400, detail="Invalid query syntax") from exc
        if detail == "Query must not be empty":
            logger.error("Empty query provided")
            raise HTTPException(status_code=400, detail=detail) from exc
        logger.error("Beets client error: %s", detail)
        raise HTTPException(status_code=500, detail=detail) from exc
    except Exception as exc:  # pragma: no cover - defensive
        logger.error("Unexpected error running beets: %s", exc)
        raise HTTPException(status_code=500, detail=str(exc)) from exc


# ----------------------------
# Endpoints
# ----------------------------


@router.post("/import", response_model=ImportResponse)
async def import_music(req: ImportRequest) -> ImportResponse:
    """Import new music into the Beets library."""

    output = await _call_client(
        beets_client.import_file,
        req.path,
        quiet=req.quiet,
        autotag=req.autotag,
    )
    return ImportResponse(success=True, message=output or "Import completed")


@router.post("/update", response_model=UpdateResponse)
async def update_library(req: UpdateRequest) -> UpdateResponse:
    """Update Beets library metadata, optionally for a specific path."""

    output = await _call_client(beets_client.update, req.path)
    return UpdateResponse(success=True, message=output or "Library updated")


@router.post(
    "/remove", response_model=RemoveResponse, response_model_exclude_none=True
)
async def remove_items(req: RemoveRequest) -> RemoveResponse:
    """Remove library items that match a query."""

    result = await _call_client(beets_client.remove, req.query, force=req.force)
    return RemoveResponse(**result)


@router.post(
    "/move", response_model=MoveResponse, response_model_exclude_none=True
)
async def move_items(req: MoveRequest) -> MoveResponse:
    """Move files in the Beets library, optionally filtering by a query."""

    result = await _call_client(beets_client.move, req.query)
    return MoveResponse(**result)


@router.post(
    "/write", response_model=WriteResponse, response_model_exclude_none=True
)
async def write_tags(req: WriteRequest) -> WriteResponse:
    """Write tags to files, optionally filtering by a query."""

    result = await _call_client(beets_client.write, req.query)
    return WriteResponse(**result)


@router.get("/albums", response_model=ListAlbumsResponse)
async def list_albums() -> ListAlbumsResponse:
    """List all albums managed by Beets."""

    albums = await _call_client(beets_client.list_albums)
    return ListAlbumsResponse(albums=albums)


@router.get("/tracks", response_model=ListTracksResponse)
async def list_tracks() -> ListTracksResponse:
    """List all track titles managed by Beets."""

    tracks = await _call_client(beets_client.list_tracks)
    return ListTracksResponse(tracks=tracks)


@router.get("/stats")
async def library_stats() -> dict:
    """Return statistics about the Beets library."""

    stats = await _call_client(beets_client.stats)
    return {"stats": stats}


@router.get("/fields", response_model=FieldsResponse)
async def list_fields() -> FieldsResponse:
    """Return all available Beets fields."""

    fields = await _call_client(beets_client.fields)
    return FieldsResponse(fields=fields)


@router.post("/query", response_model=QueryResponse)
async def run_query(req: QueryRequest) -> QueryResponse:
    """Execute a formatted Beets query."""

    results = await _call_client(
        beets_client.query, req.query, fmt=req.format
    )
    return QueryResponse(results=results)

===== app/routers/matching_router.py =====
"""Matching endpoints for Harmony."""
from __future__ import annotations

from typing import Any, Dict, Optional

from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session

from app.core.matching_engine import MusicMatchingEngine
from app.dependencies import get_db, get_matching_engine
from app.logging import get_logger
from app.models import Match
from app.schemas import AlbumMatchingRequest, MatchingRequest, MatchingResponse

logger = get_logger(__name__)

router = APIRouter()


def _extract_target_id(candidate: Optional[Dict[str, Any]]) -> Optional[str]:
    if not candidate:
        return None
    for key in ("id", "ratingKey", "filename"):
        value = candidate.get(key)
        if value is not None:
            return str(value)
    return None


def _persist_match(session: Session, match: Match) -> None:
    """Persist a match, rolling back on failure."""

    try:
        session.add(match)
        session.commit()
    except Exception as exc:  # pragma: no cover - database failure is exceptional
        session.rollback()
        logger.error("Failed to persist match %s: %s", match, exc)
        raise HTTPException(status_code=500, detail="Failed to store match result") from exc


@router.post("/spotify-to-plex", response_model=MatchingResponse)
def spotify_to_plex(
    payload: MatchingRequest,
    engine: MusicMatchingEngine = Depends(get_matching_engine),
    session: Session = Depends(get_db),
) -> MatchingResponse:
    """Match a Spotify track against Plex candidates and persist the result."""

    best_match, confidence = engine.find_best_match(payload.spotify_track, payload.candidates)
    target_id = _extract_target_id(best_match)
    match = Match(
        source="spotify-to-plex",
        spotify_track_id=str(payload.spotify_track.get("id")),
        target_id=target_id,
        confidence=confidence,
    )
    _persist_match(session, match)
    return MatchingResponse(best_match=best_match, confidence=confidence)


@router.post("/spotify-to-soulseek", response_model=MatchingResponse)
def spotify_to_soulseek(
    payload: MatchingRequest,
    engine: MusicMatchingEngine = Depends(get_matching_engine),
    session: Session = Depends(get_db),
) -> MatchingResponse:
    """Match a Spotify track against Soulseek candidates and persist the result."""

    best_candidate: Optional[Dict[str, Any]] = None
    best_score = 0.0
    for candidate in payload.candidates:
        score = engine.calculate_slskd_match_confidence(payload.spotify_track, candidate)
        if score > best_score:
            best_score = score
            best_candidate = candidate
    target_id = _extract_target_id(best_candidate)
    match = Match(
        source="spotify-to-soulseek",
        spotify_track_id=str(payload.spotify_track.get("id")),
        target_id=target_id,
        confidence=best_score,
    )
    _persist_match(session, match)
    return MatchingResponse(best_match=best_candidate, confidence=best_score)


@router.post("/spotify-to-plex-album", response_model=MatchingResponse)
def spotify_to_plex_album(
    payload: AlbumMatchingRequest, engine: MusicMatchingEngine = Depends(get_matching_engine)
) -> MatchingResponse:
    """Return the best matching Plex album for the provided Spotify album."""

    best_match, confidence = engine.find_best_album_match(payload.spotify_album, payload.candidates)
    return MatchingResponse(best_match=best_match, confidence=confidence)

===== app/routers/plex_router.py =====
"""Extended Plex API endpoints exposed through FastAPI."""
from __future__ import annotations

from typing import Any, AsyncIterator, Dict

from fastapi import APIRouter, Depends, HTTPException, Request, status
from fastapi.responses import StreamingResponse

from app.core.plex_client import PlexClient, PlexClientError
from app.dependencies import get_plex_client
from app.logging import get_logger

logger = get_logger(__name__)

router = APIRouter()


def _collect_query_params(request: Request) -> Dict[str, Any]:
    return {key: value for key, value in request.query_params.multi_items()}


@router.get("/status")
async def plex_status(client: PlexClient = Depends(get_plex_client)) -> Dict[str, Any]:
    try:
        sessions = await client.get_sessions()
        stats = await client.get_library_statistics()
    except Exception as exc:  # pragma: no cover - defensive logging
        logger.error("Failed to query Plex status: %s", exc)
        return {"status": "disconnected"}
    return {"status": "connected", "sessions": sessions, "library": stats}


@router.get("/library/sections")
async def list_libraries(
    request: Request, client: PlexClient = Depends(get_plex_client)
) -> Dict[str, Any]:
    try:
        params = _collect_query_params(request)
        return await client.get_libraries(params=params or None)
    except PlexClientError as exc:
        raise HTTPException(status_code=status.HTTP_502_BAD_GATEWAY, detail=str(exc)) from exc


@router.get("/libraries", include_in_schema=False)
async def list_libraries_legacy(
    request: Request, client: PlexClient = Depends(get_plex_client)
) -> Dict[str, Any]:
    """Backward compatible alias for :func:`list_libraries`."""

    return await list_libraries(request, client)


@router.get("/library/sections/{section_id}/all")
async def browse_library(
    section_id: str, request: Request, client: PlexClient = Depends(get_plex_client)
) -> Dict[str, Any]:
    try:
        params = _collect_query_params(request)
        return await client.get_library_items(section_id, params=params or None)
    except PlexClientError as exc:
        raise HTTPException(status_code=status.HTTP_502_BAD_GATEWAY, detail=str(exc)) from exc


@router.get("/library/{section_id}/items", include_in_schema=False)
async def browse_library_legacy(
    section_id: str, request: Request, client: PlexClient = Depends(get_plex_client)
) -> Dict[str, Any]:
    """Backward compatible alias for :func:`browse_library`."""

    return await browse_library(section_id, request, client)


@router.get("/library/metadata/{item_id}")
async def fetch_metadata(item_id: str, client: PlexClient = Depends(get_plex_client)) -> Dict[str, Any]:
    try:
        return await client.get_metadata(item_id)
    except PlexClientError as exc:
        raise HTTPException(status_code=status.HTTP_502_BAD_GATEWAY, detail=str(exc)) from exc


@router.get("/metadata/{item_id}", include_in_schema=False)
async def fetch_metadata_legacy(
    item_id: str, client: PlexClient = Depends(get_plex_client)
) -> Dict[str, Any]:
    """Backward compatible alias for :func:`fetch_metadata`."""

    return await fetch_metadata(item_id, client)


@router.get("/status/sessions")
async def active_sessions(client: PlexClient = Depends(get_plex_client)) -> Dict[str, Any]:
    return await client.get_sessions()


@router.get("/sessions", include_in_schema=False)
async def active_sessions_legacy(client: PlexClient = Depends(get_plex_client)) -> Dict[str, Any]:
    """Backward compatible alias for :func:`active_sessions`."""

    return await active_sessions(client)


@router.get("/status/sessions/history/all")
async def session_history(
    request: Request, client: PlexClient = Depends(get_plex_client)
) -> Dict[str, Any]:
    params = _collect_query_params(request)
    return await client.get_session_history(params=params or None)


@router.get("/history", include_in_schema=False)
async def session_history_legacy(
    request: Request, client: PlexClient = Depends(get_plex_client)
) -> Dict[str, Any]:
    """Backward compatible alias for :func:`session_history`."""

    return await session_history(request, client)


@router.get("/timeline")
async def get_timeline(
    request: Request, client: PlexClient = Depends(get_plex_client)
) -> Dict[str, Any]:
    params = _collect_query_params(request)
    return await client.get_timeline(params=params or None)


@router.post("/timeline")
async def post_timeline(payload: Dict[str, Any], client: PlexClient = Depends(get_plex_client)) -> str:
    return await client.update_timeline(payload)


@router.post("/scrobble")
async def post_scrobble(payload: Dict[str, Any], client: PlexClient = Depends(get_plex_client)) -> str:
    return await client.scrobble(payload)


@router.post("/unscrobble")
async def post_unscrobble(payload: Dict[str, Any], client: PlexClient = Depends(get_plex_client)) -> str:
    return await client.unscrobble(payload)


@router.get("/playlists")
async def list_playlists(client: PlexClient = Depends(get_plex_client)) -> Dict[str, Any]:
    return await client.get_playlists()


@router.post("/playlists")
async def create_playlist(
    payload: Dict[str, Any], client: PlexClient = Depends(get_plex_client)
) -> Dict[str, Any]:
    return await client.create_playlist(payload)


@router.put("/playlists/{playlist_id}")
async def update_playlist(
    playlist_id: str, payload: Dict[str, Any], client: PlexClient = Depends(get_plex_client)
) -> Dict[str, Any]:
    return await client.update_playlist(playlist_id, payload)


@router.delete("/playlists/{playlist_id}")
async def delete_playlist(playlist_id: str, client: PlexClient = Depends(get_plex_client)) -> Dict[str, Any]:
    return await client.delete_playlist(playlist_id)


@router.post("/playQueues")
async def create_playqueue(
    payload: Dict[str, Any], client: PlexClient = Depends(get_plex_client)
) -> Dict[str, Any]:
    return await client.create_playqueue(payload)


@router.get("/playQueues/{playqueue_id}")
async def get_playqueue(playqueue_id: str, client: PlexClient = Depends(get_plex_client)) -> Dict[str, Any]:
    return await client.get_playqueue(playqueue_id)


@router.post("/rate")
async def rate_item(payload: Dict[str, Any], client: PlexClient = Depends(get_plex_client)) -> str:
    item_id = payload.get("key")
    rating = payload.get("rating")
    if not item_id or rating is None:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Both 'key' and 'rating' must be provided",
        )
    return await client.rate_item(str(item_id), int(rating))


@router.post("/rate/{item_id}", include_in_schema=False)
async def rate_item_legacy(
    item_id: str, rating: int, client: PlexClient = Depends(get_plex_client)
) -> str:
    """Backward compatible alias for :func:`rate_item`."""

    return await client.rate_item(item_id, rating)


@router.post("/tags/{item_id}")
async def sync_tags(
    item_id: str, payload: Dict[str, Any], client: PlexClient = Depends(get_plex_client)
) -> Dict[str, Any]:
    tags = {key: value for key, value in payload.items() if isinstance(value, list)}
    return await client.sync_tags(item_id, tags)


@router.get("/devices")
async def list_devices(client: PlexClient = Depends(get_plex_client)) -> Dict[str, Any]:
    return await client.get_devices()


@router.get("/dvr")
async def list_dvr(client: PlexClient = Depends(get_plex_client)) -> Dict[str, Any]:
    return await client.get_dvr()


@router.get("/livetv")
async def list_live_tv(
    request: Request, client: PlexClient = Depends(get_plex_client)
) -> Dict[str, Any]:
    params = _collect_query_params(request)
    return await client.get_live_tv(params=params or None)


@router.get("/notifications")
async def listen_notifications(client: PlexClient = Depends(get_plex_client)) -> StreamingResponse:
    async def event_stream() -> AsyncIterator[bytes]:
        try:
            async with client.listen_notifications() as websocket:
                async for message in websocket:
                    if message.type.name == "TEXT":
                        yield f"data: {message.data}\n\n".encode("utf-8")
                    elif message.type.name == "ERROR":
                        logger.error("Plex notification stream error: %s", websocket.exception())
                        break
        except Exception as exc:  # pragma: no cover - defensive logging
            logger.error("Failed to stream Plex notifications: %s", exc)
            yield f"event: error\ndata: {exc}\n\n".encode("utf-8")

    return StreamingResponse(event_stream(), media_type="text/event-stream")


===== app/routers/settings_router.py =====
"""Settings management endpoints."""
from __future__ import annotations

from datetime import datetime

from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy import select
from sqlalchemy.orm import Session

from app.dependencies import get_db
from app.models import Setting, SettingHistory
from app.schemas import SettingsHistoryResponse, SettingsPayload, SettingsResponse

router = APIRouter()


@router.get("", response_model=SettingsResponse)
def get_settings(session: Session = Depends(get_db)) -> SettingsResponse:
    settings = session.execute(select(Setting)).scalars().all()
    settings_dict = {setting.key: setting.value for setting in settings}
    updated_at = max((setting.updated_at or setting.created_at for setting in settings), default=datetime.utcnow())
    return SettingsResponse(settings=settings_dict, updated_at=updated_at)


@router.post("", response_model=SettingsResponse)
def update_setting(payload: SettingsPayload, session: Session = Depends(get_db)) -> SettingsResponse:
    if not payload.key:
        raise HTTPException(status_code=400, detail="Key must not be empty")
    setting = session.execute(select(Setting).where(Setting.key == payload.key)).scalar_one_or_none()
    now = datetime.utcnow()

    history_entry = SettingHistory(
        key=payload.key,
        old_value=setting.value if setting is not None else None,
        new_value=payload.value,
        changed_at=now,
    )
    session.add(history_entry)

    if setting is None:
        setting = Setting(key=payload.key, value=payload.value, updated_at=now)
        session.add(setting)
    else:
        setting.value = payload.value
        setting.updated_at = now
    session.commit()
    return get_settings(session)


@router.get("/history", response_model=SettingsHistoryResponse)
def get_settings_history(session: Session = Depends(get_db)) -> SettingsHistoryResponse:
    history_entries = (
        session.execute(
            select(SettingHistory).order_by(SettingHistory.changed_at.desc()).limit(50)
        )
        .scalars()
        .all()
    )
    return SettingsHistoryResponse(history=history_entries)

===== app/routers/soulseek_router.py =====
"""Soulseek API endpoints."""
from __future__ import annotations

import asyncio
from datetime import datetime
from typing import Any, Dict, List

from fastapi import APIRouter, Depends, HTTPException, Query, Request
from sqlalchemy import select
from sqlalchemy.orm import Session

from app.core.soulseek_client import SoulseekClient, SoulseekClientError
from app.dependencies import get_db, get_soulseek_client
from app.logging import get_logger
from app.models import Download
from app.schemas import (
    SoulseekCancelResponse,
    SoulseekDownloadRequest,
    SoulseekDownloadResponse,
    SoulseekDownloadStatus,
    SoulseekSearchRequest,
    SoulseekSearchResponse,
    StatusResponse,
)

logger = get_logger(__name__)

router = APIRouter()


def _translate_error(message: str, exc: SoulseekClientError) -> HTTPException:
    logger.error("%s: %s", message, exc)
    return HTTPException(status_code=502, detail=message)


@router.get("/status", response_model=StatusResponse)
async def soulseek_status(client: SoulseekClient = Depends(get_soulseek_client)) -> StatusResponse:
    """Return connectivity status for the Soulseek daemon."""

    try:
        await client.get_download_status()
    except Exception as exc:  # pragma: no cover - defensive
        logger.warning("Soulseek status check failed: %s", exc)
        return StatusResponse(status="disconnected")
    return StatusResponse(status="connected")


@router.post("/search", response_model=SoulseekSearchResponse)
async def soulseek_search(
    payload: SoulseekSearchRequest,
    client: SoulseekClient = Depends(get_soulseek_client),
) -> SoulseekSearchResponse:
    """Perform a Soulseek search and normalise the JSON response."""

    try:
        results = await client.search(payload.query)
    except SoulseekClientError as exc:
        logger.error("Soulseek search failed: %s", exc)
        raise HTTPException(status_code=502, detail="Soulseek search failed") from exc
    items: list[Any]
    raw_payload: Dict[str, Any] | None = None
    if isinstance(results, dict):
        raw_payload = results
        extracted = results.get("results", [])
        items = extracted if isinstance(extracted, list) else [extracted]
    elif isinstance(results, list):
        items = results
    else:
        items = [results] if results else []
    return SoulseekSearchResponse(results=items, raw=raw_payload)


@router.post("/download", response_model=SoulseekDownloadResponse)
async def soulseek_download(
    payload: SoulseekDownloadRequest,
    request: Request,
    session: Session = Depends(get_db),
    client: SoulseekClient = Depends(get_soulseek_client),
) -> SoulseekDownloadResponse:
    """Queue a Soulseek download job and persist queued entries."""

    if not payload.files:
        raise HTTPException(status_code=400, detail="No files provided for download")

    created_downloads: List[Dict[str, Any]] = []
    job_files: List[Dict[str, Any]] = []
    try:
        for file_info in payload.files:
            filename = str(file_info.get("filename") or file_info.get("name") or "unknown")
            download = Download(filename=filename, state="queued", progress=0.0)
            session.add(download)
            session.flush()

            payload_copy = dict(file_info)
            payload_copy.setdefault("filename", filename)
            payload_copy["download_id"] = download.id
            job_files.append(payload_copy)

            created_downloads.append(
                {
                    "id": download.id,
                    "filename": filename,
                    "state": download.state,
                    "progress": download.progress,
                }
            )
        session.commit()
    except Exception as exc:  # pragma: no cover - defensive
        session.rollback()
        logger.error("Failed to persist download request: %s", exc)
        raise HTTPException(status_code=500, detail="Failed to queue download") from exc

    job = {"username": payload.username, "files": job_files}

    worker = getattr(request.app.state, "sync_worker", None)
    try:
        if worker is not None and hasattr(worker, "enqueue"):
            await worker.enqueue(job)
        else:
            await client.download(job)
    except Exception as exc:
        if isinstance(exc, asyncio.CancelledError):  # pragma: no cover - defensive
            raise
        logger.error("Soulseek rejected download queue request: %s", exc)
        for record in job_files:
            download = session.get(Download, record["download_id"])
            if download is None:
                continue
            download.state = "failed"
            download.updated_at = datetime.utcnow()
        session.commit()
        raise HTTPException(status_code=502, detail="Soulseek download failed") from exc

    detail: Dict[str, Any] = {"downloads": created_downloads}
    return SoulseekDownloadResponse(status="queued", detail=detail)


@router.get("/downloads", response_model=SoulseekDownloadStatus)
def soulseek_downloads(session: Session = Depends(get_db)) -> SoulseekDownloadStatus:
    """Return persisted download progress from the database."""

    stmt = select(Download).order_by(Download.created_at.desc())
    downloads = session.execute(stmt).scalars().all()
    return SoulseekDownloadStatus(downloads=downloads)


@router.delete("/download/{download_id}", response_model=SoulseekCancelResponse)
async def soulseek_cancel(
    download_id: int,
    session: Session = Depends(get_db),
    client: SoulseekClient = Depends(get_soulseek_client),
) -> SoulseekCancelResponse:
    """Cancel a Soulseek download by identifier."""

    download = session.get(Download, download_id)
    if download is None:
        raise HTTPException(status_code=404, detail="Download not found")

    try:
        await client.cancel_download(str(download_id))
    except SoulseekClientError as exc:
        raise _translate_error("Failed to cancel download", exc)

    download.state = "failed"
    if download.progress < 0:
        download.progress = 0.0
    elif download.progress > 100:
        download.progress = 100.0
    download.updated_at = datetime.utcnow()
    session.commit()

    return SoulseekCancelResponse(cancelled=True)


@router.get("/download/{download_id}")
async def soulseek_download_detail(
    download_id: str,
    client: SoulseekClient = Depends(get_soulseek_client),
) -> Dict[str, Any]:
    try:
        return await client.get_download(download_id)
    except SoulseekClientError as exc:
        raise _translate_error("Failed to fetch download", exc) from exc


@router.get("/downloads/all")
async def soulseek_all_downloads(client: SoulseekClient = Depends(get_soulseek_client)) -> Dict[str, Any]:
    try:
        downloads = await client.get_all_downloads()
    except SoulseekClientError as exc:
        raise _translate_error("Failed to fetch downloads", exc) from exc
    return {"downloads": downloads}


@router.delete("/downloads/completed")
async def soulseek_remove_completed_downloads(
    client: SoulseekClient = Depends(get_soulseek_client),
) -> Dict[str, Any]:
    try:
        return await client.remove_completed_downloads()
    except SoulseekClientError as exc:
        raise _translate_error("Failed to remove completed downloads", exc) from exc


@router.get("/download/{download_id}/queue")
async def soulseek_download_queue(
    download_id: str,
    client: SoulseekClient = Depends(get_soulseek_client),
) -> Dict[str, Any]:
    try:
        return await client.get_queue_position(download_id)
    except SoulseekClientError as exc:
        raise _translate_error("Failed to fetch queue position", exc) from exc


@router.post("/enqueue")
async def soulseek_enqueue(
    payload: SoulseekDownloadRequest,
    client: SoulseekClient = Depends(get_soulseek_client),
) -> Dict[str, Any]:
    try:
        return await client.enqueue(payload.username, payload.files)
    except SoulseekClientError as exc:
        raise _translate_error("Failed to enqueue downloads", exc) from exc


@router.delete("/upload/{upload_id}")
async def soulseek_cancel_upload(
    upload_id: str,
    client: SoulseekClient = Depends(get_soulseek_client),
) -> Dict[str, Any]:
    try:
        return await client.cancel_upload(upload_id)
    except SoulseekClientError as exc:
        raise _translate_error("Failed to cancel upload", exc) from exc


@router.get("/upload/{upload_id}")
async def soulseek_upload_detail(
    upload_id: str,
    client: SoulseekClient = Depends(get_soulseek_client),
) -> Dict[str, Any]:
    try:
        return await client.get_upload(upload_id)
    except SoulseekClientError as exc:
        raise _translate_error("Failed to fetch upload", exc) from exc


@router.get("/uploads")
async def soulseek_uploads(client: SoulseekClient = Depends(get_soulseek_client)) -> Dict[str, Any]:
    try:
        uploads = await client.get_uploads()
    except SoulseekClientError as exc:
        raise _translate_error("Failed to fetch uploads", exc) from exc
    return {"uploads": uploads}


@router.get("/uploads/all")
async def soulseek_all_uploads(client: SoulseekClient = Depends(get_soulseek_client)) -> Dict[str, Any]:
    try:
        uploads = await client.get_all_uploads()
    except SoulseekClientError as exc:
        raise _translate_error("Failed to fetch all uploads", exc) from exc
    return {"uploads": uploads}


@router.delete("/uploads/completed")
async def soulseek_remove_completed_uploads(
    client: SoulseekClient = Depends(get_soulseek_client),
) -> Dict[str, Any]:
    try:
        return await client.remove_completed_uploads()
    except SoulseekClientError as exc:
        raise _translate_error("Failed to remove completed uploads", exc) from exc


@router.get("/user/{username}/address")
async def soulseek_user_address(
    username: str,
    client: SoulseekClient = Depends(get_soulseek_client),
) -> Dict[str, Any]:
    try:
        return await client.user_address(username)
    except SoulseekClientError as exc:
        raise _translate_error("Failed to fetch user address", exc) from exc


@router.get("/user/{username}/browse")
async def soulseek_user_browse(
    username: str,
    client: SoulseekClient = Depends(get_soulseek_client),
) -> Dict[str, Any]:
    try:
        return await client.user_browse(username)
    except SoulseekClientError as exc:
        raise _translate_error("Failed to browse user", exc) from exc


@router.get("/user/{username}/browsing_status")
async def soulseek_user_browsing_status(
    username: str,
    client: SoulseekClient = Depends(get_soulseek_client),
) -> Dict[str, Any]:
    try:
        return await client.user_browsing_status(username)
    except SoulseekClientError as exc:
        raise _translate_error("Failed to fetch user browsing status", exc) from exc


@router.get("/user/{username}/directory")
async def soulseek_user_directory(
    username: str,
    path: str = Query(..., description="Directory path to browse"),
    client: SoulseekClient = Depends(get_soulseek_client),
) -> Dict[str, Any]:
    try:
        return await client.user_directory(username, path)
    except SoulseekClientError as exc:
        raise _translate_error("Failed to fetch user directory", exc) from exc


@router.get("/user/{username}/info")
async def soulseek_user_info(
    username: str,
    client: SoulseekClient = Depends(get_soulseek_client),
) -> Dict[str, Any]:
    try:
        return await client.user_info(username)
    except SoulseekClientError as exc:
        raise _translate_error("Failed to fetch user info", exc) from exc


@router.get("/user/{username}/status")
async def soulseek_user_status(
    username: str,
    client: SoulseekClient = Depends(get_soulseek_client),
) -> Dict[str, Any]:
    try:
        return await client.user_status(username)
    except SoulseekClientError as exc:
        raise _translate_error("Failed to fetch user status", exc) from exc

===== app/routers/spotify_router.py =====
"""Spotify API endpoints."""
from __future__ import annotations

from typing import List, Optional

from fastapi import APIRouter, Depends, HTTPException, Query
from pydantic import BaseModel
from sqlalchemy.orm import Session

from app.core.spotify_client import SpotifyClient
from app.dependencies import get_db, get_spotify_client
from app.models import Playlist
from app.schemas import (
    AudioFeaturesResponse,
    PlaylistItemsResponse,
    PlaylistResponse,
    RecommendationsResponse,
    SavedTracksResponse,
    SpotifySearchResponse,
    StatusResponse,
    TrackDetailResponse,
    UserProfileResponse,
)

router = APIRouter()


class PlaylistTracksPayload(BaseModel):
    uris: List[str]


class PlaylistReorderPayload(BaseModel):
    range_start: int
    insert_before: int


class TrackIdsPayload(BaseModel):
    ids: List[str]


@router.get("/status", response_model=StatusResponse)
def spotify_status(client: SpotifyClient = Depends(get_spotify_client)) -> StatusResponse:
    status = "connected" if client.is_authenticated() else "unauthenticated"
    return StatusResponse(status=status)


@router.get("/search/tracks", response_model=SpotifySearchResponse)
def search_tracks(
    query: str = Query(..., min_length=1),
    client: SpotifyClient = Depends(get_spotify_client),
) -> SpotifySearchResponse:
    response = client.search_tracks(query)
    items = response.get("tracks", {}).get("items", [])
    return SpotifySearchResponse(items=items)


@router.get("/search/artists", response_model=SpotifySearchResponse)
def search_artists(
    query: str = Query(..., min_length=1),
    client: SpotifyClient = Depends(get_spotify_client),
) -> SpotifySearchResponse:
    response = client.search_artists(query)
    items = response.get("artists", {}).get("items", [])
    return SpotifySearchResponse(items=items)


@router.get("/search/albums", response_model=SpotifySearchResponse)
def search_albums(
    query: str = Query(..., min_length=1),
    client: SpotifyClient = Depends(get_spotify_client),
) -> SpotifySearchResponse:
    response = client.search_albums(query)
    items = response.get("albums", {}).get("items", [])
    return SpotifySearchResponse(items=items)


@router.get("/playlists", response_model=PlaylistResponse)
def list_playlists(db: Session = Depends(get_db)) -> PlaylistResponse:
    playlists = db.query(Playlist).order_by(Playlist.updated_at.desc()).all()
    return PlaylistResponse(playlists=playlists)


@router.get("/track/{track_id}", response_model=TrackDetailResponse)
def get_track_details(
    track_id: str,
    client: SpotifyClient = Depends(get_spotify_client),
) -> TrackDetailResponse:
    details = client.get_track_details(track_id)
    if not details:
        raise HTTPException(status_code=404, detail="Track not found")
    return TrackDetailResponse(track=details)


@router.get("/audio-features/{track_id}", response_model=AudioFeaturesResponse)
def get_audio_features(
    track_id: str,
    client: SpotifyClient = Depends(get_spotify_client),
) -> AudioFeaturesResponse:
    features = client.get_audio_features(track_id)
    if not features:
        raise HTTPException(status_code=404, detail="Audio features not found")
    return AudioFeaturesResponse(audio_features=features)


@router.get("/audio-features", response_model=AudioFeaturesResponse)
def get_multiple_audio_features(
    ids: str = Query(..., min_length=1),
    client: SpotifyClient = Depends(get_spotify_client),
) -> AudioFeaturesResponse:
    track_ids = [item.strip() for item in ids.split(",") if item.strip()]
    if not track_ids:
        raise HTTPException(status_code=400, detail="No track IDs provided")
    features = client.get_multiple_audio_features(track_ids)
    return AudioFeaturesResponse(audio_features=features.get("audio_features", []))


@router.get(
    "/playlists/{playlist_id}/tracks",
    response_model=PlaylistItemsResponse,
)
def get_playlist_items(
    playlist_id: str,
    limit: int = Query(100, ge=1, le=100),
    client: SpotifyClient = Depends(get_spotify_client),
) -> PlaylistItemsResponse:
    items = client.get_playlist_items(playlist_id, limit=limit)
    total = items.get("total")
    if total is None:
        total = items.get("tracks", {}).get("total")
    if total is None:
        total = len(items.get("items", []))
    return PlaylistItemsResponse(
        items=items.get("items", []),
        total=total,
    )


@router.post(
    "/playlists/{playlist_id}/tracks",
    response_model=StatusResponse,
)
def add_tracks_to_playlist(
    playlist_id: str,
    payload: PlaylistTracksPayload,
    client: SpotifyClient = Depends(get_spotify_client),
) -> StatusResponse:
    if not payload.uris:
        raise HTTPException(status_code=400, detail="No track URIs provided")
    client.add_tracks_to_playlist(playlist_id, payload.uris)
    return StatusResponse(status="tracks-added")


@router.delete(
    "/playlists/{playlist_id}/tracks",
    response_model=StatusResponse,
)
def remove_tracks_from_playlist(
    playlist_id: str,
    payload: PlaylistTracksPayload,
    client: SpotifyClient = Depends(get_spotify_client),
) -> StatusResponse:
    if not payload.uris:
        raise HTTPException(status_code=400, detail="No track URIs provided")
    client.remove_tracks_from_playlist(playlist_id, payload.uris)
    return StatusResponse(status="tracks-removed")


@router.put(
    "/playlists/{playlist_id}/reorder",
    response_model=StatusResponse,
)
def reorder_playlist(
    playlist_id: str,
    payload: PlaylistReorderPayload,
    client: SpotifyClient = Depends(get_spotify_client),
) -> StatusResponse:
    client.reorder_playlist_items(
        playlist_id,
        range_start=payload.range_start,
        insert_before=payload.insert_before,
    )
    return StatusResponse(status="playlist-reordered")


@router.get("/me/tracks", response_model=SavedTracksResponse)
def get_saved_tracks(
    limit: int = Query(20, ge=1, le=50),
    client: SpotifyClient = Depends(get_spotify_client),
) -> SavedTracksResponse:
    saved = client.get_saved_tracks(limit=limit)
    return SavedTracksResponse(items=saved.get("items", []), total=saved.get("total", len(saved.get("items", []))))


@router.put("/me/tracks", response_model=StatusResponse)
def save_tracks(
    payload: TrackIdsPayload,
    client: SpotifyClient = Depends(get_spotify_client),
) -> StatusResponse:
    if not payload.ids:
        raise HTTPException(status_code=400, detail="No track IDs provided")
    client.save_tracks(payload.ids)
    return StatusResponse(status="tracks-saved")


@router.delete("/me/tracks", response_model=StatusResponse)
def remove_saved_tracks(
    payload: TrackIdsPayload,
    client: SpotifyClient = Depends(get_spotify_client),
) -> StatusResponse:
    if not payload.ids:
        raise HTTPException(status_code=400, detail="No track IDs provided")
    client.remove_saved_tracks(payload.ids)
    return StatusResponse(status="tracks-removed")


@router.get("/me", response_model=UserProfileResponse)
def get_current_user(
    client: SpotifyClient = Depends(get_spotify_client),
) -> UserProfileResponse:
    profile = client.get_current_user()
    return UserProfileResponse(profile=profile)


@router.get("/me/top/tracks", response_model=SpotifySearchResponse)
def get_top_tracks(
    limit: int = Query(20, ge=1, le=50),
    client: SpotifyClient = Depends(get_spotify_client),
) -> SpotifySearchResponse:
    response = client.get_top_tracks(limit=limit)
    return SpotifySearchResponse(items=response.get("items", []))


@router.get("/me/top/artists", response_model=SpotifySearchResponse)
def get_top_artists(
    limit: int = Query(20, ge=1, le=50),
    client: SpotifyClient = Depends(get_spotify_client),
) -> SpotifySearchResponse:
    response = client.get_top_artists(limit=limit)
    return SpotifySearchResponse(items=response.get("items", []))


@router.get("/recommendations", response_model=RecommendationsResponse)
def get_recommendations(
    seed_tracks: Optional[str] = Query(None),
    seed_artists: Optional[str] = Query(None),
    seed_genres: Optional[str] = Query(None),
    limit: int = Query(20, ge=1, le=100),
    client: SpotifyClient = Depends(get_spotify_client),
) -> RecommendationsResponse:
    def _split(value: Optional[str]) -> Optional[List[str]]:
        if value is None:
            return None
        result = [item.strip() for item in value.split(",") if item.strip()]
        return result or None

    response = client.get_recommendations(
        seed_tracks=_split(seed_tracks),
        seed_artists=_split(seed_artists),
        seed_genres=_split(seed_genres),
        limit=limit,
    )
    return RecommendationsResponse(
        tracks=response.get("tracks", []),
        seeds=response.get("seeds", []),
    )

===== app/schemas.py =====
"""Pydantic schemas for request and response bodies."""
from __future__ import annotations

from datetime import datetime
from typing import Any, Dict, List, Optional, Union

from pydantic import BaseModel, Field, ConfigDict


class StatusResponse(BaseModel):
    status: str
    artist_count: Optional[int] = None
    album_count: Optional[int] = None
    track_count: Optional[int] = None
    last_scan: Optional[datetime] = None


class SpotifySearchResponse(BaseModel):
    items: List[Dict[str, Any]]


class PlaylistEntry(BaseModel):
    id: str
    name: str
    track_count: int
    updated_at: datetime

    model_config = ConfigDict(from_attributes=True)


class PlaylistResponse(BaseModel):
    playlists: List[PlaylistEntry]


class TrackDetailResponse(BaseModel):
    track: Dict[str, Any]


class AudioFeaturesResponse(BaseModel):
    audio_features: Union[Dict[str, Any], List[Dict[str, Any]]]


class PlaylistItemsResponse(BaseModel):
    items: List[Dict[str, Any]]
    total: int


class SavedTracksResponse(BaseModel):
    items: List[Dict[str, Any]]
    total: int


class UserProfileResponse(BaseModel):
    profile: Dict[str, Any]


class RecommendationsResponse(BaseModel):
    tracks: List[Dict[str, Any]]
    seeds: List[Dict[str, Any]]


class SoulseekSearchRequest(BaseModel):
    query: str


class SoulseekDownloadRequest(BaseModel):
    username: str = Field(..., description="Soulseek username hosting the files")
    files: List[Dict[str, Any]] = Field(..., description="List of files to download")


class SoulseekSearchResponse(BaseModel):
    """Response payload for Soulseek search results."""

    results: List[Any]
    raw: Optional[Dict[str, Any]] = None


class SoulseekDownloadResponse(BaseModel):
    """Response payload when a Soulseek download is queued."""

    status: str
    detail: Optional[Dict[str, Any]] = None


class SoulseekDownloadEntry(BaseModel):
    id: int
    filename: str
    state: str
    progress: float
    created_at: datetime
    updated_at: datetime

    model_config = ConfigDict(from_attributes=True)


class SoulseekDownloadStatus(BaseModel):
    downloads: List[SoulseekDownloadEntry]


class SoulseekCancelResponse(BaseModel):
    cancelled: bool


class MatchingRequest(BaseModel):
    spotify_track: Dict[str, Any]
    candidates: List[Dict[str, Any]]


class MatchingResponse(BaseModel):
    best_match: Optional[Dict[str, Any]]
    confidence: float


class AlbumMatchingRequest(BaseModel):
    spotify_album: Dict[str, Any]
    candidates: List[Dict[str, Any]]


class SettingsPayload(BaseModel):
    key: str
    value: Optional[str]


class SettingsResponse(BaseModel):
    settings: Dict[str, Optional[str]]
    updated_at: datetime


class SettingsHistoryEntry(BaseModel):
    key: str
    old_value: Optional[str]
    new_value: Optional[str]
    changed_at: datetime

    model_config = ConfigDict(from_attributes=True)


class SettingsHistoryResponse(BaseModel):
    history: List[SettingsHistoryEntry]

===== app/utils/__init__.py =====
"""Utility helpers for Harmony."""

from .logging_config import configure_logging, get_logger  # noqa: F401

__all__ = ["configure_logging", "get_logger"]

===== app/utils/logging_config.py =====
"""Compatibility wrapper exposing logging helpers for legacy imports."""

from __future__ import annotations

from app.logging import configure_logging, get_logger

__all__ = ["configure_logging", "get_logger"]

===== app/workers/__init__.py =====
"""Background worker exports."""
from .matching_worker import MatchingWorker
from .playlist_sync_worker import PlaylistSyncWorker
from .scan_worker import ScanWorker
from .sync_worker import SyncWorker

__all__ = ["MatchingWorker", "PlaylistSyncWorker", "ScanWorker", "SyncWorker"]

===== app/workers/matching_worker.py =====
"""Background worker handling deferred matching operations."""
from __future__ import annotations

import asyncio
from typing import Any, Dict

from app.core.matching_engine import MusicMatchingEngine
from app.db import session_scope
from app.logging import get_logger
from app.models import Match

logger = get_logger(__name__)


class MatchingWorker:
    def __init__(self, engine: MusicMatchingEngine) -> None:
        self._engine = engine
        self._queue: asyncio.Queue[Dict[str, Any]] = asyncio.Queue()
        self._task: asyncio.Task | None = None
        self._running = asyncio.Event()

    async def start(self) -> None:
        if self._task is None or self._task.done():
            self._running.set()
            self._task = asyncio.create_task(self._run())

    async def stop(self) -> None:
        self._running.clear()
        if self._task:
            await self._queue.put({"_shutdown": True})
            await self._task

    @property
    def queue(self) -> asyncio.Queue[Dict[str, Any]]:
        return self._queue

    async def _run(self) -> None:
        logger.info("MatchingWorker started")
        while self._running.is_set():
            job = await self._queue.get()
            try:
                if job.get("_shutdown"):
                    break
                await self._process_job(job)
            except Exception as exc:  # pragma: no cover
                logger.error("Failed to process matching job: %s", exc)
            finally:
                self._queue.task_done()
        logger.info("MatchingWorker stopped")

    async def _process_job(self, job: Dict[str, Any]) -> None:
        job_type = job.get("type")
        spotify_track = job.get("spotify_track")
        candidates = job.get("candidates", [])
        if not spotify_track or not candidates:
            logger.warning("Invalid matching job received: %s", job)
            return
        if job_type == "spotify-to-plex":
            best_match, confidence = self._engine.find_best_match(spotify_track, candidates)
        else:
            best_match = None
            confidence = 0.0
            for candidate in candidates:
                score = self._engine.calculate_slskd_match_confidence(spotify_track, candidate)
                if score > confidence:
                    confidence = score
                    best_match = candidate
        self._store_match(job_type, spotify_track, best_match, confidence)

    def _store_match(
        self,
        job_type: str,
        spotify_track: Dict[str, Any],
        best_match: Dict[str, Any] | None,
        confidence: float,
    ) -> None:
        with session_scope() as session:
            match = Match(
                source=job_type,
                spotify_track_id=str(spotify_track.get("id")),
                target_id=str(best_match.get("id")) if best_match and best_match.get("id") else None,
                confidence=confidence,
            )
            session.add(match)

===== app/workers/playlist_sync_worker.py =====
"""Background worker that synchronises Spotify playlists into the database."""
from __future__ import annotations

import asyncio
from datetime import datetime
from typing import Any, Iterable

from app.core.spotify_client import SpotifyClient
from app.db import session_scope
from app.logging import get_logger
from app.models import Playlist

logger = get_logger(__name__)


class PlaylistSyncWorker:
    """Periodically fetches playlists for the authenticated user."""

    def __init__(self, spotify_client: SpotifyClient, interval_seconds: float = 900.0) -> None:
        self._client = spotify_client
        self._interval = interval_seconds
        self._task: asyncio.Task[None] | None = None
        self._running = False

    async def start(self) -> None:
        if self._task is None or self._task.done():
            self._running = True
            self._task = asyncio.create_task(self._run())

    async def stop(self) -> None:
        self._running = False
        if self._task is not None:
            self._task.cancel()
            try:
                await self._task
            except asyncio.CancelledError:  # pragma: no cover - cancellation lifecycle
                pass
            self._task = None

    async def _run(self) -> None:
        logger.info("PlaylistSyncWorker started")
        try:
            while self._running:
                await self.sync_once()
                await asyncio.sleep(self._interval)
        except asyncio.CancelledError:  # pragma: no cover - cancellation lifecycle
            logger.debug("PlaylistSyncWorker cancelled")
            raise
        finally:
            self._running = False
            logger.info("PlaylistSyncWorker stopped")

    async def sync_once(self) -> None:
        """Fetch playlists from Spotify and persist them."""

        try:
            response = self._client.get_user_playlists()
        except Exception as exc:  # pragma: no cover - defensive logging
            logger.error("Failed to fetch playlists from Spotify: %s", exc)
            return

        items: list[dict[str, Any]] = []
        if isinstance(response, dict):
            raw_items = response.get("items")
            if isinstance(raw_items, Iterable):
                items = [item for item in raw_items if isinstance(item, dict)]
        elif isinstance(response, list):
            items = [item for item in response if isinstance(item, dict)]

        if not items:
            logger.debug("No playlists received from Spotify")
            return

        now = datetime.utcnow()
        processed = 0

        with session_scope() as session:
            for payload in items:
                playlist_id = payload.get("id")
                name = payload.get("name")
                if not playlist_id or not name:
                    continue

                track_count = self._extract_track_count(payload)
                playlist = session.get(Playlist, str(playlist_id))

                if playlist is None:
                    playlist = Playlist(
                        id=str(playlist_id),
                        name=str(name),
                        track_count=track_count,
                    )
                    playlist.updated_at = now
                    session.add(playlist)
                else:
                    playlist.name = str(name)
                    playlist.track_count = track_count
                    playlist.updated_at = now

                processed += 1

        logger.info("Synced %s playlists from Spotify", processed)

    @staticmethod
    def _extract_track_count(payload: dict[str, Any]) -> int:
        """Safely derive the track count from a playlist payload."""

        track_count: int = 0
        tracks = payload.get("tracks")
        if isinstance(tracks, dict):
            total = tracks.get("total")
            try:
                track_count = int(total)
            except (TypeError, ValueError):
                track_count = 0
        elif isinstance(tracks, Iterable) and not isinstance(tracks, (str, bytes)):
            track_count = sum(1 for _ in tracks)
        else:
            try:
                track_count = int(payload.get("track_count", 0))
            except (TypeError, ValueError):
                track_count = 0

        return max(track_count, 0)

===== app/workers/scan_worker.py =====
"""Worker that periodically scans the Plex library."""
from __future__ import annotations

import asyncio
from datetime import datetime

from sqlalchemy import select

from app.core.plex_client import PlexClient
from app.db import session_scope
from app.logging import get_logger
from app.models import Setting

logger = get_logger(__name__)


class ScanWorker:
    def __init__(self, plex_client: PlexClient, interval_seconds: int = 600) -> None:
        self._client = plex_client
        self._interval = interval_seconds
        self._task: asyncio.Task | None = None
        self._running = asyncio.Event()

    async def start(self) -> None:
        if self._task is None or self._task.done():
            self._running.set()
            self._task = asyncio.create_task(self._run())

    async def stop(self) -> None:
        self._running.clear()
        if self._task:
            self._task.cancel()
            try:
                await self._task
            except asyncio.CancelledError:  # pragma: no cover
                pass

    async def _run(self) -> None:
        logger.info("ScanWorker started")
        while self._running.is_set():
            await self._perform_scan()
            await asyncio.sleep(self._interval)
        logger.info("ScanWorker stopped")

    async def _perform_scan(self) -> None:
        try:
            stats = await self._client.get_library_statistics()
        except Exception as exc:  # pragma: no cover
            logger.error("Failed to scan Plex library: %s", exc)
            return

        artist_count = stats.get("artists", 0)
        album_count = stats.get("albums", 0)
        track_count = stats.get("tracks", 0)

        now = datetime.utcnow()
        with session_scope() as session:
            self._upsert_setting(session, "plex_artist_count", str(artist_count), now)
            self._upsert_setting(session, "plex_album_count", str(album_count), now)
            self._upsert_setting(session, "plex_track_count", str(track_count), now)
            self._upsert_setting(
                session, "plex_last_scan", now.isoformat(timespec="seconds"), now
            )
        logger.info(
            "Plex scan complete: %d artists, %d albums, %d tracks",
            artist_count,
            album_count,
            track_count,
        )

    @staticmethod
    def _upsert_setting(session, key: str, value: str, timestamp: datetime) -> None:
        setting = session.execute(
            select(Setting).where(Setting.key == key)
        ).scalar_one_or_none()
        if setting is None:
            session.add(
                Setting(
                    key=key,
                    value=value,
                    created_at=timestamp,
                    updated_at=timestamp,
                )
            )
        else:
            setting.value = value
            setting.updated_at = timestamp

===== app/workers/sync_worker.py =====
"""Background worker for processing Soulseek download jobs."""
from __future__ import annotations

import asyncio
from datetime import datetime
from typing import Any, Dict, Iterable

from app.core.soulseek_client import SoulseekClient
from app.db import session_scope
from app.logging import get_logger
from app.models import Download

logger = get_logger(__name__)

ALLOWED_STATES = {"queued", "downloading", "completed", "failed"}


class SyncWorker:
    def __init__(self, soulseek_client: SoulseekClient) -> None:
        self._client = soulseek_client
        self._queue: asyncio.Queue[Dict[str, Any]] = asyncio.Queue()
        self._task: asyncio.Task | None = None
        self._running = asyncio.Event()
        self._poll_interval = 2.0

    @property
    def queue(self) -> asyncio.Queue[Dict[str, Any]]:
        return self._queue

    def is_running(self) -> bool:
        return self._running.is_set() and self._task is not None and not self._task.done()

    async def start(self) -> None:
        if self._task is None or self._task.done():
            self._running.set()
            self._task = asyncio.create_task(self._run())

    async def stop(self) -> None:
        self._running.clear()
        if self._task:
            await self._queue.put({"_shutdown": True})
            await self._task

    async def enqueue(self, job: Dict[str, Any]) -> None:
        """Submit a download job for processing."""

        if self.is_running():
            await self._queue.put(job)
            return
        await self._process_job(job)
        await self.refresh_downloads()

    async def _run(self) -> None:
        logger.info("SyncWorker started")
        try:
            while self._running.is_set():
                job: Dict[str, Any] | None = None
                try:
                    job = await asyncio.wait_for(self._queue.get(), timeout=self._poll_interval)
                except asyncio.TimeoutError:
                    await self.refresh_downloads()
                    continue

                try:
                    if job.get("_shutdown"):
                        break
                    await self._process_job(job)
                    await self.refresh_downloads()
                except Exception as exc:  # pragma: no cover - defensive
                    logger.error("Failed to process sync job: %s", exc)
                finally:
                    self._queue.task_done()
        finally:
            self._running.clear()
            logger.info("SyncWorker stopped")

    async def _process_job(self, job: Dict[str, Any]) -> None:
        username = job.get("username")
        files = job.get("files", [])
        if not username or not files:
            logger.warning("Invalid download job received: %s", job)
            return

        try:
            await self._client.download({"username": username, "files": files})
        except Exception as exc:  # pragma: no cover - defensive
            logger.error("Failed to queue Soulseek download: %s", exc)
            self._mark_failed(files)
            raise

    async def refresh_downloads(self) -> None:
        """Poll Soulseek for download progress and persist it."""

        try:
            response = await self._client.get_download_status()
        except Exception as exc:  # pragma: no cover - defensive
            logger.warning("Unable to obtain Soulseek download status: %s", exc)
            return

        downloads: Iterable[Dict[str, Any]]
        if isinstance(response, dict):
            downloads = response.get("downloads", []) or []
        elif isinstance(response, list):
            downloads = response
        else:  # pragma: no cover - defensive
            downloads = []

        if not downloads:
            return

        with session_scope() as session:
            for payload in downloads:
                download_id = payload.get("download_id") or payload.get("id")
                if download_id is None:
                    continue

                download = session.get(Download, int(download_id))
                if download is None:
                    continue

                state = str(payload.get("state", download.state))
                if state not in ALLOWED_STATES:
                    state = download.state

                progress_value = payload.get("progress", download.progress)
                try:
                    progress = float(progress_value)
                except (TypeError, ValueError):
                    progress = download.progress

                if progress < 0:
                    progress = 0.0
                elif progress > 100:
                    progress = 100.0

                if state == "queued" and 0 < progress < 100:
                    state = "downloading"
                elif state == "completed":
                    progress = 100.0

                download.state = state
                download.progress = progress
                download.updated_at = datetime.utcnow()

    def _mark_failed(self, files: Iterable[Dict[str, Any]]) -> None:
        download_ids = []
        for file_info in files:
            identifier = file_info.get("download_id") or file_info.get("id")
            if identifier is not None:
                download_ids.append(int(identifier))

        if not download_ids:
            return

        with session_scope() as session:
            for download_id in download_ids:
                download = session.get(Download, download_id)
                if download is None:
                    continue
                download.state = "failed"
                download.updated_at = datetime.utcnow()

===== docker-compose.override.yml =====
version: "3.9"

services:
  backend:
    command: ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000", "--reload"]
    environment:
      - DATABASE_URL=sqlite:///./harmony.db
      - HARMONY_LOG_LEVEL=DEBUG

===== docker-compose.yml =====
version: "3.9"

services:
  backend:
    build: .
    container_name: harmony-backend
    environment:
      - DATABASE_URL=sqlite:///./harmony.db
      - HARMONY_LOG_LEVEL=INFO
    ports:
      - "8000:8000"
    volumes:
      - ./:/app

===== docs/api.md =====
# API-Referenz

Die folgenden Tabellen geben einen Überblick über die wichtigsten REST-Endpunkte des Harmony-Backends. Beispiel-Requests orientieren
sich an den in `app/routers` definierten Routen. Alle Antworten sind JSON-codiert.

## Spotify (`/spotify`)

| Methode | Pfad | Beschreibung |
| --- | --- | --- |
| `GET` | `/spotify/status` | Prüft, ob der Spotify-Client authentifiziert ist. |
| `GET` | `/spotify/search/tracks?query=...` | Sucht nach Tracks (weitere Endpunkte für Artists/Albums identisch). |
| `GET` | `/spotify/track/{track_id}` | Liefert Track-Details. |
| `GET` | `/spotify/audio-features/{track_id}` | Einzelne Audio-Features. |
| `GET` | `/spotify/audio-features?ids=ID1,ID2` | Mehrere Audio-Features in einem Request. |
| `GET` | `/spotify/playlists` | Listet persistierte Playlists aus der Datenbank. |
| `GET` | `/spotify/playlists/{playlist_id}/tracks` | Holt Playlist-Items (optional `limit`). |
| `POST` | `/spotify/playlists/{playlist_id}/tracks` | Fügt Tracks per URIs hinzu. |
| `DELETE` | `/spotify/playlists/{playlist_id}/tracks` | Entfernt Tracks anhand von URIs. |
| `PUT` | `/spotify/playlists/{playlist_id}/reorder` | Sortiert Playlist neu. |
| `GET` | `/spotify/me` | Gibt das Spotify-Benutzerprofil zurück. |
| `GET` | `/spotify/me/tracks` | Listet gespeicherte Tracks (`limit`). |
| `PUT`/`DELETE` | `/spotify/me/tracks` | Speichert bzw. entfernt gespeicherte Tracks (Payload: `{"ids": [...]}`). |
| `GET` | `/spotify/me/top/{type}` | Top-Tracks oder Artists. |
| `GET` | `/spotify/recommendations` | Empfehlungen anhand Seed-Parametern. |

**Beispiel:**

```http
GET /spotify/search/tracks?query=daft%20punk HTTP/1.1
Authorization: Bearer <token>
```

```json
{
  "items": [
    {
      "id": "2cGxRwrMyEAp8dEbuZaVv6",
      "name": "Harder, Better, Faster, Stronger",
      "artists": [{"name": "Daft Punk"}],
      "album": {"name": "Discovery"}
    }
  ]
}
```

## Plex (`/plex`)

| Methode | Pfad | Beschreibung |
| --- | --- | --- |
| `GET` | `/plex/status` | Liefert Sitzungen und Bibliotheksstatistiken. |
| `GET` | `/plex/library/sections` | Listet Bibliotheken (Alias: `/plex/libraries`). |
| `GET` | `/plex/library/sections/{section_id}/all` | Durchsucht eine Bibliothek (Alias: `/plex/library/{section_id}/items`). |
| `GET` | `/plex/library/metadata/{item_id}` | Metadaten für ein Item. |
| `GET` | `/plex/status/sessions` | Aktive Sessions (Alias: `/plex/sessions`). |
| `GET` | `/plex/status/sessions/history/all` | Wiedergabeverlauf (Alias: `/plex/history`). |
| `GET`/`POST` | `/plex/timeline` | Holt bzw. aktualisiert Timeline-Daten. |
| `POST` | `/plex/scrobble` / `/plex/unscrobble` | Spielposition melden. |
| `GET`/`POST`/`PUT`/`DELETE` | `/plex/playlists` | Playlist-Verwaltung. |
| `POST` | `/plex/playQueues` | Erstellt PlayQueues. |
| `GET` | `/plex/playQueues/{playqueue_id}` | Lädt eine bestehende PlayQueue. |
| `POST` | `/plex/rate` | Bewertet ein Item. |
| `POST` | `/plex/tags/{item_id}` | Synchronisiert Tags. |
| `GET` | `/plex/devices` | Verfügbare Geräte. |
| `GET` | `/plex/dvr` | DVR-Daten. |
| `GET` | `/plex/livetv` | Live-TV-Informationen. |
| `GET` | `/plex/notifications` | Server-Sent Events Stream für Plex-Benachrichtigungen. |

**Beispiel:**

```http
GET /plex/library/sections/1/all?type=10 HTTP/1.1
X-Plex-Token: <token>
```

```json
{
  "MediaContainer": {
    "Metadata": [
      {"ratingKey": "123", "title": "Discovery", "parentTitle": "Daft Punk"}
    ]
  }
}
```

## Soulseek (`/soulseek`)

| Methode | Pfad | Beschreibung |
| --- | --- | --- |
| `GET` | `/soulseek/status` | Prüft die Verbindung zum slskd-Daemon. |
| `POST` | `/soulseek/search` | Führt eine Suche aus (`{"query": "artist"}`). |
| `POST` | `/soulseek/download` | Persistiert Downloads und stößt Worker an. |
| `GET` | `/soulseek/downloads` | Liefert gespeicherte Downloads aus der DB. |
| `GET` | `/soulseek/download/{id}` | Holt Detailinformationen direkt vom Client. |
| `DELETE` | `/soulseek/download/{id}` | Bricht einen Download ab. |
| `GET` | `/soulseek/downloads/all` | Delegiert an `SoulseekClient.get_all_downloads()`. |
| `DELETE` | `/soulseek/downloads/completed` | Entfernt erledigte Downloads. |
| `GET` | `/soulseek/download/{id}/queue` | Fragt Queue-Positionen ab. |
| `POST` | `/soulseek/enqueue` | Fügt mehrere Dateien der Warteschlange hinzu. |
| `GET` | `/soulseek/uploads` | Lädt Uploads. |
| `GET` | `/soulseek/uploads/all` | Alle Uploads. |
| `DELETE` | `/soulseek/upload/{id}` | Bricht einen Upload ab. |
| `DELETE` | `/soulseek/uploads/completed` | Entfernt erledigte Uploads. |
| `GET` | `/soulseek/user/{username}/address` | IP/Port eines Benutzers. |
| `GET` | `/soulseek/user/{username}/browse` | Lädt die Verzeichnisstruktur. |
| `GET` | `/soulseek/user/{username}/directory?path=...` | Abfrage eines Unterordners. |
| `GET` | `/soulseek/user/{username}/info` | Benutzerinformationen. |
| `GET` | `/soulseek/user/{username}/status` | Online-Status. |

**Beispiel:**

```http
POST /soulseek/download HTTP/1.1
Content-Type: application/json

{
  "username": "dj_user",
  "files": [
    {"filename": "Daft Punk - Harder.mp3", "size": 5120000}
  ]
}
```

```json
{
  "status": "queued",
  "detail": {
    "downloads": [
      {"id": 1, "filename": "Daft Punk - Harder.mp3", "state": "queued", "progress": 0.0}
    ]
  }
}
```

## Matching (`/matching`)

| Methode | Pfad | Beschreibung |
| --- | --- | --- |
| `POST` | `/matching/spotify-to-plex` | Matcht einen Spotify-Track gegen Plex-Kandidaten und speichert das Ergebnis. |
| `POST` | `/matching/spotify-to-soulseek` | Bewertet Spotify vs. Soulseek-Kandidaten. |
| `POST` | `/matching/spotify-to-plex-album` | Liefert das beste Album-Match. |

**Beispiel:**

```http
POST /matching/spotify-to-plex HTTP/1.1
Content-Type: application/json

{
  "spotify_track": {"id": "2cGxRwrMyEAp8dEbuZaVv6", "name": "Harder, Better, Faster, Stronger"},
  "candidates": [
    {"id": "123", "title": "Harder Better Faster Stronger", "album": "Discovery"}
  ]
}
```

```json
{
  "best_match": {"id": "123", "title": "Harder Better Faster Stronger", "album": "Discovery"},
  "confidence": 0.98
}
```

## Settings (`/settings`)

| Methode | Pfad | Beschreibung |
| --- | --- | --- |
| `GET` | `/settings` | Liefert alle Settings als Key-Value-Map inklusive `updated_at`. |
| `POST` | `/settings` | Legt/aktualisiert einen Eintrag (`{"key": "plex_artist_count", "value": "123"}`). |
| `GET` | `/settings/history` | Zeigt die letzten 50 Änderungen mit Zeitstempel. |

## Beets (`/beets`)

| Methode | Pfad | Beschreibung |
| --- | --- | --- |
| `POST` | `/beets/import` | Führt `beet import` aus (Payload: `{"path": "/music"}`). |
| `POST` | `/beets/update` | Aktualisiert Metadaten (`beet update`). |
| `POST` | `/beets/remove` | Entfernt Items nach Query (`{"query": "artist:Daft Punk"}`). |
| `POST` | `/beets/move` | Verschiebt Dateien (optional Query). |
| `POST` | `/beets/write` | Schreibt Tags auf Basis einer Query. |
| `GET` | `/beets/albums` | Listet Albumtitel. |
| `GET` | `/beets/tracks` | Listet Tracks. |
| `GET` | `/beets/stats` | Gibt Statistiken (`beet stats`). |
| `GET` | `/beets/fields` | Zeigt verfügbare Feldnamen. |
| `POST` | `/beets/query` | Führt eine Query mit Format-String aus. |

**Beispiel:**

```http
POST /beets/query HTTP/1.1
Content-Type: application/json

{
  "query": "artist:Daft Punk",
  "format": "$artist - $album - $title"
}
```

```json
{
  "results": [
    "Daft Punk - Discovery - Harder, Better, Faster, Stronger"
  ]
}
```

===== docs/architecture.md =====
# Architekturübersicht

Die Harmony-Anwendung folgt einer modularen FastAPI-Architektur, die interne und externe Komponenten klar voneinander trennt.
Das folgende textuelle Diagramm beschreibt den Aufbau:

```
+----------------------------+
|          Clients           |
| SpotifyClient, PlexClient, |
| SoulseekClient, BeetsClient|
+-------------+--------------+
              |
              v
+-------------+--------------+
|            Core            |
| MatchingEngine, Utilities  |
+-------------+--------------+
              |
              v
+-------------+--------------+
|           Routers          |
| Spotify / Plex / Soulseek  |
| Matching / Settings / Beets|
+------+------+-------------+
       |      |
       |      v
       |   Background Workers
       |   (Sync, Matching,   
       |    Scan, Playlist)   
       v                      
+------+------+-------------+
|        Datenbank           |
| SQLAlchemy Modelle         |
+----------------------------+
```

## Komponenten im Detail

### Core

- **SpotifyClient** (`app/core/spotify_client.py`): Kapselt die Spotify Web API (Suche, Audio Features, Playlists, Empfehlungen).
- **PlexClient** (`app/core/plex_client.py`): Async-Client für Bibliotheken, Sessions, Timeline und Live-TV.
- **SoulseekClient** (`app/core/soulseek_client.py`): Bindet den slskd-Daemon an und stellt Download-/Upload-Operationen bereit.
- **BeetsClient** (`app/core/beets_client.py`): Führt Beets CLI-Kommandos innerhalb eines Threadpools aus.
- **MusicMatchingEngine** (`app/core/matching_engine.py`): Berechnet Ähnlichkeitsscores und liefert Best-Match-Kandidaten.

### Routers

FastAPI-Router bilden die öffentliche REST-API. Jeder Router importiert die benötigten Clients als Dependencies (`app/dependencies.py`).
Beispiele:

- `app/routers/spotify_router.py` für `/spotify`-Endpunkte (Suche, Audio Features, Playlists, Benutzerprofil).
- `app/routers/plex_router.py` für `/plex`-Endpunkte (Bibliotheken, PlayQueues, Benachrichtigungen).
- `app/routers/soulseek_router.py` für `/soulseek`-Endpunkte (Downloads, Uploads, Benutzerinformationen).
- `app/routers/matching_router.py` für `/matching` (Spotify→Plex/Soulseek, Album-Matching).
- `app/routers/settings_router.py` für `/settings` (Key-Value Settings + Historie).
- `app/routers/beets_router.py` für `/beets` (Import, Query, Stats, Dateimanipulation).

### Datenbank

- `app/db.py` initialisiert SQLite und stellt `session_scope()` sowie `get_session()` bereit.
- `app/models.py` definiert SQLAlchemy-Modelle wie `Playlist`, `Download`, `Match`, `Setting`, `SettingHistory`.
- `app/schemas.py` enthält die Pydantic-Modelle für Anfragen und Antworten.

### Hintergrund-Worker

Während des Startup-Events (`app/main.py`) werden – sofern `HARMONY_DISABLE_WORKERS` nicht gesetzt ist – folgende Worker gestartet:

- **SyncWorker** (`app/workers/sync_worker.py`): Verarbeitet Soulseek-Downloadjobs und aktualisiert Fortschritte.
- **MatchingWorker** (`app/workers/matching_worker.py`): Persistiert berechnete Matches asynchron.
- **ScanWorker** (`app/workers/scan_worker.py`): Pollt Plex in Intervallen und aktualisiert Statistik-Settings.
- **PlaylistSyncWorker** (`app/workers/playlist_sync_worker.py`): Synchronisiert Spotify-Playlists in die Datenbank.

Alle Worker greifen über `session_scope()` auf die Datenbank zu und protokollieren Abläufe über `app/logging.py`.

## Synchronisations- & Matching-Prozesse

1. **Soulseek-Downloads**: REST-Aufrufe gegen `/soulseek/download` persistieren Downloads in der Datenbank und übergeben Jobs an den
   `SyncWorker`. Dieser startet Downloads über den `SoulseekClient` und pollt `get_download_status()`, um Fortschritt, Status und
   Zeitstempel (`Download.updated_at`) zu aktualisieren.
2. **Spotify-Playlist-Sync**: Der `PlaylistSyncWorker` ruft periodisch `SpotifyClient.get_user_playlists()` auf, normalisiert die
   Daten und speichert sie in der `Playlist`-Tabelle. Änderungen werden über `updated_at` erfasst.
3. **Plex-Scans**: Der `ScanWorker` pollt `PlexClient.get_library_statistics()` und schreibt aggregierte Werte in `Setting`-Einträge.
4. **Matching**: Der Matching-Router kann Ergebnisse direkt persistieren. Zusätzlich verarbeitet der `MatchingWorker` Jobs aus seiner
   Queue und speichert `Match`-Objekte. Die Matching-Engine vergleicht Spotify-Tracks mit Plex- oder Soulseek-Kandidaten und liefert
   Konfidenzwerte zurück.

## Interaktion der Komponenten

- Router lösen Aktionen aus und rufen über Dependencies die passenden Core-Clients auf.
- Core-Clients kommunizieren mit externen Diensten und liefern strukturierte Antworten.
- Worker laufen asynchron und nutzen dieselben Clients, um Automatisierungen im Hintergrund auszuführen.
- Alle Schreiboperationen gehen über SQLAlchemy-Sessions, sodass API-Aufrufe und Worker auf denselben Datenbestand zugreifen.

===== docs/workers.md =====
# Hintergrund-Worker

Harmony startet beim FastAPI-Startup mehrere Hintergrundprozesse, um langlaufende Aufgaben außerhalb des Request-Kontexts zu
bearbeiten. Die Worker verwenden asynchrone Tasks (`asyncio`) und greifen über `session_scope()` auf die Datenbank zu.

## SyncWorker

- **Pfad:** `app/workers/sync_worker.py`
- **Aufgabe:** Verarbeitet Soulseek-Downloadjobs, startet Downloads über den `SoulseekClient` und aktualisiert den Fortschritt.
- **Arbeitsweise:**
  - Eingehende Jobs (Username + Datei-Metadaten) landen in einer `asyncio.Queue`.
  - Läuft der Worker, werden Jobs sequentiell aus der Queue geholt; andernfalls wird der Download sofort synchron abgewickelt.
  - Nach jedem Job wird `refresh_downloads()` aufgerufen, das `client.get_download_status()` pollt und DB-Einträge (`Download`)
    aktualisiert (Status, Fortschritt, `updated_at`).
- **Polling-Intervall:** 2 Sekunden Timeout beim Queue-Waiting; fällt kein Job an, wird in diesem Intervall der Status nachgezogen.
- **Fehlerhandling:**
  - Fehler beim Download markieren die betroffenen Einträge als `failed`.
  - Nicht erkannte Statuswerte werden verworfen, Fortschrittswerte werden auf `0…100` begrenzt.
  - Netzwerkfehler beim Status-Polling führen zu einem Warn-Log, ohne den Worker zu stoppen.

## MatchingWorker

- **Pfad:** `app/workers/matching_worker.py`
- **Aufgabe:** Nimmt Matching-Jobs (`spotify_track` + Kandidatenliste) entgegen und persistiert die besten Treffer.
- **Arbeitsweise:**
  - Verwendet eine `asyncio.Queue` und ein Flag, um Shutdowns kontrolliert zu verarbeiten.
  - Für `spotify-to-plex` ruft der Worker `MusicMatchingEngine.find_best_match()` auf.
  - Für alle anderen Jobs (z. B. `spotify-to-soulseek`) wird `calculate_slskd_match_confidence()` pro Kandidat berechnet und das
    höchste Scoring übernommen.
  - Die Ergebnisse werden als `Match`-Objekte gespeichert (`source`, `spotify_track_id`, `target_id`, `confidence`).
- **Fehlerhandling:**
  - Exceptions beim Abarbeiten werden geloggt; das Queue-Item wird dennoch als abgeschlossen markiert.
  - Ungültige Jobs (fehlende Kandidaten/Tracks) werden verworfen und mit Warnung protokolliert.

## ScanWorker

- **Pfad:** `app/workers/scan_worker.py`
- **Aufgabe:** Pollt regelmäßig Plex-Statistiken und hält aggregierte Werte in den Settings aktuell.
- **Arbeitsweise:**
  - Standardintervall: 600 Sekunden (`interval_seconds`-Parameter).
  - `get_library_statistics()` liefert Anzahl Artists/Albums/Tracks; zusätzlich wird ein Zeitstempel gesetzt.
  - Werte werden über `_upsert_setting` als `Setting`-Einträge geschrieben oder aktualisiert (`plex_artist_count`, `plex_album_count`,
    `plex_track_count`, `plex_last_scan`).
- **Fehlerhandling:**
  - Netzwerkfehler werden geloggt und führen zu keinem Update.
  - Der Worker toleriert `asyncio.CancelledError`, wenn er beim Shutdown gestoppt wird.

## Zusammenspiel der Worker

- Alle Worker werden in `app/main.py` initialisiert, sofern `HARMONY_DISABLE_WORKERS` nicht auf `1` gesetzt ist.
- Die Worker teilen sich keine gemeinsamen Datenstrukturen; Synchronisation erfolgt ausschließlich über die Datenbank.
- Beim Application-Shutdown stoppt FastAPI jeden Worker kontrolliert (`stop()`), um laufende Tasks zu beenden und Queues zu räumen.

===== requirements.txt =====
fastapi
uvicorn
sqlalchemy
aiohttp
spotipy
plexapi
pydantic
pytest
pytest-asyncio
httpx

===== tests/conftest.py =====
from __future__ import annotations

import os
from contextlib import asynccontextmanager
from pathlib import Path
from typing import Any, Dict

import sys

ROOT = Path(__file__).resolve().parents[1]
if str(ROOT) not in sys.path:
    sys.path.insert(0, str(ROOT))

import pytest
from app.db import init_db, reset_engine_for_tests
from app.dependencies import (
    get_matching_engine as dependency_matching_engine,
    get_plex_client as dependency_plex_client,
    get_soulseek_client as dependency_soulseek_client,
    get_spotify_client as dependency_spotify_client,
)
from app.main import app
from app.workers import MatchingWorker, PlaylistSyncWorker, ScanWorker, SyncWorker
from tests.simple_client import SimpleTestClient


class StubSpotifyClient:
    def __init__(self) -> None:
        self.tracks: Dict[str, Dict[str, Any]] = {
            "track-1": {"id": "track-1", "name": "Test Song", "artists": [{"name": "Tester"}], "duration_ms": 200000},
        }
        self.playlists = [
            {"id": "playlist-1", "name": "My Playlist", "tracks": {"total": 1}},
        ]
        self.audio_features: Dict[str, Dict[str, Any]] = {
            "track-1": {"id": "track-1", "danceability": 0.5},
        }
        self.playlist_items: Dict[str, Dict[str, Any]] = {
            "playlist-1": {"items": [{"track": self.tracks["track-1"]}], "total": 1}
        }
        self.saved_track_ids: set[str] = set()
        self.recommendation_payload: Dict[str, Any] = {"tracks": [], "seeds": []}

    def is_authenticated(self) -> bool:
        return True

    def search_tracks(self, query: str, limit: int = 20) -> Dict[str, Any]:
        return {"tracks": {"items": list(self.tracks.values())}}

    def search_artists(self, query: str, limit: int = 20) -> Dict[str, Any]:
        return {"artists": {"items": [{"id": "artist-1", "name": "Tester"}]}}

    def search_albums(self, query: str, limit: int = 20) -> Dict[str, Any]:
        return {"albums": {"items": [{"id": "album-1", "name": "Album", "artists": [{"name": "Tester"}]}]}}

    def get_user_playlists(self, limit: int = 50) -> Dict[str, Any]:
        return {"items": [dict(item) for item in self.playlists]}

    def get_track_details(self, track_id: str) -> Dict[str, Any]:
        return self.tracks.get(track_id, {"id": track_id, "name": "Unknown"})

    def get_audio_features(self, track_id: str) -> Dict[str, Any]:
        return self.audio_features.get(track_id, {})

    def get_multiple_audio_features(self, track_ids: list[str]) -> Dict[str, Any]:
        return {
            "audio_features": [self.audio_features.get(track_id, {"id": track_id}) for track_id in track_ids]
        }

    def get_playlist_items(self, playlist_id: str, limit: int = 100) -> Dict[str, Any]:
        return self.playlist_items.get(playlist_id, {"items": [], "total": 0})

    def add_tracks_to_playlist(self, playlist_id: str, track_uris: list[str]) -> Dict[str, Any]:
        playlist = self.playlist_items.setdefault(playlist_id, {"items": [], "total": 0})
        for uri in track_uris:
            playlist["items"].append({"track": {"uri": uri}})
        playlist["total"] = len(playlist["items"])
        return {"snapshot_id": "mock"}

    def remove_tracks_from_playlist(self, playlist_id: str, track_uris: list[str]) -> Dict[str, Any]:
        playlist = self.playlist_items.setdefault(playlist_id, {"items": [], "total": 0})
        playlist["items"] = [
            item for item in playlist["items"] if item.get("track", {}).get("uri") not in set(track_uris)
        ]
        playlist["total"] = len(playlist["items"])
        return {"snapshot_id": "mock"}

    def reorder_playlist_items(
        self, playlist_id: str, range_start: int, insert_before: int
    ) -> Dict[str, Any]:
        playlist = self.playlist_items.setdefault(playlist_id, {"items": [], "total": 0})
        items = playlist["items"]
        if 0 <= range_start < len(items):
            track = items.pop(range_start)
            insert_index = max(0, min(insert_before, len(items)))
            items.insert(insert_index, track)
        playlist["items"] = items
        return {"snapshot_id": "reordered"}

    def get_saved_tracks(self, limit: int = 20) -> Dict[str, Any]:
        saved_items = [
            {"track": self.tracks.get(track_id, {"id": track_id})}
            for track_id in list(self.saved_track_ids)[:limit]
        ]
        return {"items": saved_items, "total": len(self.saved_track_ids)}

    def save_tracks(self, track_ids: list[str]) -> Dict[str, Any]:
        self.saved_track_ids.update(track_ids)
        return {"saved": sorted(self.saved_track_ids)}

    def remove_saved_tracks(self, track_ids: list[str]) -> Dict[str, Any]:
        for track_id in track_ids:
            self.saved_track_ids.discard(track_id)
        return {"saved": sorted(self.saved_track_ids)}

    def get_current_user(self) -> Dict[str, Any]:
        return {"id": "user-1", "display_name": "Harmony Tester"}

    def get_top_tracks(self, limit: int = 20) -> Dict[str, Any]:
        return {"items": list(self.tracks.values())[:limit]}

    def get_top_artists(self, limit: int = 20) -> Dict[str, Any]:
        return {"items": [{"id": "artist-1", "name": "Tester"}]}

    def get_recommendations(
        self,
        seed_tracks: list[str] | None = None,
        seed_artists: list[str] | None = None,
        seed_genres: list[str] | None = None,
        limit: int = 20,
    ) -> Dict[str, Any]:
        payload = dict(self.recommendation_payload)
        payload.setdefault("tracks", [])
        payload.setdefault("seeds", [])
        return payload


class StubPlexClient:
    def __init__(self) -> None:
        self.libraries = {
            "MediaContainer": {
                "Directory": [
                    {"key": "1", "type": "artist", "title": "Music"},
                ]
            }
        }
        self.library_items = {
            ("1", "10"): {
                "MediaContainer": {"totalSize": 2, "Metadata": [{"ratingKey": "a"}, {"ratingKey": "b"}]}
            },
            ("1", "9"): {
                "MediaContainer": {"totalSize": 3, "Metadata": [{"ratingKey": "a"}]}
            },
            ("1", "8"): {
                "MediaContainer": {"totalSize": 5, "Metadata": [{"ratingKey": "t"}]}
            },
        }
        self.metadata = {"100": {"title": "Test Item", "year": 2020}}
        self.sessions = {"MediaContainer": {"size": 1, "Metadata": [{"title": "Session"}]}}
        self.session_history = {"MediaContainer": {"size": 1, "Metadata": [{"title": "History"}]}}
        self.playlists = {"MediaContainer": {"size": 1, "Metadata": [{"title": "Playlist"}]}}
        self.created_playlists: list[dict[str, Any]] = []
        self.playqueues: Dict[str, Any] = {}
        self.timeline_updates: list[dict[str, Any]] = []
        self.scrobbles: list[dict[str, Any]] = []
        self.unscrobbles: list[dict[str, Any]] = []
        self.ratings: list[dict[str, Any]] = []
        self.tags: Dict[str, Dict[str, list[str]]] = {}
        self.devices = {"MediaContainer": {"Device": [{"name": "Player"}]}}
        self.dvr = {"MediaContainer": {"Directory": [{"name": "DVR"}]}}
        self.livetv = {"MediaContainer": {"Directory": [{"name": "Channel"}]}}

    async def get_sessions(self) -> Dict[str, Any]:
        return self.sessions

    async def get_library_statistics(self) -> Dict[str, int]:
        return {"artists": 2, "albums": 3, "tracks": 5}

    async def get_libraries(self, params: Dict[str, Any] | None = None) -> Dict[str, Any]:
        return self.libraries

    async def get_library_items(self, section_id: str, params: Dict[str, Any] | None = None) -> Dict[str, Any]:
        type_value = (params or {}).get("type", "")
        return self.library_items.get((section_id, type_value), {"MediaContainer": {"Metadata": []}})

    async def get_metadata(self, item_id: str) -> Dict[str, Any]:
        return self.metadata[item_id]

    async def get_session_history(self, params: Dict[str, Any] | None = None) -> Dict[str, Any]:
        return self.session_history

    async def get_timeline(self, params: Dict[str, Any] | None = None) -> Dict[str, Any]:
        return {"timeline": params or {}}

    async def update_timeline(self, data: Dict[str, Any]) -> str:
        self.timeline_updates.append(data)
        return "ok"

    async def scrobble(self, data: Dict[str, Any]) -> str:
        self.scrobbles.append(data)
        return "ok"

    async def unscrobble(self, data: Dict[str, Any]) -> str:
        self.unscrobbles.append(data)
        return "ok"

    async def get_playlists(self) -> Dict[str, Any]:
        return self.playlists

    async def create_playlist(self, payload: Dict[str, Any]) -> Dict[str, Any]:
        self.created_playlists.append(payload)
        return {"status": "created", "payload": payload}

    async def update_playlist(self, playlist_id: str, payload: Dict[str, Any]) -> Dict[str, Any]:
        return {"status": "updated", "id": playlist_id, "payload": payload}

    async def delete_playlist(self, playlist_id: str) -> Dict[str, Any]:
        return {"status": "deleted", "id": playlist_id}

    async def create_playqueue(self, payload: Dict[str, Any]) -> Dict[str, Any]:
        identifier = str(len(self.playqueues) + 1)
        self.playqueues[identifier] = payload
        return {"playQueueID": identifier, "payload": payload}

    async def get_playqueue(self, playqueue_id: str) -> Dict[str, Any]:
        return self.playqueues.get(playqueue_id, {})

    async def rate_item(self, item_id: str, rating: int) -> str:
        self.ratings.append({"key": item_id, "rating": rating})
        return "ok"

    async def sync_tags(self, item_id: str, tags: Dict[str, list[str]]) -> Dict[str, Any]:
        self.tags[item_id] = tags
        return {"status": "tags-updated", "id": item_id, "tags": tags}

    async def get_devices(self) -> Dict[str, Any]:
        return self.devices

    async def get_dvr(self) -> Dict[str, Any]:
        return self.dvr

    async def get_live_tv(self, params: Dict[str, Any] | None = None) -> Dict[str, Any]:
        return self.livetv

    @asynccontextmanager
    async def listen_notifications(self):  # pragma: no cover - exercised via tests
        class _Message:
            def __init__(self) -> None:
                self.type = type("Type", (), {"name": "TEXT"})
                self.data = "event"

        class _Websocket:
            def __init__(self) -> None:
                self._sent = False

            def exception(self):
                return None

            def __aiter__(self):
                return self

            async def __anext__(self):
                if self._sent:
                    raise StopAsyncIteration
                self._sent = True
                return _Message()

        yield _Websocket()


class StubSoulseekClient:
    def __init__(self) -> None:
        self.downloads: Dict[int, Dict[str, Any]] = {}
        self.queue_positions: Dict[int, Dict[str, Any]] = {}
        self.uploads: Dict[str, Dict[str, Any]] = {
            "up-1": {"id": "up-1", "filename": "upload.flac", "state": "uploading", "progress": 40.0},
            "up-2": {"id": "up-2", "filename": "done.flac", "state": "completed", "progress": 100.0},
        }
        self.enqueued: list[Dict[str, Any]] = []
        self.user_records: Dict[str, Dict[str, Any]] = {
            "tester": {
                "address": {"host": "127.0.0.1", "port": 2234},
                "browse": {"files": ["song.mp3"]},
                "browsing-status": {"state": "idle"},
                "directory": {"path": "", "files": []},
                "info": {"username": "tester", "slots": 3},
                "status": {"online": True},
            }
        }

    async def get_download_status(self) -> Dict[str, Any]:
        return {"downloads": list(self.downloads.values())}

    async def search(self, query: str) -> Dict[str, Any]:
        return {"results": [query]}

    async def download(self, payload: Dict[str, Any]) -> Dict[str, Any]:
        for file_info in payload.get("files", []):
            identifier = int(file_info.get("download_id", 0))
            if identifier <= 0:
                continue
            entry = {
                "id": identifier,
                "filename": file_info.get("filename", "unknown"),
                "progress": 0.0,
                "state": "queued",
            }
            self.downloads[identifier] = entry
        return {"status": "queued"}

    async def cancel_download(self, download_id: str) -> Dict[str, Any]:
        identifier = int(download_id)
        if identifier in self.downloads:
            self.downloads[identifier]["state"] = "failed"
        return {"cancelled": download_id}

    async def get_download(self, download_id: str) -> Dict[str, Any]:
        identifier = int(download_id)
        return self.downloads.get(identifier, {"id": identifier, "state": "unknown"})

    async def get_all_downloads(self) -> list[Dict[str, Any]]:
        return list(self.downloads.values())

    async def remove_completed_downloads(self) -> Dict[str, Any]:
        before = len(self.downloads)
        self.downloads = {k: v for k, v in self.downloads.items() if v.get("state") != "completed"}
        removed = before - len(self.downloads)
        return {"removed": removed}

    async def get_queue_position(self, download_id: str) -> Dict[str, Any]:
        identifier = int(download_id)
        return self.queue_positions.get(identifier, {"position": None})

    async def enqueue(self, username: str, files: list[Dict[str, Any]]) -> Dict[str, Any]:
        job = {"username": username, "files": files}
        self.enqueued.append(job)
        return {"status": "enqueued", "job": job}

    async def cancel_upload(self, upload_id: str) -> Dict[str, Any]:
        upload = self.uploads.get(upload_id)
        if upload:
            upload["state"] = "cancelled"
        return {"cancelled": upload_id}

    async def get_upload(self, upload_id: str) -> Dict[str, Any]:
        return self.uploads.get(upload_id, {"id": upload_id, "state": "unknown"})

    async def get_uploads(self) -> list[Dict[str, Any]]:
        return [upload for upload in self.uploads.values() if upload.get("state") != "completed"]

    async def get_all_uploads(self) -> list[Dict[str, Any]]:
        return list(self.uploads.values())

    async def remove_completed_uploads(self) -> Dict[str, Any]:
        before = len(self.uploads)
        self.uploads = {k: v for k, v in self.uploads.items() if v.get("state") != "completed"}
        removed = before - len(self.uploads)
        return {"removed": removed}

    async def user_address(self, username: str) -> Dict[str, Any]:
        record = self.user_records.get(username, {})
        return record.get("address", {"host": None, "port": None})

    async def user_browse(self, username: str) -> Dict[str, Any]:
        record = self.user_records.get(username, {})
        return record.get("browse", {"files": []})

    async def user_browsing_status(self, username: str) -> Dict[str, Any]:
        record = self.user_records.get(username, {})
        return record.get("browsing-status", {"state": "unknown"})

    async def user_directory(self, username: str, path: str) -> Dict[str, Any]:
        record = self.user_records.setdefault(username, {})
        directory = record.get("directory", {"path": path, "files": []})
        directory = dict(directory)
        directory["path"] = path
        return directory

    async def user_info(self, username: str) -> Dict[str, Any]:
        record = self.user_records.get(username, {})
        return record.get("info", {"username": username})

    async def user_status(self, username: str) -> Dict[str, Any]:
        record = self.user_records.get(username, {})
        return record.get("status", {"online": False})

    def set_status(
        self,
        download_id: int,
        *,
        progress: float | None = None,
        state: str | None = None,
    ) -> None:
        entry = self.downloads.setdefault(
            download_id,
            {
                "id": download_id,
                "filename": f"download-{download_id}",
                "progress": 0.0,
                "state": "queued",
            },
        )
        if progress is not None:
            entry["progress"] = progress
        if state is not None:
            entry["state"] = state


@pytest.fixture(autouse=True)
def configure_environment(monkeypatch: pytest.MonkeyPatch) -> None:
    monkeypatch.setenv("HARMONY_DISABLE_WORKERS", "1")
    monkeypatch.setenv("DATABASE_URL", "sqlite:///./test.db")
    reset_engine_for_tests()
    db_path = Path("test.db")
    if db_path.exists():
        db_path.unlink()
    init_db()
    yield


@pytest.fixture
def client(monkeypatch: pytest.MonkeyPatch) -> SimpleTestClient:
    stub_spotify = StubSpotifyClient()
    stub_plex = StubPlexClient()
    stub_soulseek = StubSoulseekClient()
    engine = dependency_matching_engine()

    async def noop_start(self) -> None:  # type: ignore[override]
        return None

    async def noop_stop(self) -> None:  # type: ignore[override]
        return None

    # Prevent worker tasks during tests
    monkeypatch.setattr(SyncWorker, "start", noop_start)
    monkeypatch.setattr(MatchingWorker, "start", noop_start)
    monkeypatch.setattr(ScanWorker, "start", noop_start)
    monkeypatch.setattr(PlaylistSyncWorker, "start", noop_start)
    monkeypatch.setattr(SyncWorker, "stop", noop_stop)
    monkeypatch.setattr(MatchingWorker, "stop", noop_stop)
    monkeypatch.setattr(ScanWorker, "stop", noop_stop)
    monkeypatch.setattr(PlaylistSyncWorker, "stop", noop_stop)

    from app import dependencies as deps

    monkeypatch.setattr(deps, "get_spotify_client", lambda: stub_spotify)
    monkeypatch.setattr(deps, "get_plex_client", lambda: stub_plex)
    monkeypatch.setattr(deps, "get_soulseek_client", lambda: stub_soulseek)
    monkeypatch.setattr(deps, "get_matching_engine", lambda: engine)

    app.dependency_overrides[dependency_spotify_client] = lambda: stub_spotify
    app.dependency_overrides[dependency_plex_client] = lambda: stub_plex
    app.dependency_overrides[dependency_soulseek_client] = lambda: stub_soulseek
    app.dependency_overrides[dependency_matching_engine] = lambda: engine

    app.state.soulseek_stub = stub_soulseek
    app.state.plex_stub = stub_plex
    app.state.spotify_stub = stub_spotify
    app.state.sync_worker = SyncWorker(stub_soulseek)
    app.state.playlist_worker = PlaylistSyncWorker(stub_spotify, interval_seconds=0.1)

    with SimpleTestClient(app) as test_client:
        yield test_client

    app.dependency_overrides.clear()

===== tests/simple_client.py =====
from __future__ import annotations

import asyncio
import json
from types import TracebackType
from typing import Any, Dict, Optional, Type
from urllib.parse import urlencode

from fastapi import FastAPI


class SimpleResponse:
    def __init__(self, status_code: int, body: bytes, headers: Dict[str, str]) -> None:
        self.status_code = status_code
        self._body = body
        self.headers = headers

    def json(self) -> Any:
        if not self._body:
            return None
        return json.loads(self._body.decode("utf-8"))


class SimpleTestClient:
    def __init__(self, app: FastAPI) -> None:
        self.app = app
        self._loop = asyncio.new_event_loop()
        self._previous_loop: Optional[asyncio.AbstractEventLoop] = None

    def __enter__(self) -> "SimpleTestClient":
        try:
            self._previous_loop = asyncio.get_event_loop()
        except RuntimeError:
            self._previous_loop = None
        asyncio.get_event_loop_policy().set_event_loop(self._loop)
        self._loop.run_until_complete(self.app.router.startup())
        return self

    def __exit__(
        self,
        exc_type: Optional[Type[BaseException]],
        exc: Optional[BaseException],
        tb: Optional[TracebackType],
    ) -> None:
        self._loop.run_until_complete(self.app.router.shutdown())
        self._loop.close()
        if self._previous_loop is not None:
            asyncio.get_event_loop_policy().set_event_loop(self._previous_loop)

    def get(self, path: str, params: Optional[Dict[str, Any]] = None) -> SimpleResponse:
        return self._loop.run_until_complete(self._request("GET", path, params=params))

    def post(
        self,
        path: str,
        json_body: Optional[Dict[str, Any]] = None,
        json: Optional[Dict[str, Any]] = None,
    ) -> SimpleResponse:
        payload = json_body if json_body is not None else json
        return self._loop.run_until_complete(self._request("POST", path, json_body=payload))

    def put(self, path: str, json: Optional[Dict[str, Any]] = None) -> SimpleResponse:
        return self._loop.run_until_complete(self._request("PUT", path, json_body=json))

    def delete(self, path: str, json: Optional[Dict[str, Any]] = None) -> SimpleResponse:
        return self._loop.run_until_complete(self._request("DELETE", path, json_body=json))

    async def _request(
        self,
        method: str,
        path: str,
        params: Optional[Dict[str, Any]] = None,
        json_body: Optional[Dict[str, Any]] = None,
    ) -> SimpleResponse:
        query_string = urlencode(params or {})
        scope = {
            "type": "http",
            "http_version": "1.1",
            "method": method,
            "path": path,
            "raw_path": path.encode("utf-8"),
            "query_string": query_string.encode("utf-8"),
            "headers": [],
        }

        body = b""
        if json_body is not None:
            body = json.dumps(json_body).encode("utf-8")
            scope["headers"].append((b"content-type", b"application/json"))

        response_body = bytearray()
        response_headers: Dict[str, str] = {}
        status_code = 500
        request_complete = False

        async def receive() -> Dict[str, Any]:
            nonlocal request_complete
            if request_complete:
                return {"type": "http.disconnect"}
            request_complete = True
            return {"type": "http.request", "body": body, "more_body": False}

        async def send(message: Dict[str, Any]) -> None:
            nonlocal status_code, response_headers
            if message["type"] == "http.response.start":
                status_code = message["status"]
                response_headers = {key.decode(): value.decode() for key, value in message.get("headers", [])}
            elif message["type"] == "http.response.body":
                response_body.extend(message.get("body", b""))

        await self.app(scope, receive, send)
        return SimpleResponse(status_code, bytes(response_body), response_headers)

===== tests/test_beets.py =====
from __future__ import annotations

import subprocess
from pathlib import Path
from typing import Sequence
from unittest.mock import AsyncMock, MagicMock, patch

import pytest

from fastapi import FastAPI
from fastapi.testclient import TestClient

from app.core.beets_client import BeetsClient, BeetsClientError
from app.routers import beets_router


@pytest.fixture()
def api_client() -> TestClient:
    app = FastAPI()
    app.include_router(beets_router.router, prefix="/beets")
    return TestClient(app)


def _completed(args: Sequence[str], stdout: str = "") -> subprocess.CompletedProcess[str]:
    return subprocess.CompletedProcess(args=list(args), returncode=0, stdout=stdout, stderr="")


DEFAULT_RUN_KWARGS = {
    "capture_output": True,
    "text": True,
    "check": True,
    "timeout": 60.0,
}


def _assert_run_called(
    mock_run: MagicMock,
    expected_args: Sequence[str],
    *,
    env: dict | None = None,
) -> None:
    mock_run.assert_called_once()
    args, kwargs = mock_run.call_args
    assert list(args[0]) == list(expected_args)
    expected_kwargs = dict(DEFAULT_RUN_KWARGS)
    if env is not None:
        expected_kwargs["env"] = env
    assert kwargs == expected_kwargs


class TestImportFile:
    @patch("app.core.beets_client.subprocess.run")
    def test_success(self, mock_run: MagicMock) -> None:
        mock_run.return_value = _completed(["beet", "import", "-q", "track.mp3"], "imported\n")

        client = BeetsClient()

        result = client.import_file("track.mp3")

        assert result == "imported"
        _assert_run_called(mock_run, ["beet", "import", "-q", "track.mp3"])

    @patch("app.core.beets_client.subprocess.run")
    def test_options(self, mock_run: MagicMock) -> None:
        mock_run.return_value = _completed(["beet", "import", "-A", "file.mp3"])

        client = BeetsClient()

        client.import_file(Path("file.mp3"), quiet=False, autotag=False)

        _assert_run_called(mock_run, ["beet", "import", "-A", "file.mp3"])

    @patch("app.core.beets_client.subprocess.run")
    def test_called_process_error(self, mock_run: MagicMock) -> None:
        mock_run.side_effect = subprocess.CalledProcessError(
            1, ["beet", "import"], stderr="boom"
        )

        client = BeetsClient()

        with pytest.raises(BeetsClientError):
            client.import_file("track.mp3")

    @patch("app.core.beets_client.subprocess.run")
    def test_unexpected_error(self, mock_run: MagicMock) -> None:
        mock_run.side_effect = OSError("missing beet")

        client = BeetsClient()

        with pytest.raises(BeetsClientError):
            client.import_file("track.mp3")


class TestUpdate:
    @patch("app.core.beets_client.subprocess.run")
    def test_success(self, mock_run: MagicMock) -> None:
        mock_run.return_value = _completed(["beet", "update"], "done\n")

        client = BeetsClient()

        result = client.update()

        assert result == "done"
        _assert_run_called(mock_run, ["beet", "update"])

    @patch("app.core.beets_client.subprocess.run")
    def test_with_path(self, mock_run: MagicMock) -> None:
        mock_run.return_value = _completed(["beet", "update", "/library"])

        client = BeetsClient()

        client.update("/library")

        _assert_run_called(mock_run, ["beet", "update", "/library"])

    @patch("app.core.beets_client.subprocess.run")
    def test_failure(self, mock_run: MagicMock) -> None:
        mock_run.side_effect = subprocess.CalledProcessError(1, ["beet", "update"])

        client = BeetsClient()

        with pytest.raises(BeetsClientError):
            client.update()


class TestListAlbums:
    @patch("app.core.beets_client.subprocess.run")
    def test_success(self, mock_run: MagicMock) -> None:
        mock_run.return_value = _completed(["beet", "ls", "-a"], "One\nTwo\n")

        client = BeetsClient()

        result = client.list_albums()

        assert result == ["One", "Two"]
        _assert_run_called(mock_run, ["beet", "ls", "-a"])

    @patch("app.core.beets_client.subprocess.run")
    def test_failure(self, mock_run: MagicMock) -> None:
        mock_run.side_effect = subprocess.CalledProcessError(1, ["beet", "ls", "-a"])

        client = BeetsClient()

        with pytest.raises(BeetsClientError):
            client.list_albums()


class TestListTracks:
    @patch("app.core.beets_client.subprocess.run")
    def test_success(self, mock_run: MagicMock) -> None:
        mock_run.return_value = _completed([
            "beet",
            "ls",
            "-f",
            "$title",
        ], "Foo\nBar\n")

        client = BeetsClient()

        result = client.list_tracks()

        assert result == ["Foo", "Bar"]
        _assert_run_called(mock_run, ["beet", "ls", "-f", "$title"])

    @patch("app.core.beets_client.subprocess.run")
    def test_failure(self, mock_run: MagicMock) -> None:
        mock_run.side_effect = subprocess.CalledProcessError(
            1, ["beet", "ls", "-f", "$title"]
        )

        client = BeetsClient()

        with pytest.raises(BeetsClientError):
            client.list_tracks()


class TestStats:
    @patch("app.core.beets_client.subprocess.run")
    def test_success(self, mock_run: MagicMock) -> None:
        mock_run.return_value = _completed(["beet", "stats"], "tracks: 42\n")

        client = BeetsClient()

        result = client.stats()

        assert result == {"tracks": "42"}
        _assert_run_called(mock_run, ["beet", "stats"])

    @patch("app.core.beets_client.subprocess.run")
    def test_failure(self, mock_run: MagicMock) -> None:
        mock_run.side_effect = subprocess.CalledProcessError(1, ["beet", "stats"])

        client = BeetsClient()

        with pytest.raises(BeetsClientError):
            client.stats()

    @patch("app.core.beets_client.subprocess.run")
    def test_timeout(self, mock_run: MagicMock) -> None:
        mock_run.side_effect = subprocess.TimeoutExpired(
            cmd=["beet", "stats"], timeout=60.0
        )

        client = BeetsClient()

        with pytest.raises(BeetsClientError) as exc:
            client.stats()

        assert str(exc.value) == "Command timed out"


class TestAvailability:
    @patch("app.core.beets_client.subprocess.run")
    def test_available(self, mock_run: MagicMock) -> None:
        mock_run.return_value = _completed(["beet", "version"], "beets 1.6\n")

        client = BeetsClient()

        assert client.is_available() is True
        _assert_run_called(mock_run, ["beet", "version"])

    @patch("app.core.beets_client.subprocess.run")
    def test_not_available(self, mock_run: MagicMock) -> None:
        mock_run.side_effect = subprocess.CalledProcessError(1, ["beet", "version"])

        client = BeetsClient()

        assert client.is_available() is False


class TestRemove:
    @patch("app.core.beets_client.subprocess.run")
    def test_success(self, mock_run: MagicMock) -> None:
        mock_run.return_value = _completed(
            ["beet", "remove", "genre:rock"], "Removed 2 items\n"
        )

        client = BeetsClient()

        result = client.remove("genre:rock")

        assert result == {"success": True, "removed": 2}
        _assert_run_called(mock_run, ["beet", "remove", "genre:rock"])

    @patch("app.core.beets_client.subprocess.run")
    def test_force(self, mock_run: MagicMock) -> None:
        mock_run.return_value = _completed([
            "beet",
            "remove",
            "-f",
            "genre:rock",
            "year:2020",
        ], "Removed 10 items\n")

        client = BeetsClient()

        result = client.remove("genre:rock year:2020", force=True)

        assert result == {"success": True, "removed": 10}
        _assert_run_called(
            mock_run,
            ["beet", "remove", "-f", "genre:rock", "year:2020"],
        )

    @patch("app.core.beets_client.subprocess.run")
    def test_failure(self, mock_run: MagicMock) -> None:
        mock_run.side_effect = subprocess.CalledProcessError(
            1, ["beet", "remove", "genre:rock"], stderr="error"
        )

        client = BeetsClient()

        with pytest.raises(BeetsClientError):
            client.remove("genre:rock")

    @patch("app.core.beets_client.subprocess.run")
    def test_timeout(self, mock_run: MagicMock) -> None:
        mock_run.side_effect = subprocess.TimeoutExpired(
            cmd=["beet", "remove"], timeout=60.0
        )

        client = BeetsClient()

        with pytest.raises(BeetsClientError) as exc:
            client.remove("genre:rock")

        assert str(exc.value) == "Command timed out"

    def test_empty_query(self) -> None:
        client = BeetsClient()

        with pytest.raises(BeetsClientError):
            client.remove(" ")


class TestMove:
    @patch("app.core.beets_client.subprocess.run")
    def test_without_query(self, mock_run: MagicMock) -> None:
        mock_run.return_value = _completed(["beet", "move"], "Moved 5 items\n")

        client = BeetsClient()

        result = client.move()

        assert result == {"success": True, "moved": 5}
        _assert_run_called(mock_run, ["beet", "move"])

    @patch("app.core.beets_client.subprocess.run")
    def test_with_query(self, mock_run: MagicMock) -> None:
        mock_run.return_value = _completed(
            ["beet", "move", "artist:Radiohead"], "Moved 1 items\n"
        )

        client = BeetsClient()

        result = client.move("artist:Radiohead")

        assert result == {"success": True, "moved": 1}
        _assert_run_called(mock_run, ["beet", "move", "artist:Radiohead"])

    @patch("app.core.beets_client.subprocess.run")
    def test_failure(self, mock_run: MagicMock) -> None:
        mock_run.side_effect = subprocess.CalledProcessError(
            1, ["beet", "move"], stderr="fail"
        )

        client = BeetsClient()

        with pytest.raises(BeetsClientError):
            client.move()

    @patch("app.core.beets_client.subprocess.run")
    def test_timeout(self, mock_run: MagicMock) -> None:
        mock_run.side_effect = subprocess.TimeoutExpired(
            cmd=["beet", "move"], timeout=60.0
        )

        client = BeetsClient()

        with pytest.raises(BeetsClientError) as exc:
            client.move()

        assert str(exc.value) == "Command timed out"


class TestWrite:
    @patch("app.core.beets_client.subprocess.run")
    def test_without_query(self, mock_run: MagicMock) -> None:
        mock_run.return_value = _completed(["beet", "write"], "Wrote 4 items\n")

        client = BeetsClient()

        result = client.write()

        assert result == {"success": True, "written": 4}
        _assert_run_called(mock_run, ["beet", "write"])

    @patch("app.core.beets_client.subprocess.run")
    def test_with_query(self, mock_run: MagicMock) -> None:
        mock_run.return_value = _completed(
            ["beet", "write", "year:2020"], "No changes"
        )

        client = BeetsClient()

        result = client.write("year:2020")

        assert result == {"success": True, "output": "No changes"}
        _assert_run_called(mock_run, ["beet", "write", "year:2020"])

    @patch("app.core.beets_client.subprocess.run")
    def test_failure(self, mock_run: MagicMock) -> None:
        mock_run.side_effect = subprocess.CalledProcessError(
            1, ["beet", "write"], stderr="fail"
        )

        client = BeetsClient()

        with pytest.raises(BeetsClientError):
            client.write()

    @patch("app.core.beets_client.subprocess.run")
    def test_timeout(self, mock_run: MagicMock) -> None:
        mock_run.side_effect = subprocess.TimeoutExpired(
            cmd=["beet", "write"], timeout=60.0
        )

        client = BeetsClient()

        with pytest.raises(BeetsClientError) as exc:
            client.write()

        assert str(exc.value) == "Command timed out"


class TestFields:
    @patch("app.core.beets_client.subprocess.run")
    def test_fields(self, mock_run: MagicMock) -> None:
        mock_run.return_value = _completed([
            "beet",
            "fields",
        ], "artist\nalbum\n")

        client = BeetsClient()

        result = client.fields()

        assert result == ["artist", "album"]
        _assert_run_called(mock_run, ["beet", "fields"])

    @patch("app.core.beets_client.subprocess.run")
    def test_failure(self, mock_run: MagicMock) -> None:
        mock_run.side_effect = subprocess.CalledProcessError(
            1, ["beet", "fields"], stderr="oops"
        )

        client = BeetsClient()

        with pytest.raises(BeetsClientError):
            client.fields()

    @patch("app.core.beets_client.subprocess.run")
    def test_timeout(self, mock_run: MagicMock) -> None:
        mock_run.side_effect = subprocess.TimeoutExpired(
            cmd=["beet", "fields"], timeout=60.0
        )

        client = BeetsClient()

        with pytest.raises(BeetsClientError) as exc:
            client.fields()

        assert str(exc.value) == "Command timed out"


class TestQuery:
    @patch("app.core.beets_client.subprocess.run")
    def test_query(self, mock_run: MagicMock) -> None:
        mock_run.return_value = _completed([
            "beet",
            "ls",
            "-f",
            "$artist - $title",
            "genre:rock",
            "year:1990",
        ], "Artist - Song\n")

        client = BeetsClient()

        result = client.query("genre:rock year:1990", fmt="$artist - $title")

        assert result == ["Artist - Song"]
        _assert_run_called(
            mock_run,
            [
                "beet",
                "ls",
                "-f",
                "$artist - $title",
                "genre:rock",
                "year:1990",
            ],
        )

    def test_invalid_query(self) -> None:
        client = BeetsClient()

        with pytest.raises(BeetsClientError):
            client.query("\"")

    @patch("app.core.beets_client.subprocess.run")
    def test_failure(self, mock_run: MagicMock) -> None:
        mock_run.side_effect = subprocess.CalledProcessError(
            1, ["beet", "ls"], stderr="boom"
        )

        client = BeetsClient()

        with pytest.raises(BeetsClientError):
            client.query("genre:rock")

    @patch("app.core.beets_client.subprocess.run")
    def test_timeout(self, mock_run: MagicMock) -> None:
        mock_run.side_effect = subprocess.TimeoutExpired(
            cmd=["beet", "ls"], timeout=60.0
        )

        client = BeetsClient()

        with pytest.raises(BeetsClientError) as exc:
            client.query("genre:rock")

        assert str(exc.value) == "Command timed out"


class TestEnvironment:
    @patch("app.core.beets_client.subprocess.run")
    def test_env_passed(self, mock_run: MagicMock) -> None:
        mock_run.return_value = _completed(["beet", "stats"], "")

        client = BeetsClient(env={"BEETSDIR": "/tmp/beets"})

        client.stats()

        mock_run.assert_called_once()
        _, kwargs = mock_run.call_args
        assert kwargs["env"]["BEETSDIR"] == "/tmp/beets"
        assert kwargs["timeout"] == 60.0


class TestRouterImport:
    @patch("app.routers.beets_router.run_in_threadpool", new_callable=AsyncMock)
    def test_import_options(self, mock_pool: AsyncMock, api_client: TestClient) -> None:
        mock_pool.return_value = "Imported"

        response = api_client.post(
            "/beets/import",
            json={"path": "music", "quiet": False, "autotag": False},
        )

        assert response.status_code == 200
        assert response.json() == {"success": True, "message": "Imported"}
        mock_pool.assert_awaited_once()
        call_args = mock_pool.await_args
        method = call_args.args[0]
        assert method.__self__ is beets_router.beets_client
        assert method.__name__ == "import_file"
        assert call_args.args[1] == "music"
        assert call_args.kwargs == {"quiet": False, "autotag": False}


class TestRouterRemove:
    @patch("app.routers.beets_router.run_in_threadpool", new_callable=AsyncMock)
    def test_remove(self, mock_pool: AsyncMock, api_client: TestClient) -> None:
        mock_pool.return_value = {"success": True, "removed": 5}

        response = api_client.post(
            "/beets/remove",
            json={"query": "artist:Metallica year:1986", "force": True},
        )

        assert response.status_code == 200
        assert response.json() == {"success": True, "removed": 5}
        mock_pool.assert_awaited_once()
        call_args = mock_pool.await_args
        method = call_args.args[0]
        assert method.__self__ is beets_router.beets_client
        assert method.__name__ == "remove"
        assert call_args.args[1:] == ("artist:Metallica year:1986",)
        assert call_args.kwargs == {"force": True}

    @patch("app.routers.beets_router.run_in_threadpool", new_callable=AsyncMock)
    def test_remove_invalid_query(self, mock_pool: AsyncMock, api_client: TestClient) -> None:
        mock_pool.side_effect = BeetsClientError("Invalid query syntax: missing quote")

        response = api_client.post(
            "/beets/remove",
            json={"query": "artist:'Bad", "force": False},
        )

        assert response.status_code == 400
        assert response.json()["detail"] == "Invalid query syntax"

    def test_remove_empty_query(self, api_client: TestClient) -> None:
        response = api_client.post("/beets/remove", json={"query": ""})

        assert response.status_code == 400
        assert response.json()["detail"] == "Query must not be empty"


class TestRouterMove:
    @patch("app.routers.beets_router.run_in_threadpool", new_callable=AsyncMock)
    def test_move_with_query(self, mock_pool: AsyncMock, api_client: TestClient) -> None:
        mock_pool.return_value = {"success": True, "moved": 2}

        response = api_client.post(
            "/beets/move",
            json={"query": "artist:Radiohead"},
        )

        assert response.status_code == 200
        assert response.json() == {"success": True, "moved": 2}
        mock_pool.assert_awaited_once()
        call_args = mock_pool.await_args
        method = call_args.args[0]
        assert method.__self__ is beets_router.beets_client
        assert method.__name__ == "move"
        assert call_args.args[1:] == ("artist:Radiohead",)
        assert call_args.kwargs == {}

    @patch("app.routers.beets_router.run_in_threadpool", new_callable=AsyncMock)
    def test_move_without_query(self, mock_pool: AsyncMock, api_client: TestClient) -> None:
        mock_pool.return_value = {"success": True, "moved": 4}

        response = api_client.post("/beets/move", json={})

        assert response.status_code == 200
        assert response.json() == {"success": True, "moved": 4}
        mock_pool.assert_awaited_once()
        call_args = mock_pool.await_args
        method = call_args.args[0]
        assert method.__self__ is beets_router.beets_client
        assert method.__name__ == "move"
        assert call_args.args[1:] == (None,)
        assert call_args.kwargs == {}

    @patch("app.routers.beets_router.run_in_threadpool", new_callable=AsyncMock)
    def test_move_client_error(self, mock_pool: AsyncMock, api_client: TestClient) -> None:
        mock_pool.side_effect = BeetsClientError("Command failed")

        response = api_client.post("/beets/move", json={})

        assert response.status_code == 500
        assert response.json()["detail"] == "Command failed"


class TestRouterWrite:
    @patch("app.routers.beets_router.run_in_threadpool", new_callable=AsyncMock)
    def test_write_with_query(self, mock_pool: AsyncMock, api_client: TestClient) -> None:
        mock_pool.return_value = {"success": True, "written": 3}

        response = api_client.post(
            "/beets/write",
            json={"query": "year:2020"},
        )

        assert response.status_code == 200
        assert response.json() == {"success": True, "written": 3}
        mock_pool.assert_awaited_once()
        call_args = mock_pool.await_args
        method = call_args.args[0]
        assert method.__self__ is beets_router.beets_client
        assert method.__name__ == "write"
        assert call_args.args[1:] == ("year:2020",)
        assert call_args.kwargs == {}

    @patch("app.routers.beets_router.run_in_threadpool", new_callable=AsyncMock)
    def test_write_without_query(self, mock_pool: AsyncMock, api_client: TestClient) -> None:
        mock_pool.return_value = {"success": True, "output": "done"}

        response = api_client.post("/beets/write", json={})

        assert response.status_code == 200
        assert response.json() == {"success": True, "output": "done"}
        mock_pool.assert_awaited_once()
        call_args = mock_pool.await_args
        method = call_args.args[0]
        assert method.__self__ is beets_router.beets_client
        assert method.__name__ == "write"
        assert call_args.args[1:] == (None,)
        assert call_args.kwargs == {}


class TestRouterFields:
    @patch("app.routers.beets_router.run_in_threadpool", new_callable=AsyncMock)
    def test_fields(self, mock_pool: AsyncMock, api_client: TestClient) -> None:
        mock_pool.return_value = ["artist", "album"]

        response = api_client.get("/beets/fields")

        assert response.status_code == 200
        assert response.json() == {"fields": ["artist", "album"]}
        mock_pool.assert_awaited_once()
        call_args = mock_pool.await_args
        method = call_args.args[0]
        assert method.__self__ is beets_router.beets_client
        assert method.__name__ == "fields"
        assert call_args.args[1:] == ()
        assert call_args.kwargs == {}


class TestRouterQuery:
    @patch("app.routers.beets_router.run_in_threadpool", new_callable=AsyncMock)
    def test_query(self, mock_pool: AsyncMock, api_client: TestClient) -> None:
        mock_pool.return_value = ["Artist - Song"]

        response = api_client.post(
            "/beets/query",
            json={"query": "genre:rock", "format": "$artist - $title"},
        )

        assert response.status_code == 200
        assert response.json() == {"results": ["Artist - Song"]}
        mock_pool.assert_awaited_once()
        call_args = mock_pool.await_args
        method = call_args.args[0]
        assert method.__self__ is beets_router.beets_client
        assert method.__name__ == "query"
        assert call_args.args[1:] == ("genre:rock",)
        assert call_args.kwargs == {"fmt": "$artist - $title"}

    @patch("app.routers.beets_router.run_in_threadpool", new_callable=AsyncMock)
    def test_query_invalid(self, mock_pool: AsyncMock, api_client: TestClient) -> None:
        mock_pool.side_effect = BeetsClientError("Invalid query syntax: ")

        response = api_client.post(
            "/beets/query",
            json={"query": '"'},
        )

        assert response.status_code == 400
        assert response.json()["detail"] == "Invalid query syntax"


===== tests/test_matching.py =====
from __future__ import annotations

from app.core.matching_engine import MusicMatchingEngine
from tests.simple_client import SimpleTestClient


def test_match_confidence() -> None:
    engine = MusicMatchingEngine()
    spotify_track = {
        "id": "track-1",
        "name": "Test Song",
        "artists": [{"name": "Tester"}],
        "album": {"name": "Album"},
        "duration_ms": 200000,
    }
    plex_track = {
        "id": "100",
        "title": "Test Song",
        "artist": "Tester",
        "album": "Album",
        "duration": 200000,
    }
    score = engine.calculate_match_confidence(spotify_track, plex_track)
    assert score > 0.8


def test_matching_api_plex(client: SimpleTestClient) -> None:
    payload = {
        "spotify_track": {
            "id": "track-1",
            "name": "Test Song",
            "artists": [{"name": "Tester"}],
            "album": {"name": "Album"},
            "duration_ms": 200000,
        },
        "candidates": [
            {"id": "100", "title": "Test Song", "artist": "Tester", "album": "Album", "duration": 200000}
        ],
    }
    response = client.post("/matching/spotify-to-plex", json=payload)
    assert response.status_code == 200
    data = response.json()
    assert data["best_match"]["id"] == "100"
    assert data["confidence"] > 0.5


def test_matching_api_soulseek(client: SimpleTestClient) -> None:
    payload = {
        "spotify_track": {
            "id": "track-1",
            "name": "Test Song",
            "artists": [{"name": "Tester"}],
            "album": {"name": "Album"},
        },
        "candidates": [
            {"filename": "Tester - Test Song.mp3", "username": "Tester", "bitrate": 320}
        ],
    }
    response = client.post("/matching/spotify-to-soulseek", json=payload)
    assert response.status_code == 200
    assert response.json()["confidence"] > 0.5


def test_album_matching_engine() -> None:
    engine = MusicMatchingEngine()
    spotify_album = {
        "id": "album-1",
        "name": "Test Album",
        "artists": [{"name": "Tester"}],
        "total_tracks": 10,
        "release_date": "2020-05-01",
    }
    plex_albums = [
        {
            "ratingKey": "201",
            "title": "Test Album",
            "grandparentTitle": "Tester",
            "leafCount": 10,
            "year": 2020,
        },
        {
            "ratingKey": "202",
            "title": "Other Album",
            "grandparentTitle": "Tester",
            "leafCount": 8,
            "year": 2018,
        },
    ]
    match, score = engine.find_best_album_match(spotify_album, plex_albums)
    assert match["ratingKey"] == "201"
    assert score > 0.8


def test_matching_api_album(client: SimpleTestClient) -> None:
    payload = {
        "spotify_album": {
            "id": "album-1",
            "name": "Test Album",
            "artists": [{"name": "Tester"}],
            "total_tracks": 10,
            "release_date": "2020-05-01",
        },
        "candidates": [
            {
                "ratingKey": "201",
                "title": "Test Album",
                "grandparentTitle": "Tester",
                "leafCount": 10,
                "year": 2020,
            },
            {
                "ratingKey": "202",
                "title": "Other Album",
                "grandparentTitle": "Tester",
                "leafCount": 8,
                "year": 2018,
            },
        ],
    }
    response = client.post("/matching/spotify-to-plex-album", json=payload)
    assert response.status_code == 200
    data = response.json()
    assert data["best_match"]["ratingKey"] == "201"
    assert data["confidence"] > 0.8

===== tests/test_plex.py =====
from __future__ import annotations

import asyncio
from typing import Dict

from fastapi import status

from app.db import session_scope
from app.models import Setting
from app.workers.scan_worker import ScanWorker
from tests.simple_client import SimpleTestClient


def test_plex_status(client: SimpleTestClient) -> None:
    response = client.get("/plex/status")
    assert response.status_code == status.HTTP_200_OK
    payload = response.json()
    assert payload["status"] == "connected"
    assert payload["library"] == {"artists": 2, "albums": 3, "tracks": 5}


def test_library_endpoints(client: SimpleTestClient) -> None:
    response = client.get("/plex/library/sections")
    assert response.status_code == status.HTTP_200_OK
    assert response.json()["MediaContainer"]["Directory"][0]["title"] == "Music"

    response = client.get("/plex/library/sections/1/all", params={"type": "8"})
    assert response.status_code == status.HTTP_200_OK
    assert "MediaContainer" in response.json()

    response = client.get("/plex/library/metadata/100")
    assert response.status_code == status.HTTP_200_OK
    assert response.json()["title"] == "Test Item"


def test_session_endpoints(client: SimpleTestClient) -> None:
    response = client.get("/plex/status/sessions")
    assert response.status_code == status.HTTP_200_OK
    assert response.json()["MediaContainer"]["size"] == 1

    response = client.get("/plex/status/sessions/history/all")
    assert response.status_code == status.HTTP_200_OK
    assert response.json()["MediaContainer"]["size"] == 1


def test_timeline_and_scrobble(client: SimpleTestClient) -> None:
    response = client.get("/plex/timeline", params={"ratingKey": "1"})
    assert response.status_code == status.HTTP_200_OK
    assert response.json()["timeline"] == {"ratingKey": "1"}

    response = client.post("/plex/timeline", json={"time": 1000})
    assert response.status_code == status.HTTP_200_OK
    assert response.json() == "ok"

    response = client.post("/plex/scrobble", json={"key": "100"})
    assert response.status_code == status.HTTP_200_OK
    assert response.json() == "ok"

    response = client.post("/plex/unscrobble", json={"key": "100"})
    assert response.status_code == status.HTTP_200_OK
    assert response.json() == "ok"


def test_playlists_and_playqueue(client: SimpleTestClient) -> None:
    response = client.get("/plex/playlists")
    assert response.status_code == status.HTTP_200_OK

    response = client.post("/plex/playlists", json={"title": "New"})
    assert response.status_code == status.HTTP_200_OK
    assert response.json()["status"] == "created"

    response = client.put("/plex/playlists/42", json={"title": "Updated"})
    assert response.status_code == status.HTTP_200_OK
    assert response.json()["status"] == "updated"

    response = client.delete("/plex/playlists/42")
    assert response.status_code == status.HTTP_200_OK
    assert response.json()["status"] == "deleted"

    response = client.post("/plex/playQueues", json={"uri": "library://1"})
    assert response.status_code == status.HTTP_200_OK
    playqueue_id = response.json()["playQueueID"]

    response = client.get(f"/plex/playQueues/{playqueue_id}")
    assert response.status_code == status.HTTP_200_OK
    assert response.json()["uri"] == "library://1"


def test_rating_and_tags(client: SimpleTestClient) -> None:
    response = client.post("/plex/rate", json={"key": "100", "rating": 5})
    assert response.status_code == status.HTTP_200_OK
    assert response.json() == "ok"

    response = client.post("/plex/tags/100", json={"collection": ["Favorites"]})
    assert response.status_code == status.HTTP_200_OK
    assert response.json()["tags"] == {"collection": ["Favorites"]}


def test_devices_and_livetv(client: SimpleTestClient) -> None:
    response = client.get("/plex/devices")
    assert response.status_code == status.HTTP_200_OK
    assert response.json()["MediaContainer"]["Device"][0]["name"] == "Player"

    response = client.get("/plex/dvr")
    assert response.status_code == status.HTTP_200_OK
    assert response.json()["MediaContainer"]["Directory"][0]["name"] == "DVR"

    response = client.get("/plex/livetv")
    assert response.status_code == status.HTTP_200_OK
    assert response.json()["MediaContainer"]["Directory"][0]["name"] == "Channel"


def test_notifications(client: SimpleTestClient) -> None:
    response = client.get("/plex/notifications")
    assert response.status_code == status.HTTP_200_OK
    assert b"data: event" in response._body


def test_scan_worker_updates_status(client: SimpleTestClient) -> None:
    plex_stub = client.app.state.plex_stub
    worker = ScanWorker(plex_stub)

    asyncio.get_event_loop().run_until_complete(worker._perform_scan())

    with session_scope() as session:
        stored_settings: Dict[str, str] = {
            setting.key: setting.value
            for setting in session.query(Setting).all()
            if setting.key.startswith("plex_")
        }

    assert stored_settings["plex_artist_count"] == "2"
    assert stored_settings["plex_album_count"] == "3"
    assert stored_settings["plex_track_count"] == "5"
    assert "T" in stored_settings["plex_last_scan"]


===== tests/test_settings.py =====
from __future__ import annotations

from typing import List


def _extract_history_for_key(history: List[dict], key: str) -> List[dict]:
    return [entry for entry in history if entry["key"] == key]


def test_settings_history_tracking(client) -> None:
    response = client.post("/settings", json={"key": "theme", "value": "light"})
    assert response.status_code == 200

    response = client.post("/settings", json={"key": "theme", "value": "dark"})
    assert response.status_code == 200

    response = client.post("/settings", json={"key": "notifications", "value": "enabled"})
    assert response.status_code == 200

    history_response = client.get("/settings/history")
    assert history_response.status_code == 200
    payload = history_response.json()

    assert "history" in payload
    history_entries = payload["history"]
    assert len(history_entries) >= 3

    theme_history = _extract_history_for_key(history_entries, "theme")
    assert len(theme_history) == 2

    first_entry, second_entry = theme_history[0], theme_history[1]
    assert first_entry["new_value"] == "dark"
    assert first_entry["old_value"] == "light"
    assert second_entry["new_value"] == "light"
    assert second_entry["old_value"] is None
    assert first_entry["changed_at"] >= second_entry["changed_at"]

===== tests/test_soulseek.py =====
from __future__ import annotations

from tests.simple_client import SimpleTestClient


def test_soulseek_status(client: SimpleTestClient) -> None:
    response = client.get("/soulseek/status")
    assert response.status_code == 200
    assert response.json()["status"] == "connected"


def test_soulseek_search(client: SimpleTestClient) -> None:
    response = client.post("/soulseek/search", json={"query": "Test"})
    assert response.status_code == 200
    assert response.json()["results"] == ["Test"]


def test_soulseek_download_flow(client: SimpleTestClient) -> None:
    download_payload = {
        "username": "tester",
        "files": [{"filename": "song.mp3", "size": 123}],
    }
    response = client.post("/soulseek/download", json=download_payload)
    assert response.status_code == 200
    payload = response.json()
    assert payload["status"] == "queued"
    download_id = payload["detail"]["downloads"][0]["id"]

    response = client.get("/soulseek/downloads")
    assert response.status_code == 200
    downloads = response.json()["downloads"]
    download = next(item for item in downloads if item["id"] == download_id)
    assert download["state"] == "queued"
    assert download["progress"] == 0.0

    stub = client.app.state.soulseek_stub
    stub.set_status(download_id, progress=25.0, state="downloading")
    client._loop.run_until_complete(client.app.state.sync_worker.refresh_downloads())

    response = client.get("/soulseek/downloads")
    downloads = response.json()["downloads"]
    download = next(item for item in downloads if item["id"] == download_id)
    assert download["state"] == "downloading"
    assert download["progress"] > 0

    stub.set_status(download_id, progress=100.0, state="completed")
    client._loop.run_until_complete(client.app.state.sync_worker.refresh_downloads())

    response = client.get("/soulseek/downloads")
    downloads = response.json()["downloads"]
    download = next(item for item in downloads if item["id"] == download_id)
    assert download["state"] == "completed"
    assert download["progress"] == 100.0


def test_soulseek_download_cancellation(client: SimpleTestClient) -> None:
    download_payload = {
        "username": "tester",
        "files": [{"filename": "song.mp3", "size": 123}],
    }
    response = client.post("/soulseek/download", json=download_payload)
    assert response.status_code == 200
    download_id = response.json()["detail"]["downloads"][0]["id"]

    response = client.delete(f"/soulseek/download/{download_id}")
    assert response.status_code == 200
    assert response.json()["cancelled"] is True

    response = client.get("/soulseek/downloads")
    downloads = response.json()["downloads"]
    download = next(item for item in downloads if item["id"] == download_id)
    assert download["state"] == "failed"

    response = client.delete("/soulseek/download/1")
    assert response.status_code == 200
    assert response.json()["cancelled"] is True


def test_soulseek_download_management_endpoints(client: SimpleTestClient) -> None:
    payload = {
        "username": "tester",
        "files": [{"filename": "song.mp3", "size": 123}],
    }
    response = client.post("/soulseek/download", json=payload)
    assert response.status_code == 200
    download_id = response.json()["detail"]["downloads"][0]["id"]

    stub = client.app.state.soulseek_stub
    stub.queue_positions[download_id] = {"position": 3}
    stub.set_status(download_id, state="completed", progress=100.0)

    detail = client.get(f"/soulseek/download/{download_id}")
    assert detail.status_code == 200
    assert detail.json()["id"] == download_id

    queue = client.get(f"/soulseek/download/{download_id}/queue")
    assert queue.status_code == 200
    assert queue.json()["position"] == 3

    all_downloads = client.get("/soulseek/downloads/all")
    assert all_downloads.status_code == 200
    downloads = all_downloads.json()["downloads"]
    assert any(item["id"] == download_id for item in downloads)

    removed = client.delete("/soulseek/downloads/completed")
    assert removed.status_code == 200
    assert removed.json()["removed"] >= 1

    queue_after = client.get(f"/soulseek/download/{download_id}/queue")
    assert queue_after.status_code == 200


def test_soulseek_enqueue_endpoint(client: SimpleTestClient) -> None:
    payload = {
        "username": "tester",
        "files": [{"filename": "other.mp3", "size": 321}],
    }
    response = client.post("/soulseek/enqueue", json=payload)
    assert response.status_code == 200
    body = response.json()
    assert body["status"] == "enqueued"
    assert body["job"]["files"][0]["filename"] == "other.mp3"


def test_soulseek_upload_endpoints(client: SimpleTestClient) -> None:
    stub = client.app.state.soulseek_stub
    uploads = client.get("/soulseek/uploads")
    assert uploads.status_code == 200
    assert len(uploads.json()["uploads"]) == 1

    all_uploads = client.get("/soulseek/uploads/all")
    assert all_uploads.status_code == 200
    assert len(all_uploads.json()["uploads"]) == 2

    detail = client.get("/soulseek/upload/up-1")
    assert detail.status_code == 200
    assert detail.json()["id"] == "up-1"

    cancel = client.delete("/soulseek/upload/up-1")
    assert cancel.status_code == 200
    assert cancel.json()["cancelled"] == "up-1"

    removed = client.delete("/soulseek/uploads/completed")
    assert removed.status_code == 200
    assert removed.json()["removed"] >= 1

    assert stub.uploads["up-1"]["state"] == "cancelled"


def test_soulseek_user_endpoints(client: SimpleTestClient) -> None:
    address = client.get("/soulseek/user/tester/address")
    assert address.status_code == 200
    assert address.json()["host"] == "127.0.0.1"

    browse = client.get("/soulseek/user/tester/browse")
    assert browse.status_code == 200
    assert browse.json()["files"] == ["song.mp3"]

    status = client.get("/soulseek/user/tester/browsing_status")
    assert status.status_code == 200
    assert status.json()["state"] == "idle"

    directory = client.get("/soulseek/user/tester/directory", params={"path": "/music"})
    assert directory.status_code == 200
    assert directory.json()["path"] == "/music"

    info = client.get("/soulseek/user/tester/info")
    assert info.status_code == 200
    assert info.json()["username"] == "tester"

    user_status = client.get("/soulseek/user/tester/status")
    assert user_status.status_code == 200
    assert user_status.json()["online"] is True

===== tests/test_spotify.py =====
from __future__ import annotations

from tests.simple_client import SimpleTestClient

from app.db import session_scope
from app.models import Playlist
from app.workers.playlist_sync_worker import PlaylistSyncWorker


def test_playlist_sync_worker_persists_playlists(client: SimpleTestClient) -> None:
    stub = client.app.state.spotify_stub
    stub.playlists = [
        {"id": "playlist-1", "name": "Focus", "tracks": {"total": 12}},
        {"id": "playlist-2", "name": "Relax", "track_count": 8},
    ]

    worker = PlaylistSyncWorker(stub, interval_seconds=0.1)
    client._loop.run_until_complete(worker.sync_once())

    with session_scope() as session:
        records = session.query(Playlist).all()
        assert len(records) == 2

    response = client.get("/spotify/playlists")
    assert response.status_code == 200
    playlists = response.json()["playlists"]
    assert {entry["id"] for entry in playlists} == {"playlist-1", "playlist-2"}
    first = next(item for item in playlists if item["id"] == "playlist-1")
    assert first["track_count"] == 12

    stub.playlists = [
        {"id": "playlist-1", "name": "Focus Updated", "tracks": {"total": 15}},
    ]
    client._loop.run_until_complete(worker.sync_once())

    response = client.get("/spotify/playlists")
    assert response.status_code == 200
    playlists = response.json()["playlists"]
    assert len(playlists) == 2
    updated = next(item for item in playlists if item["id"] == "playlist-1")
    assert updated["name"] == "Focus Updated"
    assert updated["track_count"] == 15
    assert playlists[0]["id"] == "playlist-1"


def test_audio_features_endpoints(client: SimpleTestClient) -> None:
    stub = client.app.state.spotify_stub
    stub.audio_features["track-2"] = {"id": "track-2", "danceability": 0.7}

    single = client.get("/spotify/audio-features/track-1")
    assert single.status_code == 200
    assert single.json()["audio_features"]["id"] == "track-1"

    multiple = client.get("/spotify/audio-features", params={"ids": "track-1,track-2"})
    assert multiple.status_code == 200
    features = multiple.json()["audio_features"]
    assert isinstance(features, list)
    assert {item["id"] for item in features} == {"track-1", "track-2"}


def test_playlist_items_endpoint(client: SimpleTestClient) -> None:
    stub = client.app.state.spotify_stub
    stub.playlist_items["playlist-42"] = {
        "items": [{"track": {"id": "track-1"}}, {"track": {"id": "track-2"}}],
        "total": 2,
    }

    response = client.get("/spotify/playlists/playlist-42/tracks")
    assert response.status_code == 200
    body = response.json()
    assert body["total"] == 2
    assert len(body["items"]) == 2


def test_save_and_remove_tracks(client: SimpleTestClient) -> None:
    stub = client.app.state.spotify_stub

    save_response = client.put("/spotify/me/tracks", json={"ids": ["track-1", "track-2"]})
    assert save_response.status_code == 200
    assert stub.saved_track_ids == {"track-1", "track-2"}

    saved = client.get("/spotify/me/tracks")
    assert saved.status_code == 200
    data = saved.json()
    assert data["total"] == 2

    remove_response = client.delete("/spotify/me/tracks", json={"ids": ["track-1"]})
    assert remove_response.status_code == 200
    assert stub.saved_track_ids == {"track-2"}


def test_recommendations_endpoint(client: SimpleTestClient) -> None:
    stub = client.app.state.spotify_stub
    stub.recommendation_payload = {
        "tracks": [{"id": "track-3"}],
        "seeds": [{"type": "track", "id": "track-1"}],
    }

    response = client.get(
        "/spotify/recommendations",
        params={"seed_tracks": "track-1", "limit": 1},
    )
    assert response.status_code == 200
    body = response.json()
    assert body["tracks"] == [{"id": "track-3"}]
    assert body["seeds"] == [{"type": "track", "id": "track-1"}]

===== BACKUP =====
===== .github/workflows/autopush.yml =====
name: CI

on:
  push:
    branches: [ main ]
  pull_request:

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
      - name: Run tests
        run: pytest

===== .gitignore =====
__pycache__/
*.pyc
harmony.db

===== .pytest_cache/.gitignore =====
# Created by pytest automatically.
*

===== .pytest_cache/CACHEDIR.TAG =====
Signature: 8a477f597d28d172789f06886806bc55
# This file is a cache directory tag created by pytest.
# For information about cache directory tags, see:
#	https://bford.info/cachedir/spec.html

===== .pytest_cache/README.md =====
# pytest cache directory #

This directory contains data from the pytest's cache plugin,
which provides the `--lf` and `--ff` options, as well as the `cache` fixture.

**Do not** commit this to version control.

See [the docs](https://docs.pytest.org/en/stable/how-to/cache.html) for more information.

===== .pytest_cache/v/cache/nodeids =====
[
  "tests/test_beets.py::TestAvailability::test_available",
  "tests/test_beets.py::TestAvailability::test_not_available",
  "tests/test_beets.py::TestEnvironment::test_env_passed",
  "tests/test_beets.py::TestFields::test_failure",
  "tests/test_beets.py::TestFields::test_fields",
  "tests/test_beets.py::TestFields::test_timeout",
  "tests/test_beets.py::TestImportFile::test_called_process_error",
  "tests/test_beets.py::TestImportFile::test_options",
  "tests/test_beets.py::TestImportFile::test_success",
  "tests/test_beets.py::TestImportFile::test_unexpected_error",
  "tests/test_beets.py::TestListAlbums::test_failure",
  "tests/test_beets.py::TestListAlbums::test_success",
  "tests/test_beets.py::TestListTracks::test_failure",
  "tests/test_beets.py::TestListTracks::test_success",
  "tests/test_beets.py::TestMove::test_failure",
  "tests/test_beets.py::TestMove::test_timeout",
  "tests/test_beets.py::TestMove::test_with_query",
  "tests/test_beets.py::TestMove::test_without_query",
  "tests/test_beets.py::TestQuery::test_failure",
  "tests/test_beets.py::TestQuery::test_invalid_query",
  "tests/test_beets.py::TestQuery::test_query",
  "tests/test_beets.py::TestQuery::test_timeout",
  "tests/test_beets.py::TestRemove::test_empty_query",
  "tests/test_beets.py::TestRemove::test_failure",
  "tests/test_beets.py::TestRemove::test_force",
  "tests/test_beets.py::TestRemove::test_success",
  "tests/test_beets.py::TestRemove::test_timeout",
  "tests/test_beets.py::TestRouterFields::test_fields",
  "tests/test_beets.py::TestRouterImport::test_import_options",
  "tests/test_beets.py::TestRouterMove::test_move_client_error",
  "tests/test_beets.py::TestRouterMove::test_move_with_query",
  "tests/test_beets.py::TestRouterMove::test_move_without_query",
  "tests/test_beets.py::TestRouterQuery::test_query",
  "tests/test_beets.py::TestRouterQuery::test_query_invalid",
  "tests/test_beets.py::TestRouterRemove::test_remove",
  "tests/test_beets.py::TestRouterRemove::test_remove_empty_query",
  "tests/test_beets.py::TestRouterRemove::test_remove_invalid_query",
  "tests/test_beets.py::TestRouterWrite::test_write_with_query",
  "tests/test_beets.py::TestRouterWrite::test_write_without_query",
  "tests/test_beets.py::TestStats::test_failure",
  "tests/test_beets.py::TestStats::test_success",
  "tests/test_beets.py::TestStats::test_timeout",
  "tests/test_beets.py::TestUpdate::test_failure",
  "tests/test_beets.py::TestUpdate::test_success",
  "tests/test_beets.py::TestUpdate::test_with_path",
  "tests/test_beets.py::TestWrite::test_failure",
  "tests/test_beets.py::TestWrite::test_timeout",
  "tests/test_beets.py::TestWrite::test_with_query",
  "tests/test_beets.py::TestWrite::test_without_query",
  "tests/test_matching.py::test_album_matching_engine",
  "tests/test_matching.py::test_match_confidence",
  "tests/test_matching.py::test_matching_api_album",
  "tests/test_matching.py::test_matching_api_plex",
  "tests/test_matching.py::test_matching_api_soulseek",
  "tests/test_plex.py::test_devices_and_livetv",
  "tests/test_plex.py::test_library_endpoints",
  "tests/test_plex.py::test_notifications",
  "tests/test_plex.py::test_playlists_and_playqueue",
  "tests/test_plex.py::test_plex_status",
  "tests/test_plex.py::test_rating_and_tags",
  "tests/test_plex.py::test_scan_worker_updates_status",
  "tests/test_plex.py::test_session_endpoints",
  "tests/test_plex.py::test_timeline_and_scrobble",
  "tests/test_settings.py::test_settings_history_tracking",
  "tests/test_soulseek.py::test_soulseek_download_cancellation",
  "tests/test_soulseek.py::test_soulseek_download_flow",
  "tests/test_soulseek.py::test_soulseek_download_management_endpoints",
  "tests/test_soulseek.py::test_soulseek_enqueue_endpoint",
  "tests/test_soulseek.py::test_soulseek_search",
  "tests/test_soulseek.py::test_soulseek_status",
  "tests/test_soulseek.py::test_soulseek_upload_endpoints",
  "tests/test_soulseek.py::test_soulseek_user_endpoints",
  "tests/test_spotify.py::test_audio_features_endpoints",
  "tests/test_spotify.py::test_playlist_items_endpoint",
  "tests/test_spotify.py::test_playlist_sync_worker_persists_playlists",
  "tests/test_spotify.py::test_recommendations_endpoint",
  "tests/test_spotify.py::test_save_and_remove_tracks"
]
===== CHANGELOG.md =====
# Changelog

Alle nennenswerten Änderungen dieses Projekts werden in dieser Datei dokumentiert.

## v1.4.0 – Spotify API Vollintegration
- Vollständige Spotify-Integration inkl. Playlist-Sync, Audio-Features, Recommendations und Benutzerbibliothek.
- Erweiterter Spotify-Router mit neuen Endpunkten für Playlists (Add/Remove/Reorder), Profil, Top-Tracks/-Artists.
- PlaylistSyncWorker synchronisiert persistierte Playlists regelmäßig in die Datenbank.

## v1.3.0 – Persistente Playlists
- Neuer Playlist-Sync-Prozess speichert Playlists persistent und liefert Änderungszeitpunkte.
- `/spotify/playlists` gibt Track-Anzahl und Timestamps aus der Datenbank zurück.

## v1.2.0 – Soulseek Downloadstatus
- Soulseek-Downloads werden mit Fortschritt und Zeitstempeln in SQLite abgelegt.
- API liefert Statusabfragen inklusive Fortschritt; Downloads können abgebrochen werden.
- Hintergrund-SyncWorker pollt slskd und aktualisiert persistierte Einträge.

## v1.1.0 – Beets-Integration
- Beets CLI via `BeetsClient` angebunden (Import, Update, Remove, Move, Write, Query, Stats).
- Dockerfiles und Compose-Setup für konsistenten Start angepasst.

## v1.0.0 – Initiale Version
- FastAPI-Anwendung mit Spotify-, Plex- und Soulseek-Routern.
- SQLite + SQLAlchemy für Persistenz, inklusive Testabdeckung mittels Pytest.

===== CHANGES_REVIEW.md =====
# Code Review Zusammenfassung

## Router & API
- Alle Router binden nun konsistente JSON-Schemata ein und liefern eindeutige HTTP-Fehlercodes.
- Plex- und Soulseek-Router verwenden strukturierte Antwortmodelle und protokollieren API-Ausfälle.
- Matching-Router persistiert Ergebnisse transaktionssicher und gibt bei Datenbankfehlern klare Fehlermeldungen aus.
- Soulseek-Downloads lassen sich inklusive Fortschritt abrufen; Abbrüche markieren Einträge als `failed`.

## Datenbank & Worker
- `session_scope()` wird in allen Workern eingesetzt, um atomare Transaktionen und Rollbacks sicherzustellen.
- Verbesserte Logging-Ausgaben erleichtern das Debugging fehlgeschlagener Hintergrundjobs.
- `downloads`-Tabelle enthält Status, Fortschritt und Aktualisierungszeitpunkt; Sync-Worker pollt Soulseek für Updates.

## Dokumentation
- README um Neuerungen in v1.2.0 ergänzt.
- CHANGELOG auf Version 1.2.0 aktualisiert.
- Dokumentation und Changelog beschreiben den Soulseek-Download-Fortschritt.

===== Dockerfile =====
FROM python:3.11-slim

ENV PYTHONUNBUFFERED=1 \
    POETRY_VIRTUALENVS_CREATE=false \
    PIP_NO_CACHE_DIR=1

WORKDIR /app

COPY requirements.txt ./
RUN pip install --upgrade pip && pip install -r requirements.txt

COPY . .

EXPOSE 8000

# Standard: Production
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]

===== README.md =====
# Harmony Backend

Harmony ist ein FastAPI-Backend, das Spotify, Plex, Soulseek (slskd), Beets sowie eine eigene Matching-Engine und Hintergrund-Worker
zu einem gemeinsamen Musik-Hub kombiniert. Die Anwendung bündelt Bibliotheken, Downloads und Metadaten, synchronisiert sie zyklisch
und stellt einheitliche JSON-APIs für Automatisierungen und Frontend-Clients bereit.

## Features

- **Vollständige Spotify-Integration** für Suche, Playlists, Audio-Features, Empfehlungen und Benutzerbibliotheken.
- **Async Plex-Client** mit Zugriff auf Bibliotheken, Sessions, PlayQueues, Live-TV und Echtzeit-Benachrichtigungen.
- **Soulseek-Anbindung** inklusive Download-/Upload-Verwaltung, Warteschlangen und Benutzerinformationen.
- **Beets CLI Bridge** zum Importieren, Aktualisieren, Verschieben und Abfragen der lokalen Musikbibliothek.
- **Matching-Engine** zur Ermittlung der besten Kandidaten zwischen Spotify ↔ Plex/Soulseek inklusive Persistierung.
- **SQLite-Datenbank** mit SQLAlchemy-Modellen für Playlists, Downloads, Matches und Settings.
- **Hintergrund-Worker** für Soulseek-Synchronisation, Matching-Queue, Plex-Scans und Spotify-Playlist-Sync.
- **Docker & GitHub Actions** für reproduzierbare Builds, Tests und Continuous Integration.

## Architekturüberblick

Harmony folgt einer klar getrennten Schichten-Architektur:

- **Core**: Enthält API-Clients (`spotify_client.py`, `plex_client.py`, `soulseek_client.py`, `beets_client.py`) und die Matching-Engine.
- **Routers**: FastAPI-Router kapseln die öffentlich erreichbaren Endpunkte (Spotify, Plex, Soulseek, Matching, Settings, Beets).
- **Workers**: Asynchrone Tasks synchronisieren Playlists, Soulseek-Downloads, Plex-Statistiken und Matching-Jobs.
- **Datenbank-Layer**: `app/db.py`, SQLAlchemy-Modelle und -Schemas verwalten persistente Zustände.

Eine ausführliche Beschreibung der Komponenten findest du in [`docs/architecture.md`](docs/architecture.md).

## Setup-Anleitung

### Voraussetzungen

- Python 3.11
- SQLite (im Lieferumfang enthalten)
- Optional: Docker und Docker Compose

### Lokales Setup

```bash
python -m venv .venv
source .venv/bin/activate
pip install --upgrade pip
pip install -r requirements.txt
uvicorn app.main:app --reload
```

Konfiguriere erforderliche Umgebungsvariablen (siehe Tabelle unten), bevor du den Server startest.

### Docker

```bash
docker build -t harmony-backend .
docker run --env-file .env -p 8000:8000 harmony-backend
```

### Docker Compose

```bash
docker compose up --build
```

Das Dev-Override (`docker-compose.override.yml`) aktiviert Hot-Reloading und Debug-Logging.

### GitHub Actions

Der Workflow [`.github/workflows/autopush.yml`](.github/workflows/autopush.yml) führt bei jedem Push auf `main` sowie bei Pull
Requests die Test-Suite (`pytest`) unter Python 3.11 aus.

## Konfiguration

| Variable | Beschreibung |
| --- | --- |
| `SPOTIFY_CLIENT_ID` | Spotify OAuth Client ID |
| `SPOTIFY_CLIENT_SECRET` | Spotify OAuth Client Secret |
| `SPOTIFY_REDIRECT_URI` | Redirect URI für den OAuth-Flow |
| `SPOTIFY_SCOPE` | Optionaler Scope für Spotify Berechtigungen |
| `PLEX_BASE_URL` | Basis-URL des Plex-Servers |
| `PLEX_TOKEN` | Plex Auth Token |
| `PLEX_LIBRARY` | Name der Plex-Musikbibliothek |
| `SLSKD_URL` | Basis-URL des Soulseek-Daemons |
| `SLSKD_API_KEY` | API-Key für slskd (falls gesetzt) |
| `DATABASE_URL` | SQLAlchemy Verbindungsstring (Standard: `sqlite:///./harmony.db`) |
| `HARMONY_LOG_LEVEL` | Log-Level (`INFO`, `DEBUG`, …) |
| `HARMONY_DISABLE_WORKERS` | `1` deaktiviert alle Hintergrund-Worker (z. B. für Tests) |

## API-Endpoints

Eine vollständige Referenz der FastAPI-Routen befindet sich in [`docs/api.md`](docs/api.md). Die wichtigsten Gruppen im Überblick:

- **Spotify** (`/spotify`): Status, Suche, Track-Details, Audio-Features, Benutzerbibliothek, Playlists, Empfehlungen.
- **Plex** (`/plex`): Status & Statistiken, Bibliotheken, PlayQueues, Playlists, Timeline, Bewertungen, Benachrichtigungen.
- **Soulseek** (`/soulseek`): Status, Suche, Downloads/Uploads, Warteschlangen, Benutzerverzeichnisse und -infos.
- **Matching** (`/matching`): Spotify→Plex, Spotify→Soulseek sowie Album-Matching.
- **Settings** (`/settings`): Key-Value Einstellungen inkl. History.
- **Beets** (`/beets`): Import, Update, Query, Stats und Dateimanipulation via CLI.

## Tests & CI

```bash
pytest
```

Die Tests mocken externe Dienste und können lokal wie auch via GitHub Actions ausgeführt werden. Für deterministische
Runs sollten die Worker mit `HARMONY_DISABLE_WORKERS=1` deaktiviert werden.

## Lizenz

Das Projekt steht derzeit ohne explizite Lizenzdatei zur Verfügung. Ohne eine veröffentlichte Lizenz gelten sämtliche Rechte
als vorbehalten.

===== ToDo.md =====
# ToDo

- ✅ Backend-Struktur mit FastAPI, SQLAlchemy und SQLite aufbauen
- ✅ Core-Clients für Spotify, Plex und Soulseek implementieren
- ✅ Matching-Engine integrieren
- ✅ Tests mit Pytest erstellen
- ✅ Docker- und CI-Konfiguration hinzufügen
- ⬜️ Erweiterte Frontend-Integration

===== app/__init__.py =====

===== app/config.py =====
"""Application configuration utilities for Harmony."""
from __future__ import annotations

import os
from dataclasses import dataclass
from typing import Optional


@dataclass(slots=True)
class SpotifyConfig:
    client_id: Optional[str]
    client_secret: Optional[str]
    redirect_uri: Optional[str]
    scope: str


@dataclass(slots=True)
class PlexConfig:
    base_url: Optional[str]
    token: Optional[str]
    library_name: Optional[str]


@dataclass(slots=True)
class SoulseekConfig:
    base_url: str
    api_key: Optional[str]


@dataclass(slots=True)
class LoggingConfig:
    level: str


@dataclass(slots=True)
class DatabaseConfig:
    url: str


@dataclass(slots=True)
class AppConfig:
    spotify: SpotifyConfig
    plex: PlexConfig
    soulseek: SoulseekConfig
    logging: LoggingConfig
    database: DatabaseConfig


DEFAULT_DB_URL = "sqlite:///./harmony.db"
DEFAULT_SOULSEEK_URL = "http://localhost:5030"
DEFAULT_SPOTIFY_SCOPE = (
    "user-library-read playlist-read-private playlist-read-collaborative"
)


def load_config() -> AppConfig:
    """Load application configuration from environment variables."""

    spotify = SpotifyConfig(
        client_id=os.getenv("SPOTIFY_CLIENT_ID"),
        client_secret=os.getenv("SPOTIFY_CLIENT_SECRET"),
        redirect_uri=os.getenv("SPOTIFY_REDIRECT_URI"),
        scope=os.getenv("SPOTIFY_SCOPE", DEFAULT_SPOTIFY_SCOPE),
    )

    plex = PlexConfig(
        base_url=os.getenv("PLEX_BASE_URL") or os.getenv("PLEX_URL"),
        token=os.getenv("PLEX_TOKEN"),
        library_name=os.getenv("PLEX_LIBRARY"),
    )

    soulseek = SoulseekConfig(
        base_url=os.getenv("SLSKD_URL", DEFAULT_SOULSEEK_URL),
        api_key=os.getenv("SLSKD_API_KEY"),
    )

    logging = LoggingConfig(level=os.getenv("HARMONY_LOG_LEVEL", "INFO"))
    database = DatabaseConfig(url=os.getenv("DATABASE_URL", DEFAULT_DB_URL))

    return AppConfig(
        spotify=spotify,
        plex=plex,
        soulseek=soulseek,
        logging=logging,
        database=database,
    )

===== app/core/__init__.py =====

===== app/core/beets_client.py =====
from __future__ import annotations

from pathlib import Path
from typing import Mapping, Sequence
import os
import shlex
import subprocess
import re

from app.utils.logging_config import get_logger


class BeetsClientError(RuntimeError):
    """Raised when execution of a beets command fails."""


logger = get_logger("beets_client")


class BeetsClient:
    """Thin wrapper around the :mod:`beets` CLI."""

    def __init__(
        self,
        env: Mapping[str, str] | None = None,
        timeout: float = 60.0,
    ) -> None:
        self._env = {**os.environ, **env} if env else None
        self._timeout = timeout

    def _run(self, args: Sequence[str]) -> subprocess.CompletedProcess[str]:
        """Execute *args* with the ``beet`` CLI and return the process result."""

        command = " ".join(args)
        logger.info("Executing beets command: %s", command)

        try:
            run_kwargs = dict(capture_output=True, text=True, check=True)
            if self._env is not None:
                run_kwargs["env"] = self._env
            result = subprocess.run(list(args), timeout=self._timeout, **run_kwargs)
        except subprocess.TimeoutExpired as exc:
            logger.error("Beets command timed out: %s", command)
            raise BeetsClientError("Command timed out") from exc
        except subprocess.CalledProcessError as exc:
            stderr = (exc.stderr or "").strip()
            if stderr:
                logger.error("Beets command failed (%s): %s", command, stderr)
            else:
                logger.error("Beets command failed (%s)", command)
            raise BeetsClientError(stderr or f"Command '{command}' failed") from exc
        except Exception as exc:  # pragma: no cover - defensive
            logger.exception("Unexpected error while executing '%s'", command)
            raise BeetsClientError(f"Unexpected error running '{command}'") from exc

        stdout = (result.stdout or "").strip()
        if stdout:
            logger.info("Beets command output: %s", stdout)

        return result

    def import_file(
        self, path: str | Path, quiet: bool = True, autotag: bool = True
    ) -> str:
        """Import *path* into the beets library using ``beet import``."""

        args: list[str] = ["beet", "import"]
        if quiet:
            args.append("-q")
        if not autotag:
            args.append("-A")
        args.append(str(path))

        result = self._run(args)
        return (result.stdout or "").strip()

    def update(self, path: str | Path | None = None) -> str:
        """Run ``beet update`` optionally scoped to *path*."""

        args: list[str] = ["beet", "update"]
        if path is not None:
            args.append(str(path))

        result = self._run(args)
        return (result.stdout or "").strip()

    def list_albums(self) -> list[str]:
        """Return a list of album names from ``beet ls -a``."""

        result = self._run(["beet", "ls", "-a"])
        stdout = result.stdout or ""
        albums = [line for line in stdout.splitlines() if line.strip()]
        logger.debug("Parsed albums: %s", albums)
        return albums

    def list_tracks(self) -> list[str]:
        """Return a list of track titles from ``beet ls -f '$title'``."""

        result = self._run(["beet", "ls", "-f", "$title"])
        stdout = result.stdout or ""
        tracks = [line for line in stdout.splitlines() if line.strip()]
        logger.debug("Parsed tracks: %s", tracks)
        return tracks

    def stats(self) -> dict[str, str]:
        """Return parsed key/value pairs from ``beet stats``."""

        result = self._run(["beet", "stats"])
        stdout = result.stdout or ""
        stats: dict[str, str] = {}
        for line in stdout.splitlines():
            if ":" not in line:
                continue
            key, value = line.split(":", 1)
            key = key.strip()
            value = value.strip()
            if key:
                stats[key] = value
        logger.debug("Parsed stats: %s", stats)
        return stats

    def is_available(self) -> bool:
        """Return ``True`` when the ``beet`` CLI is reachable."""

        try:
            self._run(["beet", "version"])
        except BeetsClientError:
            return False
        return True

    def remove(self, query: str, force: bool = False) -> dict[str, object]:
        """Remove items matching *query* using ``beet remove``."""

        query_args = self._parse_query(query)
        args: list[str] = ["beet", "remove"]
        if force:
            args.append("-f")
        args.extend(query_args)

        result = self._run(args)
        parsed = self._parse_count_output(result.stdout, "Removed", "removed")
        logger.debug("Parsed remove output: %s", parsed)
        return parsed

    def move(self, query: str | None = None) -> dict[str, object]:
        """Move items in the library using ``beet move`` with an optional query."""

        args: list[str] = ["beet", "move"]
        if query:
            args.extend(self._parse_query(query))

        result = self._run(args)
        parsed = self._parse_count_output(result.stdout, "Moved", "moved")
        logger.debug("Parsed move output: %s", parsed)
        return parsed

    def write(self, query: str | None = None) -> dict[str, object]:
        """Write tags for items using ``beet write`` with an optional query."""

        args: list[str] = ["beet", "write"]
        if query:
            args.extend(self._parse_query(query))

        result = self._run(args)
        parsed = self._parse_count_output(result.stdout, "Wrote", "written")
        logger.debug("Parsed write output: %s", parsed)
        return parsed

    def fields(self) -> list[str]:
        """Return the list of available fields from ``beet fields``."""

        result = self._run(["beet", "fields"])
        stdout = result.stdout or ""
        fields = [line for line in stdout.splitlines() if line.strip()]
        logger.debug("Parsed fields: %s", fields)
        return fields

    def query(
        self, query: str, fmt: str = "$artist - $album - $title"
    ) -> list[str]:
        """Return formatted items for *query* via ``beet ls``."""

        query_args = self._parse_query(query)
        args: list[str] = ["beet", "ls", "-f", fmt]
        args.extend(query_args)

        result = self._run(args)
        stdout = result.stdout or ""
        results = [line for line in stdout.splitlines() if line.strip()]
        logger.debug("Parsed query results: %s", results)
        return results

    @staticmethod
    def _parse_query(query: str) -> list[str]:
        if not query or not query.strip():
            raise BeetsClientError("Query must not be empty")
        try:
            parts = shlex.split(query)
        except ValueError as exc:  # pragma: no cover - defensive
            raise BeetsClientError(f"Invalid query syntax: {exc}") from exc
        return parts

    @staticmethod
    def _parse_count_output(
        stdout: str | None, verb: str, key: str
    ) -> dict[str, object]:
        output = (stdout or "").strip()
        pattern = rf"{verb} (\d+) items"
        match = re.search(pattern, output)
        if match:
            count = int(match.group(1))
            return {"success": True, key: count}
        return {"success": True, "output": output}

===== app/core/matching_engine.py =====
"""Music matching logic used by Harmony."""
from __future__ import annotations

import re
import unicodedata
from difflib import SequenceMatcher
from typing import Dict, Iterable, Optional, Tuple


class MusicMatchingEngine:
    """Provides fuzzy matching utilities across Spotify, Plex and Soulseek."""

    def _normalize(self, value: Optional[str]) -> str:
        if not value:
            return ""
        normalized = unicodedata.normalize("NFKD", value)
        normalized = normalized.encode("ascii", "ignore").decode("ascii")
        normalized = re.sub(r"[^a-z0-9]+", " ", normalized.lower())
        return normalized.strip()

    def _ratio(self, a: Optional[str], b: Optional[str]) -> float:
        na, nb = self._normalize(a), self._normalize(b)
        if not na or not nb:
            return 0.0
        return SequenceMatcher(None, na, nb).ratio()

    def calculate_match_confidence(self, spotify_track: Dict[str, str], plex_track: Dict[str, str]) -> float:
        title_score = self._ratio(spotify_track.get("name"), plex_track.get("title"))
        artist_score = self._ratio(
            (spotify_track.get("artists") or [{}])[0].get("name") if isinstance(spotify_track.get("artists"), list) else spotify_track.get("artist"),
            plex_track.get("artist") or plex_track.get("grandparentTitle"),
        )
        album_score = self._ratio(
            (spotify_track.get("album") or {}).get("name") if isinstance(spotify_track.get("album"), dict) else spotify_track.get("album"),
            plex_track.get("album") or plex_track.get("parentTitle"),
        )
        duration_spotify = spotify_track.get("duration_ms")
        duration_plex = plex_track.get("duration")
        duration_score = 0.0
        if duration_spotify and duration_plex:
            duration_score = 1.0 - min(abs(duration_spotify - duration_plex) / max(duration_spotify, duration_plex), 1)

        return round((title_score * 0.5) + (artist_score * 0.3) + (album_score * 0.15) + (duration_score * 0.05), 4)

    def find_best_match(
        self, spotify_track: Dict[str, str], plex_candidates: Iterable[Dict[str, str]]
    ) -> Tuple[Optional[Dict[str, str]], float]:
        best_match: Optional[Dict[str, str]] = None
        best_score = 0.0
        for candidate in plex_candidates:
            score = self.calculate_match_confidence(spotify_track, candidate)
            if score > best_score:
                best_score = score
                best_match = candidate
        return best_match, best_score

    def calculate_slskd_match_confidence(
        self, spotify_track: Dict[str, str], soulseek_entry: Dict[str, str]
    ) -> float:
        title_score = self._ratio(spotify_track.get("name"), soulseek_entry.get("filename"))
        artist = (
            (spotify_track.get("artists") or [{}])[0].get("name")
            if isinstance(spotify_track.get("artists"), list)
            else spotify_track.get("artist")
        )
        artist_score = self._ratio(artist, soulseek_entry.get("username"))
        bitrate_score = 1.0 if soulseek_entry.get("bitrate", 0) >= 256 else 0.5
        return round((title_score * 0.6) + (artist_score * 0.2) + (bitrate_score * 0.2), 4)

    def _extract_album_artist(self, album: Dict[str, str]) -> Optional[str]:
        artists = album.get("artists")
        if isinstance(artists, list) and artists:
            primary_artist = artists[0]
            if isinstance(primary_artist, dict):
                return primary_artist.get("name")
            return str(primary_artist)
        return album.get("artist") or album.get("grandparentTitle")

    def _album_track_count(self, album: Dict[str, str]) -> Optional[int]:
        for key in ("total_tracks", "trackCount", "leafCount", "childCount", "track_count"):
            value = album.get(key)
            if isinstance(value, int):
                return value
            if isinstance(value, str) and value.isdigit():
                return int(value)
        tracks = album.get("tracks")
        if isinstance(tracks, dict):
            items = tracks.get("items")
            if isinstance(items, list):
                return len(items)
        if isinstance(tracks, list):
            return len(tracks)
        return None

    def _album_year(self, album: Dict[str, str]) -> Optional[int]:
        for key in ("year", "release_year"):
            value = album.get(key)
            if isinstance(value, int):
                return value
            if isinstance(value, str) and value.isdigit():
                return int(value)
        release_date = album.get("release_date")
        if isinstance(release_date, str) and release_date:
            if len(release_date) >= 4 and release_date[:4].isdigit():
                return int(release_date[:4])
        originally_available_at = album.get("originallyAvailableAt")
        if isinstance(originally_available_at, str) and originally_available_at:
            if originally_available_at[:4].isdigit():
                return int(originally_available_at[:4])
        return None

    def calculate_album_confidence(
        self, spotify_album: Dict[str, str], plex_album: Dict[str, str]
    ) -> float:
        """Calculate similarity score between Spotify and Plex albums."""

        name_score = self._ratio(spotify_album.get("name"), plex_album.get("title"))
        spotify_artist = self._extract_album_artist(spotify_album)
        plex_artist = self._extract_album_artist(plex_album) or plex_album.get("parentTitle")
        artist_score = self._ratio(spotify_artist, plex_artist)

        spotify_tracks = self._album_track_count(spotify_album)
        plex_tracks = self._album_track_count(plex_album)
        track_count_score = 0.0
        if spotify_tracks and plex_tracks:
            diff = abs(spotify_tracks - plex_tracks)
            max_count = max(spotify_tracks, plex_tracks)
            track_count_score = 1.0 - min(diff / max_count, 1)

        spotify_year = self._album_year(spotify_album)
        plex_year = self._album_year(plex_album)
        year_score = 0.0
        if spotify_year and plex_year:
            year_score = 1.0 if spotify_year == plex_year else 0.0

        score = (name_score * 0.4) + (artist_score * 0.4) + (track_count_score * 0.1) + (year_score * 0.1)
        return round(score, 4)

    def find_best_album_match(
        self, spotify_album: Dict[str, str], plex_albums: Iterable[Dict[str, str]]
    ) -> Tuple[Optional[Dict[str, str]], float]:
        """Find the highest scoring Plex album for the given Spotify album."""

        best_match: Optional[Dict[str, str]] = None
        best_score = 0.0
        for candidate in plex_albums:
            score = self.calculate_album_confidence(spotify_album, candidate)
            if score > best_score:
                best_score = score
                best_match = candidate
        return best_match, best_score

===== app/core/plex_client.py =====
"""Async Plex client built on top of the public Plex API."""
from __future__ import annotations

import asyncio
from contextlib import asynccontextmanager
from typing import Any, AsyncIterator, Dict, List

import aiohttp

from app.config import PlexConfig
from app.logging import get_logger

logger = get_logger(__name__)


class PlexClientError(RuntimeError):
    """Raised when the Plex API returns an error response."""


class PlexClient:
    """Asynchronous Plex API wrapper.

    The client intentionally exposes only the pieces of the API that are
    required by Harmony.  All HTTP communication is performed with
    :mod:`aiohttp` and a very small retry helper is used to increase
    robustness when Plex temporarily fails to respond.
    """

    _DEFAULT_TIMEOUT = aiohttp.ClientTimeout(total=30)
    _RETRY_ATTEMPTS = 3
    _RETRY_BASE_DELAY = 0.25

    def __init__(self, config: PlexConfig) -> None:
        if not (config.base_url and config.token):
            raise ValueError("Plex configuration is incomplete")
        self._base_url = config.base_url.rstrip("/")
        self._token = config.token
        self._session: aiohttp.ClientSession | None = None
        self._lock = asyncio.Lock()

    async def _ensure_session(self) -> aiohttp.ClientSession:
        async with self._lock:
            if self._session is None or self._session.closed:
                self._session = aiohttp.ClientSession(timeout=self._DEFAULT_TIMEOUT)
        assert self._session is not None
        return self._session

    def _build_url(self, path: str) -> str:
        if not path.startswith("/"):
            path = f"/{path}"
        return f"{self._base_url}{path}"

    def _build_headers(self) -> Dict[str, str]:
        return {"X-Plex-Token": self._token}

    async def _request(
        self,
        method: str,
        path: str,
        *,
        params: Dict[str, Any] | None = None,
        data: Dict[str, Any] | None = None,
        json_body: Dict[str, Any] | None = None,
        expect_json: bool = True,
    ) -> Any:
        url = self._build_url(path)
        attempt = 0
        last_exception: Exception | None = None
        while attempt < self._RETRY_ATTEMPTS:
            attempt += 1
            session = await self._ensure_session()
            try:
                async with session.request(
                    method,
                    url,
                    headers=self._build_headers(),
                    params=params,
                    data=data,
                    json=json_body,
                ) as response:
                    if response.status >= 400:
                        text = await response.text()
                        raise PlexClientError(
                            f"Plex {method} {url} failed with status {response.status}: {text}"
                        )
                    if expect_json:
                        return await response.json(content_type=None)
                    return await response.text()
            except Exception as exc:  # pragma: no cover - defensive logging
                last_exception = exc
                logger.warning(
                    "Plex request error (%s %s attempt %d/%d): %s",
                    method,
                    url,
                    attempt,
                    self._RETRY_ATTEMPTS,
                    exc,
                )
                if attempt >= self._RETRY_ATTEMPTS:
                    break
                await asyncio.sleep(self._RETRY_BASE_DELAY * attempt)
        assert last_exception is not None
        raise last_exception

    async def _get(self, path: str, params: Dict[str, Any] | None = None) -> Any:
        return await self._request("GET", path, params=params)

    async def _post(
        self,
        path: str,
        *,
        params: Dict[str, Any] | None = None,
        data: Dict[str, Any] | None = None,
        json_body: Dict[str, Any] | None = None,
        expect_json: bool = True,
    ) -> Any:
        return await self._request(
            "POST", path, params=params, data=data, json_body=json_body, expect_json=expect_json
        )

    async def _put(
        self,
        path: str,
        *,
        params: Dict[str, Any] | None = None,
        data: Dict[str, Any] | None = None,
        json_body: Dict[str, Any] | None = None,
    ) -> Any:
        return await self._request("PUT", path, params=params, data=data, json_body=json_body)

    async def _delete(self, path: str, params: Dict[str, Any] | None = None) -> Any:
        return await self._request("DELETE", path, params=params)

    async def get_libraries(self, params: Dict[str, Any] | None = None) -> Any:
        """Return all Plex library sections."""

        return await self._get("/library/sections", params=params)

    async def get_library_items(
        self, section_id: str, params: Dict[str, Any] | None = None
    ) -> Any:
        """Return items for a given library section."""

        return await self._get(f"/library/sections/{section_id}/all", params=params)

    async def get_metadata(self, item_id: str) -> Any:
        return await self._get(f"/library/metadata/{item_id}")

    async def get_sessions(self) -> Any:
        return await self._get("/status/sessions")

    async def get_session_history(self, params: Dict[str, Any] | None = None) -> Any:
        return await self._get("/status/sessions/history/all", params=params)

    async def get_timeline(self, params: Dict[str, Any] | None = None) -> Any:
        return await self._get("/:/timeline", params=params)

    async def update_timeline(self, data: Dict[str, Any]) -> Any:
        return await self._post("/:/timeline", data=data, expect_json=False)

    async def scrobble(self, data: Dict[str, Any]) -> Any:
        return await self._post("/:/scrobble", data=data, expect_json=False)

    async def unscrobble(self, data: Dict[str, Any]) -> Any:
        return await self._post("/:/unscrobble", data=data, expect_json=False)

    async def get_playlists(self) -> Any:
        return await self._get("/playlists")

    async def create_playlist(self, payload: Dict[str, Any]) -> Any:
        return await self._post("/playlists", json_body=payload)

    async def update_playlist(self, playlist_id: str, payload: Dict[str, Any]) -> Any:
        return await self._put(f"/playlists/{playlist_id}", json_body=payload)

    async def delete_playlist(self, playlist_id: str) -> Any:
        return await self._delete(f"/playlists/{playlist_id}")

    async def create_playqueue(self, payload: Dict[str, Any]) -> Any:
        return await self._post("/playQueues", json_body=payload)

    async def get_playqueue(self, playqueue_id: str) -> Any:
        return await self._get(f"/playQueues/{playqueue_id}")

    async def rate_item(self, item_id: str, rating: int) -> Any:
        payload = {"key": item_id, "rating": rating}
        return await self._post("/:/rate", data=payload, expect_json=False)

    async def sync_tags(self, item_id: str, tags: Dict[str, List[str]]) -> Any:
        payload = {"key": item_id, **tags}
        return await self._post("/:/settags", json_body=payload)

    async def get_devices(self) -> Any:
        return await self._get("/devices")

    async def get_dvr(self) -> Any:
        return await self._get("/livetv/dvrs")

    async def get_live_tv(self, params: Dict[str, Any] | None = None) -> Any:
        return await self._get("/livetv", params=params)

    async def get_library_statistics(self) -> Dict[str, int]:
        """Compute high level statistics for the Plex music library."""

        stats = {"artists": 0, "albums": 0, "tracks": 0}
        libraries = await self.get_libraries()
        container = libraries.get("MediaContainer", {}) if isinstance(libraries, dict) else {}
        for section in container.get("Directory", []):
            if section.get("type") != "artist":
                continue
            section_id = section.get("key")
            if not section_id:
                continue
            items = await self.get_library_items(section_id, params={"type": "10"})
            section_container = (
                items.get("MediaContainer", {}) if isinstance(items, dict) else {}
            )
            stats["artists"] += int(section_container.get("totalSize", 0))

            albums = await self.get_library_items(section_id, params={"type": "9"})
            album_container = (
                albums.get("MediaContainer", {}) if isinstance(albums, dict) else {}
            )
            stats["albums"] += int(album_container.get("totalSize", 0))

            tracks = await self.get_library_items(section_id, params={"type": "8"})
            track_container = (
                tracks.get("MediaContainer", {}) if isinstance(tracks, dict) else {}
            )
            stats["tracks"] += int(track_container.get("totalSize", 0))
        return stats

    @asynccontextmanager
    async def listen_notifications(self) -> AsyncIterator[aiohttp.ClientWebSocketResponse]:
        """Connect to the Plex websocket notification endpoint."""

        session = await self._ensure_session()
        url = self._build_url("/:/websocket/notifications")
        headers = self._build_headers()
        async with session.ws_connect(url, headers=headers) as websocket:
            yield websocket

    async def close(self) -> None:
        if self._session and not self._session.closed:
            await self._session.close()


===== app/core/soulseek_client.py =====
"""Async client for the slskd REST API."""
from __future__ import annotations

import asyncio
import time
from collections import deque
from typing import Any, Dict, List, Optional

import aiohttp

from app.config import SoulseekConfig
from app.logging import get_logger


logger = get_logger(__name__)


class SoulseekClientError(RuntimeError):
    pass


class SoulseekClient:
    RATE_LIMIT_COUNT = 35
    RATE_LIMIT_WINDOW = 220.0

    def __init__(
        self,
        config: SoulseekConfig,
        session: Optional[aiohttp.ClientSession] = None,
    ) -> None:
        self._config = config
        self._session = session
        self._session_owner = session is None
        self._timestamps: deque[float] = deque(maxlen=self.RATE_LIMIT_COUNT)
        self._lock = asyncio.Lock()
        self._max_retries = 3

    async def _ensure_session(self) -> aiohttp.ClientSession:
        if self._session is None or self._session.closed:
            self._session = aiohttp.ClientSession()
        return self._session

    def _build_url(self, path: str) -> str:
        base = self._config.base_url.rstrip("/")
        return f"{base}/api/v0/{path.lstrip('/')}"

    def _build_headers(self) -> Dict[str, str]:
        headers = {"Content-Type": "application/json"}
        if self._config.api_key:
            headers["X-API-Key"] = self._config.api_key
        return headers

    async def _respect_rate_limit(self) -> None:
        async with self._lock:
            now = time.monotonic()
            while self._timestamps and now - self._timestamps[0] > self.RATE_LIMIT_WINDOW:
                self._timestamps.popleft()
            if len(self._timestamps) >= self.RATE_LIMIT_COUNT:
                wait_time = self.RATE_LIMIT_WINDOW - (now - self._timestamps[0])
                if wait_time > 0:
                    await asyncio.sleep(wait_time)
            self._timestamps.append(time.monotonic())

    async def _request(self, method: str, path: str, **kwargs: Any) -> Any:
        await self._respect_rate_limit()
        session = await self._ensure_session()
        url = self._build_url(path)
        headers = kwargs.pop("headers", {})
        headers = {**self._build_headers(), **headers}

        backoff = 0.5
        for attempt in range(1, self._max_retries + 1):
            try:
                async with session.request(method, url, headers=headers, **kwargs) as response:
                    if response.status >= 400:
                        content = await response.text()
                        raise SoulseekClientError(
                            f"slskd error {response.status}: {content[:200]}"
                        )
                    if "application/json" in response.headers.get("Content-Type", ""):
                        return await response.json()
                    return await response.text()
            except (aiohttp.ClientError, SoulseekClientError) as exc:
                if attempt == self._max_retries:
                    logger.error("Soulseek request failed: %s", exc)
                    raise
                await asyncio.sleep(backoff)
                backoff *= 2

    async def close(self) -> None:
        if self._session_owner and self._session and not self._session.closed:
            await self._session.close()

    async def search(self, query: str) -> Dict[str, Any]:
        payload = {"searchText": query, "filterResponses": True}
        return await self._request("POST", "searches", json=payload)

    async def download(self, payload: Dict[str, Any]) -> Dict[str, Any]:
        username = payload.get("username")
        if not username:
            raise ValueError("username is required for download requests")
        downloads = payload.get("files")
        if not isinstance(downloads, list) or not downloads:
            raise ValueError("files must be a non-empty list")
        return await self._request("POST", f"transfers/downloads/{username}", json=downloads)

    async def get_download_status(self) -> Dict[str, Any]:
        return await self._request("GET", "transfers/downloads")

    async def cancel_download(self, download_id: str) -> Dict[str, Any]:
        return await self._request("DELETE", f"transfers/downloads/{download_id}")

    async def get_download(self, download_id: str) -> Dict[str, Any]:
        return await self._request("GET", f"transfers/downloads/{download_id}")

    async def get_all_downloads(self) -> List[Dict[str, Any]]:
        result = await self._request("GET", "transfers/downloads/all")
        if isinstance(result, list):
            return result
        if isinstance(result, dict) and "downloads" in result:
            payload = result["downloads"]
            return payload if isinstance(payload, list) else [payload]
        return [result]

    async def remove_completed_downloads(self) -> Dict[str, Any]:
        return await self._request("DELETE", "transfers/downloads/completed")

    async def get_queue_position(self, download_id: str) -> Dict[str, Any]:
        return await self._request("GET", f"transfers/downloads/{download_id}/queue")

    async def enqueue(self, username: str, files: List[Dict[str, Any]]) -> Dict[str, Any]:
        if not username:
            raise ValueError("username is required for enqueue requests")
        if not isinstance(files, list) or not files:
            raise ValueError("files must be a non-empty list")
        payload = {"username": username, "files": files}
        return await self._request("POST", "transfers/enqueue", json=payload)

    async def cancel_upload(self, upload_id: str) -> Dict[str, Any]:
        return await self._request("DELETE", f"transfers/uploads/{upload_id}")

    async def get_upload(self, upload_id: str) -> Dict[str, Any]:
        return await self._request("GET", f"transfers/uploads/{upload_id}")

    async def get_uploads(self) -> List[Dict[str, Any]]:
        result = await self._request("GET", "transfers/uploads")
        if isinstance(result, list):
            return result
        if isinstance(result, dict) and "uploads" in result:
            payload = result["uploads"]
            return payload if isinstance(payload, list) else [payload]
        return [result]

    async def get_all_uploads(self) -> List[Dict[str, Any]]:
        result = await self._request("GET", "transfers/uploads/all")
        if isinstance(result, list):
            return result
        if isinstance(result, dict) and "uploads" in result:
            payload = result["uploads"]
            return payload if isinstance(payload, list) else [payload]
        return [result]

    async def remove_completed_uploads(self) -> Dict[str, Any]:
        return await self._request("DELETE", "transfers/uploads/completed")

    async def user_address(self, username: str) -> Dict[str, Any]:
        return await self._request("GET", f"users/{username}/address")

    async def user_browse(self, username: str) -> Dict[str, Any]:
        return await self._request("GET", f"users/{username}/browse")

    async def user_browsing_status(self, username: str) -> Dict[str, Any]:
        return await self._request("GET", f"users/{username}/browsing-status")

    async def user_directory(self, username: str, path: str) -> Dict[str, Any]:
        return await self._request("GET", f"users/{username}/directory", params={"path": path})

    async def user_info(self, username: str) -> Dict[str, Any]:
        return await self._request("GET", f"users/{username}/info")

    async def user_status(self, username: str) -> Dict[str, Any]:
        return await self._request("GET", f"users/{username}/status")

===== app/core/spotify_client.py =====
"""Spotify client wrapper used by Harmony."""
from __future__ import annotations

import threading
import time
from typing import Any, Dict, List, Optional

from app.config import SpotifyConfig
from app.logging import get_logger

try:  # pragma: no cover - import guard
    import spotipy
    from spotipy import Spotify
    from spotipy.oauth2 import SpotifyOAuth
    from spotipy.exceptions import SpotifyException
except Exception:  # pragma: no cover - during tests we mock the client
    spotipy = None
    Spotify = Any  # type: ignore
    SpotifyOAuth = Any  # type: ignore

    class SpotifyException(Exception):  # type: ignore
        http_status: Optional[int] = None


logger = get_logger(__name__)


class SpotifyClient:
    """High level client around Spotipy with rate limiting and retries."""

    def __init__(
        self,
        config: SpotifyConfig,
        client: Optional[Spotify] = None,
        rate_limit_seconds: float = 0.2,
        max_retries: int = 3,
    ) -> None:
        self._config = config
        self._rate_limit_seconds = rate_limit_seconds
        self._max_retries = max_retries
        self._lock = threading.Lock()
        self._last_request_time = 0.0

        if client is not None:
            self._client = client
        else:
            if spotipy is None:
                raise RuntimeError("spotipy is required for SpotifyClient but is not installed")
            if not (config.client_id and config.client_secret and config.redirect_uri):
                raise ValueError("Spotify configuration is incomplete")

            auth_manager = SpotifyOAuth(
                client_id=config.client_id,
                client_secret=config.client_secret,
                redirect_uri=config.redirect_uri,
                scope=config.scope,
            )
            self._client = spotipy.Spotify(auth_manager=auth_manager)

    def _respect_rate_limit(self) -> None:
        with self._lock:
            now = time.monotonic()
            elapsed = now - self._last_request_time
            if elapsed < self._rate_limit_seconds:
                time.sleep(self._rate_limit_seconds - elapsed)
            self._last_request_time = time.monotonic()

    def _execute(self, func, *args, **kwargs):
        backoff = 0.5
        for attempt in range(1, self._max_retries + 1):
            self._respect_rate_limit()
            try:
                return func(*args, **kwargs)
            except SpotifyException as exc:  # pragma: no cover - network errors are mocked in tests
                status = getattr(exc, "http_status", None)
                if status not in {429, 502, 503} or attempt == self._max_retries:
                    logger.error("Spotify API request failed", exc_info=exc)
                    raise
                logger.warning("Retrying Spotify API request due to status %s", status)
                time.sleep(backoff)
                backoff *= 2
            except Exception as exc:  # pragma: no cover
                if attempt == self._max_retries:
                    raise
                logger.warning("Retrying Spotify API request due to %s", exc)
                time.sleep(backoff)
                backoff *= 2

    def is_authenticated(self) -> bool:
        try:
            profile = self._execute(self._client.current_user)
        except Exception:
            return False
        return bool(profile)

    def search_tracks(self, query: str, limit: int = 20) -> Dict[str, Any]:
        return self._execute(self._client.search, q=query, type="track", limit=limit)

    def search_artists(self, query: str, limit: int = 20) -> Dict[str, Any]:
        return self._execute(self._client.search, q=query, type="artist", limit=limit)

    def search_albums(self, query: str, limit: int = 20) -> Dict[str, Any]:
        return self._execute(self._client.search, q=query, type="album", limit=limit)

    def get_user_playlists(self, limit: int = 50) -> Dict[str, Any]:
        return self._execute(self._client.current_user_playlists, limit=limit)

    def get_track_details(self, track_id: str) -> Dict[str, Any]:
        return self._execute(self._client.track, track_id)

    def get_audio_features(self, track_id: str) -> Dict[str, Any]:
        features = self._execute(self._client.audio_features, [track_id]) or []
        return features[0] if features else {}

    def get_multiple_audio_features(self, track_ids: List[str]) -> Dict[str, Any]:
        features = self._execute(self._client.audio_features, track_ids)
        return {"audio_features": features or []}

    def get_playlist_items(self, playlist_id: str, limit: int = 100) -> Dict[str, Any]:
        return self._execute(self._client.playlist_items, playlist_id, limit=limit)

    def add_tracks_to_playlist(self, playlist_id: str, track_uris: List[str]) -> Dict[str, Any]:
        return self._execute(self._client.playlist_add_items, playlist_id, track_uris)

    def remove_tracks_from_playlist(self, playlist_id: str, track_uris: List[str]) -> Dict[str, Any]:
        return self._execute(
            self._client.playlist_remove_all_occurrences_of_items, playlist_id, track_uris
        )

    def reorder_playlist_items(
        self, playlist_id: str, range_start: int, insert_before: int
    ) -> Dict[str, Any]:
        return self._execute(
            self._client.playlist_reorder_items,
            playlist_id,
            range_start=range_start,
            insert_before=insert_before,
        )

    def get_saved_tracks(self, limit: int = 20) -> Dict[str, Any]:
        return self._execute(self._client.current_user_saved_tracks, limit=limit)

    def save_tracks(self, track_ids: List[str]) -> Dict[str, Any]:
        return self._execute(self._client.current_user_saved_tracks_add, track_ids)

    def remove_saved_tracks(self, track_ids: List[str]) -> Dict[str, Any]:
        return self._execute(self._client.current_user_saved_tracks_delete, track_ids)

    def get_current_user(self) -> Dict[str, Any]:
        return self._execute(self._client.current_user)

    def get_top_tracks(self, limit: int = 20) -> Dict[str, Any]:
        return self._execute(self._client.current_user_top_tracks, limit=limit)

    def get_top_artists(self, limit: int = 20) -> Dict[str, Any]:
        return self._execute(self._client.current_user_top_artists, limit=limit)

    def get_recommendations(
        self,
        seed_tracks: Optional[List[str]] = None,
        seed_artists: Optional[List[str]] = None,
        seed_genres: Optional[List[str]] = None,
        limit: int = 20,
    ) -> Dict[str, Any]:
        params: Dict[str, Any] = {"limit": limit}
        if seed_tracks:
            params["seed_tracks"] = seed_tracks
        if seed_artists:
            params["seed_artists"] = seed_artists
        if seed_genres:
            params["seed_genres"] = seed_genres
        return self._execute(self._client.recommendations, **params)

===== app/db.py =====
"""Database configuration and helper utilities."""
from __future__ import annotations

from contextlib import contextmanager
from pathlib import Path
from typing import Iterator, Optional

from sqlalchemy import Engine, create_engine
from sqlalchemy.engine import make_url
from sqlalchemy.orm import DeclarativeBase, Session, sessionmaker

from app.config import load_config


class Base(DeclarativeBase):
    pass


_engine: Optional[Engine] = None
SessionLocal: Optional[sessionmaker[Session]] = None
_configured_database_url: Optional[str] = None
_initializing_db: bool = False


def _build_engine(database_url: str) -> Engine:
    connect_args = {"check_same_thread": False} if database_url.startswith("sqlite") else {}
    return create_engine(database_url, connect_args=connect_args)


def _resolve_sqlite_path(database_url: str) -> Optional[Path]:
    try:
        url = make_url(database_url)
    except Exception:  # pragma: no cover - defensive parsing
        return None

    if url.get_backend_name() != "sqlite":
        return None

    database = url.database or ""
    if database in {":memory:", ""}:
        return None

    return Path(database)


def _ensure_engine(*, auto_init: bool = True) -> None:
    global _engine, SessionLocal, _configured_database_url, _initializing_db

    config = load_config()
    database_url = config.database.url
    sqlite_path = _resolve_sqlite_path(database_url)

    reuse_existing = False
    if _engine is not None and database_url == _configured_database_url:
        if sqlite_path is None or sqlite_path.exists() or not auto_init:
            reuse_existing = True

    if reuse_existing:
        return

    if _engine is not None:
        _engine.dispose()

    _engine = _build_engine(database_url)
    SessionLocal = sessionmaker(
        bind=_engine,
        autoflush=False,
        autocommit=False,
        expire_on_commit=False,
    )
    _configured_database_url = database_url

    if (
        auto_init
        and not _initializing_db
        and sqlite_path is not None
        and not sqlite_path.exists()
    ):
        init_db()


def get_session() -> Session:
    if SessionLocal is None:
        _ensure_engine()
    assert SessionLocal is not None  # For type checkers
    return SessionLocal()


@contextmanager
def session_scope() -> Iterator[Session]:
    session = get_session()
    try:
        yield session
        session.commit()
    except Exception:
        session.rollback()
        raise
    finally:
        session.close()


def init_db() -> None:
    global _initializing_db

    if _initializing_db:
        return

    _initializing_db = True
    try:
        _ensure_engine(auto_init=False)
        assert _engine is not None
        from app import models  # Import models for metadata

        Base.metadata.create_all(bind=_engine)
    finally:
        _initializing_db = False


def reset_engine_for_tests() -> None:
    """Reset the cached engine/session so tests get a clean database handle."""

    global _engine, SessionLocal, _configured_database_url, _initializing_db

    if _engine is not None:
        _engine.dispose()

    _engine = None
    SessionLocal = None
    _configured_database_url = None
    _initializing_db = False


__all__ = [
    "Base",
    "SessionLocal",
    "get_session",
    "session_scope",
    "init_db",
    "reset_engine_for_tests",
    "_engine",
]

===== app/dependencies.py =====
"""FastAPI dependency providers."""
from __future__ import annotations

from functools import lru_cache
from typing import Generator

from sqlalchemy.orm import Session

from app.config import AppConfig, load_config
from app.core.matching_engine import MusicMatchingEngine
from app.core.plex_client import PlexClient
from app.core.soulseek_client import SoulseekClient
from app.core.spotify_client import SpotifyClient
from app.db import get_session


@lru_cache()
def get_app_config() -> AppConfig:
    return load_config()


@lru_cache()
def get_spotify_client() -> SpotifyClient:
    return SpotifyClient(get_app_config().spotify)


@lru_cache()
def get_plex_client() -> PlexClient:
    return PlexClient(get_app_config().plex)


@lru_cache()
def get_soulseek_client() -> SoulseekClient:
    return SoulseekClient(get_app_config().soulseek)


@lru_cache()
def get_matching_engine() -> MusicMatchingEngine:
    return MusicMatchingEngine()


def get_db() -> Generator[Session, None, None]:
    session = get_session()
    try:
        yield session
    finally:
        session.close()

===== app/logging.py =====
"""Logging configuration utilities."""
from __future__ import annotations

import logging
import sys
from typing import Optional


LOG_FORMAT = "%(asctime)s [%(levelname)s] %(name)s: %(message)s"


def configure_logging(level: str = "INFO", log_file: Optional[str] = None) -> None:
    """Configure application wide logging handlers."""
    handlers: list[logging.Handler] = [logging.StreamHandler(sys.stdout)]
    if log_file:
        handlers.append(logging.FileHandler(log_file))

    logging.basicConfig(
        level=getattr(logging, level.upper(), logging.INFO),
        format=LOG_FORMAT,
        handlers=handlers,
        force=True,
    )


def get_logger(name: str) -> logging.Logger:
    return logging.getLogger(name)

===== app/main.py =====
"""Entry point for the Harmony FastAPI application."""
from __future__ import annotations

import os

import inspect

from fastapi import FastAPI

from app.dependencies import (
    get_app_config,
    get_matching_engine,
    get_plex_client,
    get_soulseek_client,
    get_spotify_client,
)
from app.db import init_db
from app.logging import configure_logging, get_logger
from app.routers import matching_router, plex_router, settings_router, soulseek_router, spotify_router
from app.workers import MatchingWorker, PlaylistSyncWorker, ScanWorker, SyncWorker

app = FastAPI(title="Harmony Backend", version="1.4.0")
logger = get_logger(__name__)

app.include_router(spotify_router, prefix="/spotify", tags=["Spotify"])
app.include_router(plex_router, prefix="/plex", tags=["Plex"])
app.include_router(soulseek_router, prefix="/soulseek", tags=["Soulseek"])
app.include_router(matching_router, prefix="/matching", tags=["Matching"])
app.include_router(settings_router, prefix="/settings", tags=["Settings"])


@app.on_event("startup")
async def startup_event() -> None:
    config = get_app_config()
    configure_logging(config.logging.level)
    init_db()
    logger.info("Database initialised")

    if os.getenv("HARMONY_DISABLE_WORKERS") not in {"1", "true", "TRUE"}:
        soulseek_client = get_soulseek_client()
        matching_engine = get_matching_engine()
        plex_client = get_plex_client()
        spotify_client = get_spotify_client()

        app.state.sync_worker = SyncWorker(soulseek_client)
        await app.state.sync_worker.start()

        app.state.matching_worker = MatchingWorker(matching_engine)
        await app.state.matching_worker.start()

        app.state.scan_worker = ScanWorker(plex_client)
        await app.state.scan_worker.start()

        app.state.playlist_worker = PlaylistSyncWorker(spotify_client)
        await app.state.playlist_worker.start()

    logger.info("Harmony application started")


@app.on_event("shutdown")
async def shutdown_event() -> None:
    if worker := getattr(app.state, "sync_worker", None):
        await worker.stop()
    if worker := getattr(app.state, "matching_worker", None):
        await worker.stop()
    if worker := getattr(app.state, "scan_worker", None):
        await worker.stop()
    if worker := getattr(app.state, "playlist_worker", None):
        await worker.stop()
    try:
        plex_client = get_plex_client()
    except ValueError:
        plex_client = None
    close_fn = getattr(plex_client, "close", None)
    if callable(close_fn):
        result = close_fn()
        if inspect.isawaitable(result):
            await result
    logger.info("Harmony application stopped")


@app.get("/")
async def root() -> dict[str, str]:
    return {"status": "ok", "version": app.version}

===== app/models.py =====
"""Database models for Harmony."""
from __future__ import annotations

from datetime import datetime

from sqlalchemy import Column, DateTime, Float, Integer, String, Text

from app.db import Base


class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    username = Column(String(255), unique=True, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)


class Playlist(Base):
    __tablename__ = "playlists"

    id = Column(String(128), primary_key=True)
    name = Column(String(512), nullable=False)
    track_count = Column(Integer, nullable=False, default=0)
    updated_at = Column(
        DateTime,
        default=datetime.utcnow,
        onupdate=datetime.utcnow,
        nullable=False,
    )


class Download(Base):
    __tablename__ = "downloads"

    id = Column(Integer, primary_key=True, index=True)
    filename = Column(String(1024), nullable=False)
    state = Column(String(50), nullable=False, default="queued")
    progress = Column(Float, nullable=False, default=0.0)
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(
        DateTime,
        default=datetime.utcnow,
        onupdate=datetime.utcnow,
        nullable=False,
    )


class Match(Base):
    __tablename__ = "matches"

    id = Column(Integer, primary_key=True, index=True)
    source = Column(String(50), nullable=False)
    spotify_track_id = Column(String(128), index=True, nullable=False)
    target_id = Column(String(128), nullable=True)
    confidence = Column(Float, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)


class Setting(Base):
    __tablename__ = "settings"

    id = Column(Integer, primary_key=True, index=True)
    key = Column(String(255), unique=True, nullable=False)
    value = Column(Text, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)


class SettingHistory(Base):
    __tablename__ = "settings_history"

    id = Column(Integer, primary_key=True, index=True)
    key = Column(String(255), nullable=False)
    old_value = Column(Text, nullable=True)
    new_value = Column(Text, nullable=True)
    changed_at = Column(DateTime, default=datetime.utcnow, nullable=False)

===== app/routers/__init__.py =====
"""Expose API routers."""
from .matching_router import router as matching_router
from .plex_router import router as plex_router
from .settings_router import router as settings_router
from .soulseek_router import router as soulseek_router
from .spotify_router import router as spotify_router

__all__ = [
    "matching_router",
    "plex_router",
    "settings_router",
    "soulseek_router",
    "spotify_router",
]

===== app/routers/beets_router.py =====
from typing import List, Optional

from fastapi import APIRouter, HTTPException
from fastapi.concurrency import run_in_threadpool
from pydantic import BaseModel

from app.core.beets_client import BeetsClient, BeetsClientError
from app.utils.logging_config import get_logger

logger = get_logger("beets_router")

router = APIRouter()
beets_client = BeetsClient()


# ----------------------------
# Request / Response Schemas
# ----------------------------


class ImportRequest(BaseModel):
    path: str
    quiet: bool = True
    autotag: bool = True


class ImportResponse(BaseModel):
    success: bool
    message: str


class UpdateRequest(BaseModel):
    path: Optional[str] = None


class UpdateResponse(BaseModel):
    success: bool
    message: str


class RemoveRequest(BaseModel):
    query: str
    force: bool = False


class RemoveResponse(BaseModel):
    success: bool
    removed: Optional[int] = None
    output: Optional[str] = None


class MoveRequest(BaseModel):
    query: Optional[str] = None


class MoveResponse(BaseModel):
    success: bool
    moved: Optional[int] = None
    output: Optional[str] = None


class WriteRequest(BaseModel):
    query: Optional[str] = None


class WriteResponse(BaseModel):
    success: bool
    written: Optional[int] = None
    output: Optional[str] = None


class ListAlbumsResponse(BaseModel):
    albums: List[str]


class ListTracksResponse(BaseModel):
    tracks: List[str]


class FieldsResponse(BaseModel):
    fields: List[str]


class QueryRequest(BaseModel):
    query: str
    format: str = "$artist - $album - $title"


class QueryResponse(BaseModel):
    results: List[str]


# ----------------------------
# Helper functions
# ----------------------------


async def _call_client(method, *args, **kwargs):
    try:
        return await run_in_threadpool(method, *args, **kwargs)
    except BeetsClientError as exc:
        detail = str(exc)
        if detail.startswith("Invalid query syntax"):
            logger.error("Invalid query syntax: %s", detail)
            raise HTTPException(status_code=400, detail="Invalid query syntax") from exc
        if detail == "Query must not be empty":
            logger.error("Empty query provided")
            raise HTTPException(status_code=400, detail=detail) from exc
        logger.error("Beets client error: %s", detail)
        raise HTTPException(status_code=500, detail=detail) from exc
    except Exception as exc:  # pragma: no cover - defensive
        logger.error("Unexpected error running beets: %s", exc)
        raise HTTPException(status_code=500, detail=str(exc)) from exc


# ----------------------------
# Endpoints
# ----------------------------


@router.post("/import", response_model=ImportResponse)
async def import_music(req: ImportRequest) -> ImportResponse:
    """Import new music into the Beets library."""

    output = await _call_client(
        beets_client.import_file,
        req.path,
        quiet=req.quiet,
        autotag=req.autotag,
    )
    return ImportResponse(success=True, message=output or "Import completed")


@router.post("/update", response_model=UpdateResponse)
async def update_library(req: UpdateRequest) -> UpdateResponse:
    """Update Beets library metadata, optionally for a specific path."""

    output = await _call_client(beets_client.update, req.path)
    return UpdateResponse(success=True, message=output or "Library updated")


@router.post(
    "/remove", response_model=RemoveResponse, response_model_exclude_none=True
)
async def remove_items(req: RemoveRequest) -> RemoveResponse:
    """Remove library items that match a query."""

    result = await _call_client(beets_client.remove, req.query, force=req.force)
    return RemoveResponse(**result)


@router.post(
    "/move", response_model=MoveResponse, response_model_exclude_none=True
)
async def move_items(req: MoveRequest) -> MoveResponse:
    """Move files in the Beets library, optionally filtering by a query."""

    result = await _call_client(beets_client.move, req.query)
    return MoveResponse(**result)


@router.post(
    "/write", response_model=WriteResponse, response_model_exclude_none=True
)
async def write_tags(req: WriteRequest) -> WriteResponse:
    """Write tags to files, optionally filtering by a query."""

    result = await _call_client(beets_client.write, req.query)
    return WriteResponse(**result)


@router.get("/albums", response_model=ListAlbumsResponse)
async def list_albums() -> ListAlbumsResponse:
    """List all albums managed by Beets."""

    albums = await _call_client(beets_client.list_albums)
    return ListAlbumsResponse(albums=albums)


@router.get("/tracks", response_model=ListTracksResponse)
async def list_tracks() -> ListTracksResponse:
    """List all track titles managed by Beets."""

    tracks = await _call_client(beets_client.list_tracks)
    return ListTracksResponse(tracks=tracks)


@router.get("/stats")
async def library_stats() -> dict:
    """Return statistics about the Beets library."""

    stats = await _call_client(beets_client.stats)
    return {"stats": stats}


@router.get("/fields", response_model=FieldsResponse)
async def list_fields() -> FieldsResponse:
    """Return all available Beets fields."""

    fields = await _call_client(beets_client.fields)
    return FieldsResponse(fields=fields)


@router.post("/query", response_model=QueryResponse)
async def run_query(req: QueryRequest) -> QueryResponse:
    """Execute a formatted Beets query."""

    results = await _call_client(
        beets_client.query, req.query, fmt=req.format
    )
    return QueryResponse(results=results)

===== app/routers/matching_router.py =====
"""Matching endpoints for Harmony."""
from __future__ import annotations

from typing import Any, Dict, Optional

from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session

from app.core.matching_engine import MusicMatchingEngine
from app.dependencies import get_db, get_matching_engine
from app.logging import get_logger
from app.models import Match
from app.schemas import AlbumMatchingRequest, MatchingRequest, MatchingResponse

logger = get_logger(__name__)

router = APIRouter()


def _extract_target_id(candidate: Optional[Dict[str, Any]]) -> Optional[str]:
    if not candidate:
        return None
    for key in ("id", "ratingKey", "filename"):
        value = candidate.get(key)
        if value is not None:
            return str(value)
    return None


def _persist_match(session: Session, match: Match) -> None:
    """Persist a match, rolling back on failure."""

    try:
        session.add(match)
        session.commit()
    except Exception as exc:  # pragma: no cover - database failure is exceptional
        session.rollback()
        logger.error("Failed to persist match %s: %s", match, exc)
        raise HTTPException(status_code=500, detail="Failed to store match result") from exc


@router.post("/spotify-to-plex", response_model=MatchingResponse)
def spotify_to_plex(
    payload: MatchingRequest,
    engine: MusicMatchingEngine = Depends(get_matching_engine),
    session: Session = Depends(get_db),
) -> MatchingResponse:
    """Match a Spotify track against Plex candidates and persist the result."""

    best_match, confidence = engine.find_best_match(payload.spotify_track, payload.candidates)
    target_id = _extract_target_id(best_match)
    match = Match(
        source="spotify-to-plex",
        spotify_track_id=str(payload.spotify_track.get("id")),
        target_id=target_id,
        confidence=confidence,
    )
    _persist_match(session, match)
    return MatchingResponse(best_match=best_match, confidence=confidence)


@router.post("/spotify-to-soulseek", response_model=MatchingResponse)
def spotify_to_soulseek(
    payload: MatchingRequest,
    engine: MusicMatchingEngine = Depends(get_matching_engine),
    session: Session = Depends(get_db),
) -> MatchingResponse:
    """Match a Spotify track against Soulseek candidates and persist the result."""

    best_candidate: Optional[Dict[str, Any]] = None
    best_score = 0.0
    for candidate in payload.candidates:
        score = engine.calculate_slskd_match_confidence(payload.spotify_track, candidate)
        if score > best_score:
            best_score = score
            best_candidate = candidate
    target_id = _extract_target_id(best_candidate)
    match = Match(
        source="spotify-to-soulseek",
        spotify_track_id=str(payload.spotify_track.get("id")),
        target_id=target_id,
        confidence=best_score,
    )
    _persist_match(session, match)
    return MatchingResponse(best_match=best_candidate, confidence=best_score)


@router.post("/spotify-to-plex-album", response_model=MatchingResponse)
def spotify_to_plex_album(
    payload: AlbumMatchingRequest, engine: MusicMatchingEngine = Depends(get_matching_engine)
) -> MatchingResponse:
    """Return the best matching Plex album for the provided Spotify album."""

    best_match, confidence = engine.find_best_album_match(payload.spotify_album, payload.candidates)
    return MatchingResponse(best_match=best_match, confidence=confidence)

===== app/routers/plex_router.py =====
"""Extended Plex API endpoints exposed through FastAPI."""
from __future__ import annotations

from typing import Any, AsyncIterator, Dict

from fastapi import APIRouter, Depends, HTTPException, Request, status
from fastapi.responses import StreamingResponse

from app.core.plex_client import PlexClient, PlexClientError
from app.dependencies import get_plex_client
from app.logging import get_logger

logger = get_logger(__name__)

router = APIRouter()


def _collect_query_params(request: Request) -> Dict[str, Any]:
    return {key: value for key, value in request.query_params.multi_items()}


@router.get("/status")
async def plex_status(client: PlexClient = Depends(get_plex_client)) -> Dict[str, Any]:
    try:
        sessions = await client.get_sessions()
        stats = await client.get_library_statistics()
    except Exception as exc:  # pragma: no cover - defensive logging
        logger.error("Failed to query Plex status: %s", exc)
        return {"status": "disconnected"}
    return {"status": "connected", "sessions": sessions, "library": stats}


@router.get("/library/sections")
async def list_libraries(
    request: Request, client: PlexClient = Depends(get_plex_client)
) -> Dict[str, Any]:
    try:
        params = _collect_query_params(request)
        return await client.get_libraries(params=params or None)
    except PlexClientError as exc:
        raise HTTPException(status_code=status.HTTP_502_BAD_GATEWAY, detail=str(exc)) from exc


@router.get("/libraries", include_in_schema=False)
async def list_libraries_legacy(
    request: Request, client: PlexClient = Depends(get_plex_client)
) -> Dict[str, Any]:
    """Backward compatible alias for :func:`list_libraries`."""

    return await list_libraries(request, client)


@router.get("/library/sections/{section_id}/all")
async def browse_library(
    section_id: str, request: Request, client: PlexClient = Depends(get_plex_client)
) -> Dict[str, Any]:
    try:
        params = _collect_query_params(request)
        return await client.get_library_items(section_id, params=params or None)
    except PlexClientError as exc:
        raise HTTPException(status_code=status.HTTP_502_BAD_GATEWAY, detail=str(exc)) from exc


@router.get("/library/{section_id}/items", include_in_schema=False)
async def browse_library_legacy(
    section_id: str, request: Request, client: PlexClient = Depends(get_plex_client)
) -> Dict[str, Any]:
    """Backward compatible alias for :func:`browse_library`."""

    return await browse_library(section_id, request, client)


@router.get("/library/metadata/{item_id}")
async def fetch_metadata(item_id: str, client: PlexClient = Depends(get_plex_client)) -> Dict[str, Any]:
    try:
        return await client.get_metadata(item_id)
    except PlexClientError as exc:
        raise HTTPException(status_code=status.HTTP_502_BAD_GATEWAY, detail=str(exc)) from exc


@router.get("/metadata/{item_id}", include_in_schema=False)
async def fetch_metadata_legacy(
    item_id: str, client: PlexClient = Depends(get_plex_client)
) -> Dict[str, Any]:
    """Backward compatible alias for :func:`fetch_metadata`."""

    return await fetch_metadata(item_id, client)


@router.get("/status/sessions")
async def active_sessions(client: PlexClient = Depends(get_plex_client)) -> Dict[str, Any]:
    return await client.get_sessions()


@router.get("/sessions", include_in_schema=False)
async def active_sessions_legacy(client: PlexClient = Depends(get_plex_client)) -> Dict[str, Any]:
    """Backward compatible alias for :func:`active_sessions`."""

    return await active_sessions(client)


@router.get("/status/sessions/history/all")
async def session_history(
    request: Request, client: PlexClient = Depends(get_plex_client)
) -> Dict[str, Any]:
    params = _collect_query_params(request)
    return await client.get_session_history(params=params or None)


@router.get("/history", include_in_schema=False)
async def session_history_legacy(
    request: Request, client: PlexClient = Depends(get_plex_client)
) -> Dict[str, Any]:
    """Backward compatible alias for :func:`session_history`."""

    return await session_history(request, client)


@router.get("/timeline")
async def get_timeline(
    request: Request, client: PlexClient = Depends(get_plex_client)
) -> Dict[str, Any]:
    params = _collect_query_params(request)
    return await client.get_timeline(params=params or None)


@router.post("/timeline")
async def post_timeline(payload: Dict[str, Any], client: PlexClient = Depends(get_plex_client)) -> str:
    return await client.update_timeline(payload)


@router.post("/scrobble")
async def post_scrobble(payload: Dict[str, Any], client: PlexClient = Depends(get_plex_client)) -> str:
    return await client.scrobble(payload)


@router.post("/unscrobble")
async def post_unscrobble(payload: Dict[str, Any], client: PlexClient = Depends(get_plex_client)) -> str:
    return await client.unscrobble(payload)


@router.get("/playlists")
async def list_playlists(client: PlexClient = Depends(get_plex_client)) -> Dict[str, Any]:
    return await client.get_playlists()


@router.post("/playlists")
async def create_playlist(
    payload: Dict[str, Any], client: PlexClient = Depends(get_plex_client)
) -> Dict[str, Any]:
    return await client.create_playlist(payload)


@router.put("/playlists/{playlist_id}")
async def update_playlist(
    playlist_id: str, payload: Dict[str, Any], client: PlexClient = Depends(get_plex_client)
) -> Dict[str, Any]:
    return await client.update_playlist(playlist_id, payload)


@router.delete("/playlists/{playlist_id}")
async def delete_playlist(playlist_id: str, client: PlexClient = Depends(get_plex_client)) -> Dict[str, Any]:
    return await client.delete_playlist(playlist_id)


@router.post("/playQueues")
async def create_playqueue(
    payload: Dict[str, Any], client: PlexClient = Depends(get_plex_client)
) -> Dict[str, Any]:
    return await client.create_playqueue(payload)


@router.get("/playQueues/{playqueue_id}")
async def get_playqueue(playqueue_id: str, client: PlexClient = Depends(get_plex_client)) -> Dict[str, Any]:
    return await client.get_playqueue(playqueue_id)


@router.post("/rate")
async def rate_item(payload: Dict[str, Any], client: PlexClient = Depends(get_plex_client)) -> str:
    item_id = payload.get("key")
    rating = payload.get("rating")
    if not item_id or rating is None:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Both 'key' and 'rating' must be provided",
        )
    return await client.rate_item(str(item_id), int(rating))


@router.post("/rate/{item_id}", include_in_schema=False)
async def rate_item_legacy(
    item_id: str, rating: int, client: PlexClient = Depends(get_plex_client)
) -> str:
    """Backward compatible alias for :func:`rate_item`."""

    return await client.rate_item(item_id, rating)


@router.post("/tags/{item_id}")
async def sync_tags(
    item_id: str, payload: Dict[str, Any], client: PlexClient = Depends(get_plex_client)
) -> Dict[str, Any]:
    tags = {key: value for key, value in payload.items() if isinstance(value, list)}
    return await client.sync_tags(item_id, tags)


@router.get("/devices")
async def list_devices(client: PlexClient = Depends(get_plex_client)) -> Dict[str, Any]:
    return await client.get_devices()


@router.get("/dvr")
async def list_dvr(client: PlexClient = Depends(get_plex_client)) -> Dict[str, Any]:
    return await client.get_dvr()


@router.get("/livetv")
async def list_live_tv(
    request: Request, client: PlexClient = Depends(get_plex_client)
) -> Dict[str, Any]:
    params = _collect_query_params(request)
    return await client.get_live_tv(params=params or None)


@router.get("/notifications")
async def listen_notifications(client: PlexClient = Depends(get_plex_client)) -> StreamingResponse:
    async def event_stream() -> AsyncIterator[bytes]:
        try:
            async with client.listen_notifications() as websocket:
                async for message in websocket:
                    if message.type.name == "TEXT":
                        yield f"data: {message.data}\n\n".encode("utf-8")
                    elif message.type.name == "ERROR":
                        logger.error("Plex notification stream error: %s", websocket.exception())
                        break
        except Exception as exc:  # pragma: no cover - defensive logging
            logger.error("Failed to stream Plex notifications: %s", exc)
            yield f"event: error\ndata: {exc}\n\n".encode("utf-8")

    return StreamingResponse(event_stream(), media_type="text/event-stream")


===== app/routers/settings_router.py =====
"""Settings management endpoints."""
from __future__ import annotations

from datetime import datetime

from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy import select
from sqlalchemy.orm import Session

from app.dependencies import get_db
from app.models import Setting, SettingHistory
from app.schemas import SettingsHistoryResponse, SettingsPayload, SettingsResponse

router = APIRouter()


@router.get("", response_model=SettingsResponse)
def get_settings(session: Session = Depends(get_db)) -> SettingsResponse:
    settings = session.execute(select(Setting)).scalars().all()
    settings_dict = {setting.key: setting.value for setting in settings}
    updated_at = max((setting.updated_at or setting.created_at for setting in settings), default=datetime.utcnow())
    return SettingsResponse(settings=settings_dict, updated_at=updated_at)


@router.post("", response_model=SettingsResponse)
def update_setting(payload: SettingsPayload, session: Session = Depends(get_db)) -> SettingsResponse:
    if not payload.key:
        raise HTTPException(status_code=400, detail="Key must not be empty")
    setting = session.execute(select(Setting).where(Setting.key == payload.key)).scalar_one_or_none()
    now = datetime.utcnow()

    history_entry = SettingHistory(
        key=payload.key,
        old_value=setting.value if setting is not None else None,
        new_value=payload.value,
        changed_at=now,
    )
    session.add(history_entry)

    if setting is None:
        setting = Setting(key=payload.key, value=payload.value, updated_at=now)
        session.add(setting)
    else:
        setting.value = payload.value
        setting.updated_at = now
    session.commit()
    return get_settings(session)


@router.get("/history", response_model=SettingsHistoryResponse)
def get_settings_history(session: Session = Depends(get_db)) -> SettingsHistoryResponse:
    history_entries = (
        session.execute(
            select(SettingHistory).order_by(SettingHistory.changed_at.desc()).limit(50)
        )
        .scalars()
        .all()
    )
    return SettingsHistoryResponse(history=history_entries)

===== app/routers/soulseek_router.py =====
"""Soulseek API endpoints."""
from __future__ import annotations

import asyncio
from datetime import datetime
from typing import Any, Dict, List

from fastapi import APIRouter, Depends, HTTPException, Query, Request
from sqlalchemy import select
from sqlalchemy.orm import Session

from app.core.soulseek_client import SoulseekClient, SoulseekClientError
from app.dependencies import get_db, get_soulseek_client
from app.logging import get_logger
from app.models import Download
from app.schemas import (
    SoulseekCancelResponse,
    SoulseekDownloadRequest,
    SoulseekDownloadResponse,
    SoulseekDownloadStatus,
    SoulseekSearchRequest,
    SoulseekSearchResponse,
    StatusResponse,
)

logger = get_logger(__name__)

router = APIRouter()


def _translate_error(message: str, exc: SoulseekClientError) -> HTTPException:
    logger.error("%s: %s", message, exc)
    return HTTPException(status_code=502, detail=message)


@router.get("/status", response_model=StatusResponse)
async def soulseek_status(client: SoulseekClient = Depends(get_soulseek_client)) -> StatusResponse:
    """Return connectivity status for the Soulseek daemon."""

    try:
        await client.get_download_status()
    except Exception as exc:  # pragma: no cover - defensive
        logger.warning("Soulseek status check failed: %s", exc)
        return StatusResponse(status="disconnected")
    return StatusResponse(status="connected")


@router.post("/search", response_model=SoulseekSearchResponse)
async def soulseek_search(
    payload: SoulseekSearchRequest,
    client: SoulseekClient = Depends(get_soulseek_client),
) -> SoulseekSearchResponse:
    """Perform a Soulseek search and normalise the JSON response."""

    try:
        results = await client.search(payload.query)
    except SoulseekClientError as exc:
        logger.error("Soulseek search failed: %s", exc)
        raise HTTPException(status_code=502, detail="Soulseek search failed") from exc
    items: list[Any]
    raw_payload: Dict[str, Any] | None = None
    if isinstance(results, dict):
        raw_payload = results
        extracted = results.get("results", [])
        items = extracted if isinstance(extracted, list) else [extracted]
    elif isinstance(results, list):
        items = results
    else:
        items = [results] if results else []
    return SoulseekSearchResponse(results=items, raw=raw_payload)


@router.post("/download", response_model=SoulseekDownloadResponse)
async def soulseek_download(
    payload: SoulseekDownloadRequest,
    request: Request,
    session: Session = Depends(get_db),
    client: SoulseekClient = Depends(get_soulseek_client),
) -> SoulseekDownloadResponse:
    """Queue a Soulseek download job and persist queued entries."""

    if not payload.files:
        raise HTTPException(status_code=400, detail="No files provided for download")

    created_downloads: List[Dict[str, Any]] = []
    job_files: List[Dict[str, Any]] = []
    try:
        for file_info in payload.files:
            filename = str(file_info.get("filename") or file_info.get("name") or "unknown")
            download = Download(filename=filename, state="queued", progress=0.0)
            session.add(download)
            session.flush()

            payload_copy = dict(file_info)
            payload_copy.setdefault("filename", filename)
            payload_copy["download_id"] = download.id
            job_files.append(payload_copy)

            created_downloads.append(
                {
                    "id": download.id,
                    "filename": filename,
                    "state": download.state,
                    "progress": download.progress,
                }
            )
        session.commit()
    except Exception as exc:  # pragma: no cover - defensive
        session.rollback()
        logger.error("Failed to persist download request: %s", exc)
        raise HTTPException(status_code=500, detail="Failed to queue download") from exc

    job = {"username": payload.username, "files": job_files}

    worker = getattr(request.app.state, "sync_worker", None)
    try:
        if worker is not None and hasattr(worker, "enqueue"):
            await worker.enqueue(job)
        else:
            await client.download(job)
    except Exception as exc:
        if isinstance(exc, asyncio.CancelledError):  # pragma: no cover - defensive
            raise
        logger.error("Soulseek rejected download queue request: %s", exc)
        for record in job_files:
            download = session.get(Download, record["download_id"])
            if download is None:
                continue
            download.state = "failed"
            download.updated_at = datetime.utcnow()
        session.commit()
        raise HTTPException(status_code=502, detail="Soulseek download failed") from exc

    detail: Dict[str, Any] = {"downloads": created_downloads}
    return SoulseekDownloadResponse(status="queued", detail=detail)


@router.get("/downloads", response_model=SoulseekDownloadStatus)
def soulseek_downloads(session: Session = Depends(get_db)) -> SoulseekDownloadStatus:
    """Return persisted download progress from the database."""

    stmt = select(Download).order_by(Download.created_at.desc())
    downloads = session.execute(stmt).scalars().all()
    return SoulseekDownloadStatus(downloads=downloads)


@router.delete("/download/{download_id}", response_model=SoulseekCancelResponse)
async def soulseek_cancel(
    download_id: int,
    session: Session = Depends(get_db),
    client: SoulseekClient = Depends(get_soulseek_client),
) -> SoulseekCancelResponse:
    """Cancel a Soulseek download by identifier."""

    download = session.get(Download, download_id)
    if download is None:
        raise HTTPException(status_code=404, detail="Download not found")

    try:
        await client.cancel_download(str(download_id))
    except SoulseekClientError as exc:
        raise _translate_error("Failed to cancel download", exc)

    download.state = "failed"
    if download.progress < 0:
        download.progress = 0.0
    elif download.progress > 100:
        download.progress = 100.0
    download.updated_at = datetime.utcnow()
    session.commit()

    return SoulseekCancelResponse(cancelled=True)


@router.get("/download/{download_id}")
async def soulseek_download_detail(
    download_id: str,
    client: SoulseekClient = Depends(get_soulseek_client),
) -> Dict[str, Any]:
    try:
        return await client.get_download(download_id)
    except SoulseekClientError as exc:
        raise _translate_error("Failed to fetch download", exc) from exc


@router.get("/downloads/all")
async def soulseek_all_downloads(client: SoulseekClient = Depends(get_soulseek_client)) -> Dict[str, Any]:
    try:
        downloads = await client.get_all_downloads()
    except SoulseekClientError as exc:
        raise _translate_error("Failed to fetch downloads", exc) from exc
    return {"downloads": downloads}


@router.delete("/downloads/completed")
async def soulseek_remove_completed_downloads(
    client: SoulseekClient = Depends(get_soulseek_client),
) -> Dict[str, Any]:
    try:
        return await client.remove_completed_downloads()
    except SoulseekClientError as exc:
        raise _translate_error("Failed to remove completed downloads", exc) from exc


@router.get("/download/{download_id}/queue")
async def soulseek_download_queue(
    download_id: str,
    client: SoulseekClient = Depends(get_soulseek_client),
) -> Dict[str, Any]:
    try:
        return await client.get_queue_position(download_id)
    except SoulseekClientError as exc:
        raise _translate_error("Failed to fetch queue position", exc) from exc


@router.post("/enqueue")
async def soulseek_enqueue(
    payload: SoulseekDownloadRequest,
    client: SoulseekClient = Depends(get_soulseek_client),
) -> Dict[str, Any]:
    try:
        return await client.enqueue(payload.username, payload.files)
    except SoulseekClientError as exc:
        raise _translate_error("Failed to enqueue downloads", exc) from exc


@router.delete("/upload/{upload_id}")
async def soulseek_cancel_upload(
    upload_id: str,
    client: SoulseekClient = Depends(get_soulseek_client),
) -> Dict[str, Any]:
    try:
        return await client.cancel_upload(upload_id)
    except SoulseekClientError as exc:
        raise _translate_error("Failed to cancel upload", exc) from exc


@router.get("/upload/{upload_id}")
async def soulseek_upload_detail(
    upload_id: str,
    client: SoulseekClient = Depends(get_soulseek_client),
) -> Dict[str, Any]:
    try:
        return await client.get_upload(upload_id)
    except SoulseekClientError as exc:
        raise _translate_error("Failed to fetch upload", exc) from exc


@router.get("/uploads")
async def soulseek_uploads(client: SoulseekClient = Depends(get_soulseek_client)) -> Dict[str, Any]:
    try:
        uploads = await client.get_uploads()
    except SoulseekClientError as exc:
        raise _translate_error("Failed to fetch uploads", exc) from exc
    return {"uploads": uploads}


@router.get("/uploads/all")
async def soulseek_all_uploads(client: SoulseekClient = Depends(get_soulseek_client)) -> Dict[str, Any]:
    try:
        uploads = await client.get_all_uploads()
    except SoulseekClientError as exc:
        raise _translate_error("Failed to fetch all uploads", exc) from exc
    return {"uploads": uploads}


@router.delete("/uploads/completed")
async def soulseek_remove_completed_uploads(
    client: SoulseekClient = Depends(get_soulseek_client),
) -> Dict[str, Any]:
    try:
        return await client.remove_completed_uploads()
    except SoulseekClientError as exc:
        raise _translate_error("Failed to remove completed uploads", exc) from exc


@router.get("/user/{username}/address")
async def soulseek_user_address(
    username: str,
    client: SoulseekClient = Depends(get_soulseek_client),
) -> Dict[str, Any]:
    try:
        return await client.user_address(username)
    except SoulseekClientError as exc:
        raise _translate_error("Failed to fetch user address", exc) from exc


@router.get("/user/{username}/browse")
async def soulseek_user_browse(
    username: str,
    client: SoulseekClient = Depends(get_soulseek_client),
) -> Dict[str, Any]:
    try:
        return await client.user_browse(username)
    except SoulseekClientError as exc:
        raise _translate_error("Failed to browse user", exc) from exc


@router.get("/user/{username}/browsing_status")
async def soulseek_user_browsing_status(
    username: str,
    client: SoulseekClient = Depends(get_soulseek_client),
) -> Dict[str, Any]:
    try:
        return await client.user_browsing_status(username)
    except SoulseekClientError as exc:
        raise _translate_error("Failed to fetch user browsing status", exc) from exc


@router.get("/user/{username}/directory")
async def soulseek_user_directory(
    username: str,
    path: str = Query(..., description="Directory path to browse"),
    client: SoulseekClient = Depends(get_soulseek_client),
) -> Dict[str, Any]:
    try:
        return await client.user_directory(username, path)
    except SoulseekClientError as exc:
        raise _translate_error("Failed to fetch user directory", exc) from exc


@router.get("/user/{username}/info")
async def soulseek_user_info(
    username: str,
    client: SoulseekClient = Depends(get_soulseek_client),
) -> Dict[str, Any]:
    try:
        return await client.user_info(username)
    except SoulseekClientError as exc:
        raise _translate_error("Failed to fetch user info", exc) from exc


@router.get("/user/{username}/status")
async def soulseek_user_status(
    username: str,
    client: SoulseekClient = Depends(get_soulseek_client),
) -> Dict[str, Any]:
    try:
        return await client.user_status(username)
    except SoulseekClientError as exc:
        raise _translate_error("Failed to fetch user status", exc) from exc

===== app/routers/spotify_router.py =====
"""Spotify API endpoints."""
from __future__ import annotations

from typing import List, Optional

from fastapi import APIRouter, Depends, HTTPException, Query
from pydantic import BaseModel
from sqlalchemy.orm import Session

from app.core.spotify_client import SpotifyClient
from app.dependencies import get_db, get_spotify_client
from app.models import Playlist
from app.schemas import (
    AudioFeaturesResponse,
    PlaylistItemsResponse,
    PlaylistResponse,
    RecommendationsResponse,
    SavedTracksResponse,
    SpotifySearchResponse,
    StatusResponse,
    TrackDetailResponse,
    UserProfileResponse,
)

router = APIRouter()


class PlaylistTracksPayload(BaseModel):
    uris: List[str]


class PlaylistReorderPayload(BaseModel):
    range_start: int
    insert_before: int


class TrackIdsPayload(BaseModel):
    ids: List[str]


@router.get("/status", response_model=StatusResponse)
def spotify_status(client: SpotifyClient = Depends(get_spotify_client)) -> StatusResponse:
    status = "connected" if client.is_authenticated() else "unauthenticated"
    return StatusResponse(status=status)


@router.get("/search/tracks", response_model=SpotifySearchResponse)
def search_tracks(
    query: str = Query(..., min_length=1),
    client: SpotifyClient = Depends(get_spotify_client),
) -> SpotifySearchResponse:
    response = client.search_tracks(query)
    items = response.get("tracks", {}).get("items", [])
    return SpotifySearchResponse(items=items)


@router.get("/search/artists", response_model=SpotifySearchResponse)
def search_artists(
    query: str = Query(..., min_length=1),
    client: SpotifyClient = Depends(get_spotify_client),
) -> SpotifySearchResponse:
    response = client.search_artists(query)
    items = response.get("artists", {}).get("items", [])
    return SpotifySearchResponse(items=items)


@router.get("/search/albums", response_model=SpotifySearchResponse)
def search_albums(
    query: str = Query(..., min_length=1),
    client: SpotifyClient = Depends(get_spotify_client),
) -> SpotifySearchResponse:
    response = client.search_albums(query)
    items = response.get("albums", {}).get("items", [])
    return SpotifySearchResponse(items=items)


@router.get("/playlists", response_model=PlaylistResponse)
def list_playlists(db: Session = Depends(get_db)) -> PlaylistResponse:
    playlists = db.query(Playlist).order_by(Playlist.updated_at.desc()).all()
    return PlaylistResponse(playlists=playlists)


@router.get("/track/{track_id}", response_model=TrackDetailResponse)
def get_track_details(
    track_id: str,
    client: SpotifyClient = Depends(get_spotify_client),
) -> TrackDetailResponse:
    details = client.get_track_details(track_id)
    if not details:
        raise HTTPException(status_code=404, detail="Track not found")
    return TrackDetailResponse(track=details)


@router.get("/audio-features/{track_id}", response_model=AudioFeaturesResponse)
def get_audio_features(
    track_id: str,
    client: SpotifyClient = Depends(get_spotify_client),
) -> AudioFeaturesResponse:
    features = client.get_audio_features(track_id)
    if not features:
        raise HTTPException(status_code=404, detail="Audio features not found")
    return AudioFeaturesResponse(audio_features=features)


@router.get("/audio-features", response_model=AudioFeaturesResponse)
def get_multiple_audio_features(
    ids: str = Query(..., min_length=1),
    client: SpotifyClient = Depends(get_spotify_client),
) -> AudioFeaturesResponse:
    track_ids = [item.strip() for item in ids.split(",") if item.strip()]
    if not track_ids:
        raise HTTPException(status_code=400, detail="No track IDs provided")
    features = client.get_multiple_audio_features(track_ids)
    return AudioFeaturesResponse(audio_features=features.get("audio_features", []))


@router.get(
    "/playlists/{playlist_id}/tracks",
    response_model=PlaylistItemsResponse,
)
def get_playlist_items(
    playlist_id: str,
    limit: int = Query(100, ge=1, le=100),
    client: SpotifyClient = Depends(get_spotify_client),
) -> PlaylistItemsResponse:
    items = client.get_playlist_items(playlist_id, limit=limit)
    total = items.get("total")
    if total is None:
        total = items.get("tracks", {}).get("total")
    if total is None:
        total = len(items.get("items", []))
    return PlaylistItemsResponse(
        items=items.get("items", []),
        total=total,
    )


@router.post(
    "/playlists/{playlist_id}/tracks",
    response_model=StatusResponse,
)
def add_tracks_to_playlist(
    playlist_id: str,
    payload: PlaylistTracksPayload,
    client: SpotifyClient = Depends(get_spotify_client),
) -> StatusResponse:
    if not payload.uris:
        raise HTTPException(status_code=400, detail="No track URIs provided")
    client.add_tracks_to_playlist(playlist_id, payload.uris)
    return StatusResponse(status="tracks-added")


@router.delete(
    "/playlists/{playlist_id}/tracks",
    response_model=StatusResponse,
)
def remove_tracks_from_playlist(
    playlist_id: str,
    payload: PlaylistTracksPayload,
    client: SpotifyClient = Depends(get_spotify_client),
) -> StatusResponse:
    if not payload.uris:
        raise HTTPException(status_code=400, detail="No track URIs provided")
    client.remove_tracks_from_playlist(playlist_id, payload.uris)
    return StatusResponse(status="tracks-removed")


@router.put(
    "/playlists/{playlist_id}/reorder",
    response_model=StatusResponse,
)
def reorder_playlist(
    playlist_id: str,
    payload: PlaylistReorderPayload,
    client: SpotifyClient = Depends(get_spotify_client),
) -> StatusResponse:
    client.reorder_playlist_items(
        playlist_id,
        range_start=payload.range_start,
        insert_before=payload.insert_before,
    )
    return StatusResponse(status="playlist-reordered")


@router.get("/me/tracks", response_model=SavedTracksResponse)
def get_saved_tracks(
    limit: int = Query(20, ge=1, le=50),
    client: SpotifyClient = Depends(get_spotify_client),
) -> SavedTracksResponse:
    saved = client.get_saved_tracks(limit=limit)
    return SavedTracksResponse(items=saved.get("items", []), total=saved.get("total", len(saved.get("items", []))))


@router.put("/me/tracks", response_model=StatusResponse)
def save_tracks(
    payload: TrackIdsPayload,
    client: SpotifyClient = Depends(get_spotify_client),
) -> StatusResponse:
    if not payload.ids:
        raise HTTPException(status_code=400, detail="No track IDs provided")
    client.save_tracks(payload.ids)
    return StatusResponse(status="tracks-saved")


@router.delete("/me/tracks", response_model=StatusResponse)
def remove_saved_tracks(
    payload: TrackIdsPayload,
    client: SpotifyClient = Depends(get_spotify_client),
) -> StatusResponse:
    if not payload.ids:
        raise HTTPException(status_code=400, detail="No track IDs provided")
    client.remove_saved_tracks(payload.ids)
    return StatusResponse(status="tracks-removed")


@router.get("/me", response_model=UserProfileResponse)
def get_current_user(
    client: SpotifyClient = Depends(get_spotify_client),
) -> UserProfileResponse:
    profile = client.get_current_user()
    return UserProfileResponse(profile=profile)


@router.get("/me/top/tracks", response_model=SpotifySearchResponse)
def get_top_tracks(
    limit: int = Query(20, ge=1, le=50),
    client: SpotifyClient = Depends(get_spotify_client),
) -> SpotifySearchResponse:
    response = client.get_top_tracks(limit=limit)
    return SpotifySearchResponse(items=response.get("items", []))


@router.get("/me/top/artists", response_model=SpotifySearchResponse)
def get_top_artists(
    limit: int = Query(20, ge=1, le=50),
    client: SpotifyClient = Depends(get_spotify_client),
) -> SpotifySearchResponse:
    response = client.get_top_artists(limit=limit)
    return SpotifySearchResponse(items=response.get("items", []))


@router.get("/recommendations", response_model=RecommendationsResponse)
def get_recommendations(
    seed_tracks: Optional[str] = Query(None),
    seed_artists: Optional[str] = Query(None),
    seed_genres: Optional[str] = Query(None),
    limit: int = Query(20, ge=1, le=100),
    client: SpotifyClient = Depends(get_spotify_client),
) -> RecommendationsResponse:
    def _split(value: Optional[str]) -> Optional[List[str]]:
        if value is None:
            return None
        result = [item.strip() for item in value.split(",") if item.strip()]
        return result or None

    response = client.get_recommendations(
        seed_tracks=_split(seed_tracks),
        seed_artists=_split(seed_artists),
        seed_genres=_split(seed_genres),
        limit=limit,
    )
    return RecommendationsResponse(
        tracks=response.get("tracks", []),
        seeds=response.get("seeds", []),
    )

===== app/schemas.py =====
"""Pydantic schemas for request and response bodies."""
from __future__ import annotations

from datetime import datetime
from typing import Any, Dict, List, Optional, Union

from pydantic import BaseModel, Field, ConfigDict


class StatusResponse(BaseModel):
    status: str
    artist_count: Optional[int] = None
    album_count: Optional[int] = None
    track_count: Optional[int] = None
    last_scan: Optional[datetime] = None


class SpotifySearchResponse(BaseModel):
    items: List[Dict[str, Any]]


class PlaylistEntry(BaseModel):
    id: str
    name: str
    track_count: int
    updated_at: datetime

    model_config = ConfigDict(from_attributes=True)


class PlaylistResponse(BaseModel):
    playlists: List[PlaylistEntry]


class TrackDetailResponse(BaseModel):
    track: Dict[str, Any]


class AudioFeaturesResponse(BaseModel):
    audio_features: Union[Dict[str, Any], List[Dict[str, Any]]]


class PlaylistItemsResponse(BaseModel):
    items: List[Dict[str, Any]]
    total: int


class SavedTracksResponse(BaseModel):
    items: List[Dict[str, Any]]
    total: int


class UserProfileResponse(BaseModel):
    profile: Dict[str, Any]


class RecommendationsResponse(BaseModel):
    tracks: List[Dict[str, Any]]
    seeds: List[Dict[str, Any]]


class SoulseekSearchRequest(BaseModel):
    query: str


class SoulseekDownloadRequest(BaseModel):
    username: str = Field(..., description="Soulseek username hosting the files")
    files: List[Dict[str, Any]] = Field(..., description="List of files to download")


class SoulseekSearchResponse(BaseModel):
    """Response payload for Soulseek search results."""

    results: List[Any]
    raw: Optional[Dict[str, Any]] = None


class SoulseekDownloadResponse(BaseModel):
    """Response payload when a Soulseek download is queued."""

    status: str
    detail: Optional[Dict[str, Any]] = None


class SoulseekDownloadEntry(BaseModel):
    id: int
    filename: str
    state: str
    progress: float
    created_at: datetime
    updated_at: datetime

    model_config = ConfigDict(from_attributes=True)


class SoulseekDownloadStatus(BaseModel):
    downloads: List[SoulseekDownloadEntry]


class SoulseekCancelResponse(BaseModel):
    cancelled: bool


class MatchingRequest(BaseModel):
    spotify_track: Dict[str, Any]
    candidates: List[Dict[str, Any]]


class MatchingResponse(BaseModel):
    best_match: Optional[Dict[str, Any]]
    confidence: float


class AlbumMatchingRequest(BaseModel):
    spotify_album: Dict[str, Any]
    candidates: List[Dict[str, Any]]


class SettingsPayload(BaseModel):
    key: str
    value: Optional[str]


class SettingsResponse(BaseModel):
    settings: Dict[str, Optional[str]]
    updated_at: datetime


class SettingsHistoryEntry(BaseModel):
    key: str
    old_value: Optional[str]
    new_value: Optional[str]
    changed_at: datetime

    model_config = ConfigDict(from_attributes=True)


class SettingsHistoryResponse(BaseModel):
    history: List[SettingsHistoryEntry]

===== app/utils/__init__.py =====
"""Utility helpers for Harmony."""

from .logging_config import configure_logging, get_logger  # noqa: F401

__all__ = ["configure_logging", "get_logger"]

===== app/utils/logging_config.py =====
"""Compatibility wrapper exposing logging helpers for legacy imports."""

from __future__ import annotations

from app.logging import configure_logging, get_logger

__all__ = ["configure_logging", "get_logger"]

===== app/workers/__init__.py =====
"""Background worker exports."""
from .matching_worker import MatchingWorker
from .playlist_sync_worker import PlaylistSyncWorker
from .scan_worker import ScanWorker
from .sync_worker import SyncWorker

__all__ = ["MatchingWorker", "PlaylistSyncWorker", "ScanWorker", "SyncWorker"]

===== app/workers/matching_worker.py =====
"""Background worker handling deferred matching operations."""
from __future__ import annotations

import asyncio
from typing import Any, Dict

from app.core.matching_engine import MusicMatchingEngine
from app.db import session_scope
from app.logging import get_logger
from app.models import Match

logger = get_logger(__name__)


class MatchingWorker:
    def __init__(self, engine: MusicMatchingEngine) -> None:
        self._engine = engine
        self._queue: asyncio.Queue[Dict[str, Any]] = asyncio.Queue()
        self._task: asyncio.Task | None = None
        self._running = asyncio.Event()

    async def start(self) -> None:
        if self._task is None or self._task.done():
            self._running.set()
            self._task = asyncio.create_task(self._run())

    async def stop(self) -> None:
        self._running.clear()
        if self._task:
            await self._queue.put({"_shutdown": True})
            await self._task

    @property
    def queue(self) -> asyncio.Queue[Dict[str, Any]]:
        return self._queue

    async def _run(self) -> None:
        logger.info("MatchingWorker started")
        while self._running.is_set():
            job = await self._queue.get()
            try:
                if job.get("_shutdown"):
                    break
                await self._process_job(job)
            except Exception as exc:  # pragma: no cover
                logger.error("Failed to process matching job: %s", exc)
            finally:
                self._queue.task_done()
        logger.info("MatchingWorker stopped")

    async def _process_job(self, job: Dict[str, Any]) -> None:
        job_type = job.get("type")
        spotify_track = job.get("spotify_track")
        candidates = job.get("candidates", [])
        if not spotify_track or not candidates:
            logger.warning("Invalid matching job received: %s", job)
            return
        if job_type == "spotify-to-plex":
            best_match, confidence = self._engine.find_best_match(spotify_track, candidates)
        else:
            best_match = None
            confidence = 0.0
            for candidate in candidates:
                score = self._engine.calculate_slskd_match_confidence(spotify_track, candidate)
                if score > confidence:
                    confidence = score
                    best_match = candidate
        self._store_match(job_type, spotify_track, best_match, confidence)

    def _store_match(
        self,
        job_type: str,
        spotify_track: Dict[str, Any],
        best_match: Dict[str, Any] | None,
        confidence: float,
    ) -> None:
        with session_scope() as session:
            match = Match(
                source=job_type,
                spotify_track_id=str(spotify_track.get("id")),
                target_id=str(best_match.get("id")) if best_match and best_match.get("id") else None,
                confidence=confidence,
            )
            session.add(match)

===== app/workers/playlist_sync_worker.py =====
"""Background worker that synchronises Spotify playlists into the database."""
from __future__ import annotations

import asyncio
from datetime import datetime
from typing import Any, Iterable

from app.core.spotify_client import SpotifyClient
from app.db import session_scope
from app.logging import get_logger
from app.models import Playlist

logger = get_logger(__name__)


class PlaylistSyncWorker:
    """Periodically fetches playlists for the authenticated user."""

    def __init__(self, spotify_client: SpotifyClient, interval_seconds: float = 900.0) -> None:
        self._client = spotify_client
        self._interval = interval_seconds
        self._task: asyncio.Task[None] | None = None
        self._running = False

    async def start(self) -> None:
        if self._task is None or self._task.done():
            self._running = True
            self._task = asyncio.create_task(self._run())

    async def stop(self) -> None:
        self._running = False
        if self._task is not None:
            self._task.cancel()
            try:
                await self._task
            except asyncio.CancelledError:  # pragma: no cover - cancellation lifecycle
                pass
            self._task = None

    async def _run(self) -> None:
        logger.info("PlaylistSyncWorker started")
        try:
            while self._running:
                await self.sync_once()
                await asyncio.sleep(self._interval)
        except asyncio.CancelledError:  # pragma: no cover - cancellation lifecycle
            logger.debug("PlaylistSyncWorker cancelled")
            raise
        finally:
            self._running = False
            logger.info("PlaylistSyncWorker stopped")

    async def sync_once(self) -> None:
        """Fetch playlists from Spotify and persist them."""

        try:
            response = self._client.get_user_playlists()
        except Exception as exc:  # pragma: no cover - defensive logging
            logger.error("Failed to fetch playlists from Spotify: %s", exc)
            return

        items: list[dict[str, Any]] = []
        if isinstance(response, dict):
            raw_items = response.get("items")
            if isinstance(raw_items, Iterable):
                items = [item for item in raw_items if isinstance(item, dict)]
        elif isinstance(response, list):
            items = [item for item in response if isinstance(item, dict)]

        if not items:
            logger.debug("No playlists received from Spotify")
            return

        now = datetime.utcnow()
        processed = 0

        with session_scope() as session:
            for payload in items:
                playlist_id = payload.get("id")
                name = payload.get("name")
                if not playlist_id or not name:
                    continue

                track_count = self._extract_track_count(payload)
                playlist = session.get(Playlist, str(playlist_id))

                if playlist is None:
                    playlist = Playlist(
                        id=str(playlist_id),
                        name=str(name),
                        track_count=track_count,
                    )
                    playlist.updated_at = now
                    session.add(playlist)
                else:
                    playlist.name = str(name)
                    playlist.track_count = track_count
                    playlist.updated_at = now

                processed += 1

        logger.info("Synced %s playlists from Spotify", processed)

    @staticmethod
    def _extract_track_count(payload: dict[str, Any]) -> int:
        """Safely derive the track count from a playlist payload."""

        track_count: int = 0
        tracks = payload.get("tracks")
        if isinstance(tracks, dict):
            total = tracks.get("total")
            try:
                track_count = int(total)
            except (TypeError, ValueError):
                track_count = 0
        elif isinstance(tracks, Iterable) and not isinstance(tracks, (str, bytes)):
            track_count = sum(1 for _ in tracks)
        else:
            try:
                track_count = int(payload.get("track_count", 0))
            except (TypeError, ValueError):
                track_count = 0

        return max(track_count, 0)

===== app/workers/scan_worker.py =====
"""Worker that periodically scans the Plex library."""
from __future__ import annotations

import asyncio
from datetime import datetime

from sqlalchemy import select

from app.core.plex_client import PlexClient
from app.db import session_scope
from app.logging import get_logger
from app.models import Setting

logger = get_logger(__name__)


class ScanWorker:
    def __init__(self, plex_client: PlexClient, interval_seconds: int = 600) -> None:
        self._client = plex_client
        self._interval = interval_seconds
        self._task: asyncio.Task | None = None
        self._running = asyncio.Event()

    async def start(self) -> None:
        if self._task is None or self._task.done():
            self._running.set()
            self._task = asyncio.create_task(self._run())

    async def stop(self) -> None:
        self._running.clear()
        if self._task:
            self._task.cancel()
            try:
                await self._task
            except asyncio.CancelledError:  # pragma: no cover
                pass

    async def _run(self) -> None:
        logger.info("ScanWorker started")
        while self._running.is_set():
            await self._perform_scan()
            await asyncio.sleep(self._interval)
        logger.info("ScanWorker stopped")

    async def _perform_scan(self) -> None:
        try:
            stats = await self._client.get_library_statistics()
        except Exception as exc:  # pragma: no cover
            logger.error("Failed to scan Plex library: %s", exc)
            return

        artist_count = stats.get("artists", 0)
        album_count = stats.get("albums", 0)
        track_count = stats.get("tracks", 0)

        now = datetime.utcnow()
        with session_scope() as session:
            self._upsert_setting(session, "plex_artist_count", str(artist_count), now)
            self._upsert_setting(session, "plex_album_count", str(album_count), now)
            self._upsert_setting(session, "plex_track_count", str(track_count), now)
            self._upsert_setting(
                session, "plex_last_scan", now.isoformat(timespec="seconds"), now
            )
        logger.info(
            "Plex scan complete: %d artists, %d albums, %d tracks",
            artist_count,
            album_count,
            track_count,
        )

    @staticmethod
    def _upsert_setting(session, key: str, value: str, timestamp: datetime) -> None:
        setting = session.execute(
            select(Setting).where(Setting.key == key)
        ).scalar_one_or_none()
        if setting is None:
            session.add(
                Setting(
                    key=key,
                    value=value,
                    created_at=timestamp,
                    updated_at=timestamp,
                )
            )
        else:
            setting.value = value
            setting.updated_at = timestamp

===== app/workers/sync_worker.py =====
"""Background worker for processing Soulseek download jobs."""
from __future__ import annotations

import asyncio
from datetime import datetime
from typing import Any, Dict, Iterable

from app.core.soulseek_client import SoulseekClient
from app.db import session_scope
from app.logging import get_logger
from app.models import Download

logger = get_logger(__name__)

ALLOWED_STATES = {"queued", "downloading", "completed", "failed"}


class SyncWorker:
    def __init__(self, soulseek_client: SoulseekClient) -> None:
        self._client = soulseek_client
        self._queue: asyncio.Queue[Dict[str, Any]] = asyncio.Queue()
        self._task: asyncio.Task | None = None
        self._running = asyncio.Event()
        self._poll_interval = 2.0

    @property
    def queue(self) -> asyncio.Queue[Dict[str, Any]]:
        return self._queue

    def is_running(self) -> bool:
        return self._running.is_set() and self._task is not None and not self._task.done()

    async def start(self) -> None:
        if self._task is None or self._task.done():
            self._running.set()
            self._task = asyncio.create_task(self._run())

    async def stop(self) -> None:
        self._running.clear()
        if self._task:
            await self._queue.put({"_shutdown": True})
            await self._task

    async def enqueue(self, job: Dict[str, Any]) -> None:
        """Submit a download job for processing."""

        if self.is_running():
            await self._queue.put(job)
            return
        await self._process_job(job)
        await self.refresh_downloads()

    async def _run(self) -> None:
        logger.info("SyncWorker started")
        try:
            while self._running.is_set():
                job: Dict[str, Any] | None = None
                try:
                    job = await asyncio.wait_for(self._queue.get(), timeout=self._poll_interval)
                except asyncio.TimeoutError:
                    await self.refresh_downloads()
                    continue

                try:
                    if job.get("_shutdown"):
                        break
                    await self._process_job(job)
                    await self.refresh_downloads()
                except Exception as exc:  # pragma: no cover - defensive
                    logger.error("Failed to process sync job: %s", exc)
                finally:
                    self._queue.task_done()
        finally:
            self._running.clear()
            logger.info("SyncWorker stopped")

    async def _process_job(self, job: Dict[str, Any]) -> None:
        username = job.get("username")
        files = job.get("files", [])
        if not username or not files:
            logger.warning("Invalid download job received: %s", job)
            return

        try:
            await self._client.download({"username": username, "files": files})
        except Exception as exc:  # pragma: no cover - defensive
            logger.error("Failed to queue Soulseek download: %s", exc)
            self._mark_failed(files)
            raise

    async def refresh_downloads(self) -> None:
        """Poll Soulseek for download progress and persist it."""

        try:
            response = await self._client.get_download_status()
        except Exception as exc:  # pragma: no cover - defensive
            logger.warning("Unable to obtain Soulseek download status: %s", exc)
            return

        downloads: Iterable[Dict[str, Any]]
        if isinstance(response, dict):
            downloads = response.get("downloads", []) or []
        elif isinstance(response, list):
            downloads = response
        else:  # pragma: no cover - defensive
            downloads = []

        if not downloads:
            return

        with session_scope() as session:
            for payload in downloads:
                download_id = payload.get("download_id") or payload.get("id")
                if download_id is None:
                    continue

                download = session.get(Download, int(download_id))
                if download is None:
                    continue

                state = str(payload.get("state", download.state))
                if state not in ALLOWED_STATES:
                    state = download.state

                progress_value = payload.get("progress", download.progress)
                try:
                    progress = float(progress_value)
                except (TypeError, ValueError):
                    progress = download.progress

                if progress < 0:
                    progress = 0.0
                elif progress > 100:
                    progress = 100.0

                if state == "queued" and 0 < progress < 100:
                    state = "downloading"
                elif state == "completed":
                    progress = 100.0

                download.state = state
                download.progress = progress
                download.updated_at = datetime.utcnow()

    def _mark_failed(self, files: Iterable[Dict[str, Any]]) -> None:
        download_ids = []
        for file_info in files:
            identifier = file_info.get("download_id") or file_info.get("id")
            if identifier is not None:
                download_ids.append(int(identifier))

        if not download_ids:
            return

        with session_scope() as session:
            for download_id in download_ids:
                download = session.get(Download, download_id)
                if download is None:
                    continue
                download.state = "failed"
                download.updated_at = datetime.utcnow()

===== docker-compose.override.yml =====
version: "3.9"

services:
  backend:
    command: ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000", "--reload"]
    environment:
      - DATABASE_URL=sqlite:///./harmony.db
      - HARMONY_LOG_LEVEL=DEBUG

===== docker-compose.yml =====
version: "3.9"

services:
  backend:
    build: .
    container_name: harmony-backend
    environment:
      - DATABASE_URL=sqlite:///./harmony.db
      - HARMONY_LOG_LEVEL=INFO
    ports:
      - "8000:8000"
    volumes:
      - ./:/app

===== docs/api.md =====
# API-Referenz

Die folgenden Tabellen geben einen Überblick über die wichtigsten REST-Endpunkte des Harmony-Backends. Beispiel-Requests orientieren
sich an den in `app/routers` definierten Routen. Alle Antworten sind JSON-codiert.

## Spotify (`/spotify`)

| Methode | Pfad | Beschreibung |
| --- | --- | --- |
| `GET` | `/spotify/status` | Prüft, ob der Spotify-Client authentifiziert ist. |
| `GET` | `/spotify/search/tracks?query=...` | Sucht nach Tracks (weitere Endpunkte für Artists/Albums identisch). |
| `GET` | `/spotify/track/{track_id}` | Liefert Track-Details. |
| `GET` | `/spotify/audio-features/{track_id}` | Einzelne Audio-Features. |
| `GET` | `/spotify/audio-features?ids=ID1,ID2` | Mehrere Audio-Features in einem Request. |
| `GET` | `/spotify/playlists` | Listet persistierte Playlists aus der Datenbank. |
| `GET` | `/spotify/playlists/{playlist_id}/tracks` | Holt Playlist-Items (optional `limit`). |
| `POST` | `/spotify/playlists/{playlist_id}/tracks` | Fügt Tracks per URIs hinzu. |
| `DELETE` | `/spotify/playlists/{playlist_id}/tracks` | Entfernt Tracks anhand von URIs. |
| `PUT` | `/spotify/playlists/{playlist_id}/reorder` | Sortiert Playlist neu. |
| `GET` | `/spotify/me` | Gibt das Spotify-Benutzerprofil zurück. |
| `GET` | `/spotify/me/tracks` | Listet gespeicherte Tracks (`limit`). |
| `PUT`/`DELETE` | `/spotify/me/tracks` | Speichert bzw. entfernt gespeicherte Tracks (Payload: `{"ids": [...]}`). |
| `GET` | `/spotify/me/top/{type}` | Top-Tracks oder Artists. |
| `GET` | `/spotify/recommendations` | Empfehlungen anhand Seed-Parametern. |

**Beispiel:**

```http
GET /spotify/search/tracks?query=daft%20punk HTTP/1.1
Authorization: Bearer <token>
```

```json
{
  "items": [
    {
      "id": "2cGxRwrMyEAp8dEbuZaVv6",
      "name": "Harder, Better, Faster, Stronger",
      "artists": [{"name": "Daft Punk"}],
      "album": {"name": "Discovery"}
    }
  ]
}
```

## Plex (`/plex`)

| Methode | Pfad | Beschreibung |
| --- | --- | --- |
| `GET` | `/plex/status` | Liefert Sitzungen und Bibliotheksstatistiken. |
| `GET` | `/plex/library/sections` | Listet Bibliotheken (Alias: `/plex/libraries`). |
| `GET` | `/plex/library/sections/{section_id}/all` | Durchsucht eine Bibliothek (Alias: `/plex/library/{section_id}/items`). |
| `GET` | `/plex/library/metadata/{item_id}` | Metadaten für ein Item. |
| `GET` | `/plex/status/sessions` | Aktive Sessions (Alias: `/plex/sessions`). |
| `GET` | `/plex/status/sessions/history/all` | Wiedergabeverlauf (Alias: `/plex/history`). |
| `GET`/`POST` | `/plex/timeline` | Holt bzw. aktualisiert Timeline-Daten. |
| `POST` | `/plex/scrobble` / `/plex/unscrobble` | Spielposition melden. |
| `GET`/`POST`/`PUT`/`DELETE` | `/plex/playlists` | Playlist-Verwaltung. |
| `POST` | `/plex/playQueues` | Erstellt PlayQueues. |
| `GET` | `/plex/playQueues/{playqueue_id}` | Lädt eine bestehende PlayQueue. |
| `POST` | `/plex/rate` | Bewertet ein Item. |
| `POST` | `/plex/tags/{item_id}` | Synchronisiert Tags. |
| `GET` | `/plex/devices` | Verfügbare Geräte. |
| `GET` | `/plex/dvr` | DVR-Daten. |
| `GET` | `/plex/livetv` | Live-TV-Informationen. |
| `GET` | `/plex/notifications` | Server-Sent Events Stream für Plex-Benachrichtigungen. |

**Beispiel:**

```http
GET /plex/library/sections/1/all?type=10 HTTP/1.1
X-Plex-Token: <token>
```

```json
{
  "MediaContainer": {
    "Metadata": [
      {"ratingKey": "123", "title": "Discovery", "parentTitle": "Daft Punk"}
    ]
  }
}
```

## Soulseek (`/soulseek`)

| Methode | Pfad | Beschreibung |
| --- | --- | --- |
| `GET` | `/soulseek/status` | Prüft die Verbindung zum slskd-Daemon. |
| `POST` | `/soulseek/search` | Führt eine Suche aus (`{"query": "artist"}`). |
| `POST` | `/soulseek/download` | Persistiert Downloads und stößt Worker an. |
| `GET` | `/soulseek/downloads` | Liefert gespeicherte Downloads aus der DB. |
| `GET` | `/soulseek/download/{id}` | Holt Detailinformationen direkt vom Client. |
| `DELETE` | `/soulseek/download/{id}` | Bricht einen Download ab. |
| `GET` | `/soulseek/downloads/all` | Delegiert an `SoulseekClient.get_all_downloads()`. |
| `DELETE` | `/soulseek/downloads/completed` | Entfernt erledigte Downloads. |
| `GET` | `/soulseek/download/{id}/queue` | Fragt Queue-Positionen ab. |
| `POST` | `/soulseek/enqueue` | Fügt mehrere Dateien der Warteschlange hinzu. |
| `GET` | `/soulseek/uploads` | Lädt Uploads. |
| `GET` | `/soulseek/uploads/all` | Alle Uploads. |
| `DELETE` | `/soulseek/upload/{id}` | Bricht einen Upload ab. |
| `DELETE` | `/soulseek/uploads/completed` | Entfernt erledigte Uploads. |
| `GET` | `/soulseek/user/{username}/address` | IP/Port eines Benutzers. |
| `GET` | `/soulseek/user/{username}/browse` | Lädt die Verzeichnisstruktur. |
| `GET` | `/soulseek/user/{username}/directory?path=...` | Abfrage eines Unterordners. |
| `GET` | `/soulseek/user/{username}/info` | Benutzerinformationen. |
| `GET` | `/soulseek/user/{username}/status` | Online-Status. |

**Beispiel:**

```http
POST /soulseek/download HTTP/1.1
Content-Type: application/json

{
  "username": "dj_user",
  "files": [
    {"filename": "Daft Punk - Harder.mp3", "size": 5120000}
  ]
}
```

```json
{
  "status": "queued",
  "detail": {
    "downloads": [
      {"id": 1, "filename": "Daft Punk - Harder.mp3", "state": "queued", "progress": 0.0}
    ]
  }
}
```

## Matching (`/matching`)

| Methode | Pfad | Beschreibung |
| --- | --- | --- |
| `POST` | `/matching/spotify-to-plex` | Matcht einen Spotify-Track gegen Plex-Kandidaten und speichert das Ergebnis. |
| `POST` | `/matching/spotify-to-soulseek` | Bewertet Spotify vs. Soulseek-Kandidaten. |
| `POST` | `/matching/spotify-to-plex-album` | Liefert das beste Album-Match. |

**Beispiel:**

```http
POST /matching/spotify-to-plex HTTP/1.1
Content-Type: application/json

{
  "spotify_track": {"id": "2cGxRwrMyEAp8dEbuZaVv6", "name": "Harder, Better, Faster, Stronger"},
  "candidates": [
    {"id": "123", "title": "Harder Better Faster Stronger", "album": "Discovery"}
  ]
}
```

```json
{
  "best_match": {"id": "123", "title": "Harder Better Faster Stronger", "album": "Discovery"},
  "confidence": 0.98
}
```

## Settings (`/settings`)

| Methode | Pfad | Beschreibung |
| --- | --- | --- |
| `GET` | `/settings` | Liefert alle Settings als Key-Value-Map inklusive `updated_at`. |
| `POST` | `/settings` | Legt/aktualisiert einen Eintrag (`{"key": "plex_artist_count", "value": "123"}`). |
| `GET` | `/settings/history` | Zeigt die letzten 50 Änderungen mit Zeitstempel. |

## Beets (`/beets`)

| Methode | Pfad | Beschreibung |
| --- | --- | --- |
| `POST` | `/beets/import` | Führt `beet import` aus (Payload: `{"path": "/music"}`). |
| `POST` | `/beets/update` | Aktualisiert Metadaten (`beet update`). |
| `POST` | `/beets/remove` | Entfernt Items nach Query (`{"query": "artist:Daft Punk"}`). |
| `POST` | `/beets/move` | Verschiebt Dateien (optional Query). |
| `POST` | `/beets/write` | Schreibt Tags auf Basis einer Query. |
| `GET` | `/beets/albums` | Listet Albumtitel. |
| `GET` | `/beets/tracks` | Listet Tracks. |
| `GET` | `/beets/stats` | Gibt Statistiken (`beet stats`). |
| `GET` | `/beets/fields` | Zeigt verfügbare Feldnamen. |
| `POST` | `/beets/query` | Führt eine Query mit Format-String aus. |

**Beispiel:**

```http
POST /beets/query HTTP/1.1
Content-Type: application/json

{
  "query": "artist:Daft Punk",
  "format": "$artist - $album - $title"
}
```

```json
{
  "results": [
    "Daft Punk - Discovery - Harder, Better, Faster, Stronger"
  ]
}
```

===== docs/architecture.md =====
# Architekturübersicht

Die Harmony-Anwendung folgt einer modularen FastAPI-Architektur, die interne und externe Komponenten klar voneinander trennt.
Das folgende textuelle Diagramm beschreibt den Aufbau:

```
+----------------------------+
|          Clients           |
| SpotifyClient, PlexClient, |
| SoulseekClient, BeetsClient|
+-------------+--------------+
              |
              v
+-------------+--------------+
|            Core            |
| MatchingEngine, Utilities  |
+-------------+--------------+
              |
              v
+-------------+--------------+
|           Routers          |
| Spotify / Plex / Soulseek  |
| Matching / Settings / Beets|
+------+------+-------------+
       |      |
       |      v
       |   Background Workers
       |   (Sync, Matching,   
       |    Scan, Playlist)   
       v                      
+------+------+-------------+
|        Datenbank           |
| SQLAlchemy Modelle         |
+----------------------------+
```

## Komponenten im Detail

### Core

- **SpotifyClient** (`app/core/spotify_client.py`): Kapselt die Spotify Web API (Suche, Audio Features, Playlists, Empfehlungen).
- **PlexClient** (`app/core/plex_client.py`): Async-Client für Bibliotheken, Sessions, Timeline und Live-TV.
- **SoulseekClient** (`app/core/soulseek_client.py`): Bindet den slskd-Daemon an und stellt Download-/Upload-Operationen bereit.
- **BeetsClient** (`app/core/beets_client.py`): Führt Beets CLI-Kommandos innerhalb eines Threadpools aus.
- **MusicMatchingEngine** (`app/core/matching_engine.py`): Berechnet Ähnlichkeitsscores und liefert Best-Match-Kandidaten.

### Routers

FastAPI-Router bilden die öffentliche REST-API. Jeder Router importiert die benötigten Clients als Dependencies (`app/dependencies.py`).
Beispiele:

- `app/routers/spotify_router.py` für `/spotify`-Endpunkte (Suche, Audio Features, Playlists, Benutzerprofil).
- `app/routers/plex_router.py` für `/plex`-Endpunkte (Bibliotheken, PlayQueues, Benachrichtigungen).
- `app/routers/soulseek_router.py` für `/soulseek`-Endpunkte (Downloads, Uploads, Benutzerinformationen).
- `app/routers/matching_router.py` für `/matching` (Spotify→Plex/Soulseek, Album-Matching).
- `app/routers/settings_router.py` für `/settings` (Key-Value Settings + Historie).
- `app/routers/beets_router.py` für `/beets` (Import, Query, Stats, Dateimanipulation).

### Datenbank

- `app/db.py` initialisiert SQLite und stellt `session_scope()` sowie `get_session()` bereit.
- `app/models.py` definiert SQLAlchemy-Modelle wie `Playlist`, `Download`, `Match`, `Setting`, `SettingHistory`.
- `app/schemas.py` enthält die Pydantic-Modelle für Anfragen und Antworten.

### Hintergrund-Worker

Während des Startup-Events (`app/main.py`) werden – sofern `HARMONY_DISABLE_WORKERS` nicht gesetzt ist – folgende Worker gestartet:

- **SyncWorker** (`app/workers/sync_worker.py`): Verarbeitet Soulseek-Downloadjobs und aktualisiert Fortschritte.
- **MatchingWorker** (`app/workers/matching_worker.py`): Persistiert berechnete Matches asynchron.
- **ScanWorker** (`app/workers/scan_worker.py`): Pollt Plex in Intervallen und aktualisiert Statistik-Settings.
- **PlaylistSyncWorker** (`app/workers/playlist_sync_worker.py`): Synchronisiert Spotify-Playlists in die Datenbank.

Alle Worker greifen über `session_scope()` auf die Datenbank zu und protokollieren Abläufe über `app/logging.py`.

## Synchronisations- & Matching-Prozesse

1. **Soulseek-Downloads**: REST-Aufrufe gegen `/soulseek/download` persistieren Downloads in der Datenbank und übergeben Jobs an den
   `SyncWorker`. Dieser startet Downloads über den `SoulseekClient` und pollt `get_download_status()`, um Fortschritt, Status und
   Zeitstempel (`Download.updated_at`) zu aktualisieren.
2. **Spotify-Playlist-Sync**: Der `PlaylistSyncWorker` ruft periodisch `SpotifyClient.get_user_playlists()` auf, normalisiert die
   Daten und speichert sie in der `Playlist`-Tabelle. Änderungen werden über `updated_at` erfasst.
3. **Plex-Scans**: Der `ScanWorker` pollt `PlexClient.get_library_statistics()` und schreibt aggregierte Werte in `Setting`-Einträge.
4. **Matching**: Der Matching-Router kann Ergebnisse direkt persistieren. Zusätzlich verarbeitet der `MatchingWorker` Jobs aus seiner
   Queue und speichert `Match`-Objekte. Die Matching-Engine vergleicht Spotify-Tracks mit Plex- oder Soulseek-Kandidaten und liefert
   Konfidenzwerte zurück.

## Interaktion der Komponenten

- Router lösen Aktionen aus und rufen über Dependencies die passenden Core-Clients auf.
- Core-Clients kommunizieren mit externen Diensten und liefern strukturierte Antworten.
- Worker laufen asynchron und nutzen dieselben Clients, um Automatisierungen im Hintergrund auszuführen.
- Alle Schreiboperationen gehen über SQLAlchemy-Sessions, sodass API-Aufrufe und Worker auf denselben Datenbestand zugreifen.

===== docs/workers.md =====
# Hintergrund-Worker

Harmony startet beim FastAPI-Startup mehrere Hintergrundprozesse, um langlaufende Aufgaben außerhalb des Request-Kontexts zu
bearbeiten. Die Worker verwenden asynchrone Tasks (`asyncio`) und greifen über `session_scope()` auf die Datenbank zu.

## SyncWorker

- **Pfad:** `app/workers/sync_worker.py`
- **Aufgabe:** Verarbeitet Soulseek-Downloadjobs, startet Downloads über den `SoulseekClient` und aktualisiert den Fortschritt.
- **Arbeitsweise:**
  - Eingehende Jobs (Username + Datei-Metadaten) landen in einer `asyncio.Queue`.
  - Läuft der Worker, werden Jobs sequentiell aus der Queue geholt; andernfalls wird der Download sofort synchron abgewickelt.
  - Nach jedem Job wird `refresh_downloads()` aufgerufen, das `client.get_download_status()` pollt und DB-Einträge (`Download`)
    aktualisiert (Status, Fortschritt, `updated_at`).
- **Polling-Intervall:** 2 Sekunden Timeout beim Queue-Waiting; fällt kein Job an, wird in diesem Intervall der Status nachgezogen.
- **Fehlerhandling:**
  - Fehler beim Download markieren die betroffenen Einträge als `failed`.
  - Nicht erkannte Statuswerte werden verworfen, Fortschrittswerte werden auf `0…100` begrenzt.
  - Netzwerkfehler beim Status-Polling führen zu einem Warn-Log, ohne den Worker zu stoppen.

## MatchingWorker

- **Pfad:** `app/workers/matching_worker.py`
- **Aufgabe:** Nimmt Matching-Jobs (`spotify_track` + Kandidatenliste) entgegen und persistiert die besten Treffer.
- **Arbeitsweise:**
  - Verwendet eine `asyncio.Queue` und ein Flag, um Shutdowns kontrolliert zu verarbeiten.
  - Für `spotify-to-plex` ruft der Worker `MusicMatchingEngine.find_best_match()` auf.
  - Für alle anderen Jobs (z. B. `spotify-to-soulseek`) wird `calculate_slskd_match_confidence()` pro Kandidat berechnet und das
    höchste Scoring übernommen.
  - Die Ergebnisse werden als `Match`-Objekte gespeichert (`source`, `spotify_track_id`, `target_id`, `confidence`).
- **Fehlerhandling:**
  - Exceptions beim Abarbeiten werden geloggt; das Queue-Item wird dennoch als abgeschlossen markiert.
  - Ungültige Jobs (fehlende Kandidaten/Tracks) werden verworfen und mit Warnung protokolliert.

## ScanWorker

- **Pfad:** `app/workers/scan_worker.py`
- **Aufgabe:** Pollt regelmäßig Plex-Statistiken und hält aggregierte Werte in den Settings aktuell.
- **Arbeitsweise:**
  - Standardintervall: 600 Sekunden (`interval_seconds`-Parameter).
  - `get_library_statistics()` liefert Anzahl Artists/Albums/Tracks; zusätzlich wird ein Zeitstempel gesetzt.
  - Werte werden über `_upsert_setting` als `Setting`-Einträge geschrieben oder aktualisiert (`plex_artist_count`, `plex_album_count`,
    `plex_track_count`, `plex_last_scan`).
- **Fehlerhandling:**
  - Netzwerkfehler werden geloggt und führen zu keinem Update.
  - Der Worker toleriert `asyncio.CancelledError`, wenn er beim Shutdown gestoppt wird.

## Zusammenspiel der Worker

- Alle Worker werden in `app/main.py` initialisiert, sofern `HARMONY_DISABLE_WORKERS` nicht auf `1` gesetzt ist.
- Die Worker teilen sich keine gemeinsamen Datenstrukturen; Synchronisation erfolgt ausschließlich über die Datenbank.
- Beim Application-Shutdown stoppt FastAPI jeden Worker kontrolliert (`stop()`), um laufende Tasks zu beenden und Queues zu räumen.

===== requirements.txt =====
fastapi
uvicorn
sqlalchemy
aiohttp
spotipy
plexapi
pydantic
pytest
pytest-asyncio
httpx

===== tests/conftest.py =====
from __future__ import annotations

import os
from contextlib import asynccontextmanager
from pathlib import Path
from typing import Any, Dict

import sys

ROOT = Path(__file__).resolve().parents[1]
if str(ROOT) not in sys.path:
    sys.path.insert(0, str(ROOT))

import pytest
from app.db import init_db, reset_engine_for_tests
from app.dependencies import (
    get_matching_engine as dependency_matching_engine,
    get_plex_client as dependency_plex_client,
    get_soulseek_client as dependency_soulseek_client,
    get_spotify_client as dependency_spotify_client,
)
from app.main import app
from app.workers import MatchingWorker, PlaylistSyncWorker, ScanWorker, SyncWorker
from tests.simple_client import SimpleTestClient


class StubSpotifyClient:
    def __init__(self) -> None:
        self.tracks: Dict[str, Dict[str, Any]] = {
            "track-1": {"id": "track-1", "name": "Test Song", "artists": [{"name": "Tester"}], "duration_ms": 200000},
        }
        self.playlists = [
            {"id": "playlist-1", "name": "My Playlist", "tracks": {"total": 1}},
        ]
        self.audio_features: Dict[str, Dict[str, Any]] = {
            "track-1": {"id": "track-1", "danceability": 0.5},
        }
        self.playlist_items: Dict[str, Dict[str, Any]] = {
            "playlist-1": {"items": [{"track": self.tracks["track-1"]}], "total": 1}
        }
        self.saved_track_ids: set[str] = set()
        self.recommendation_payload: Dict[str, Any] = {"tracks": [], "seeds": []}

    def is_authenticated(self) -> bool:
        return True

    def search_tracks(self, query: str, limit: int = 20) -> Dict[str, Any]:
        return {"tracks": {"items": list(self.tracks.values())}}

    def search_artists(self, query: str, limit: int = 20) -> Dict[str, Any]:
        return {"artists": {"items": [{"id": "artist-1", "name": "Tester"}]}}

    def search_albums(self, query: str, limit: int = 20) -> Dict[str, Any]:
        return {"albums": {"items": [{"id": "album-1", "name": "Album", "artists": [{"name": "Tester"}]}]}}

    def get_user_playlists(self, limit: int = 50) -> Dict[str, Any]:
        return {"items": [dict(item) for item in self.playlists]}

    def get_track_details(self, track_id: str) -> Dict[str, Any]:
        return self.tracks.get(track_id, {"id": track_id, "name": "Unknown"})

    def get_audio_features(self, track_id: str) -> Dict[str, Any]:
        return self.audio_features.get(track_id, {})

    def get_multiple_audio_features(self, track_ids: list[str]) -> Dict[str, Any]:
        return {
            "audio_features": [self.audio_features.get(track_id, {"id": track_id}) for track_id in track_ids]
        }

    def get_playlist_items(self, playlist_id: str, limit: int = 100) -> Dict[str, Any]:
        return self.playlist_items.get(playlist_id, {"items": [], "total": 0})

    def add_tracks_to_playlist(self, playlist_id: str, track_uris: list[str]) -> Dict[str, Any]:
        playlist = self.playlist_items.setdefault(playlist_id, {"items": [], "total": 0})
        for uri in track_uris:
            playlist["items"].append({"track": {"uri": uri}})
        playlist["total"] = len(playlist["items"])
        return {"snapshot_id": "mock"}

    def remove_tracks_from_playlist(self, playlist_id: str, track_uris: list[str]) -> Dict[str, Any]:
        playlist = self.playlist_items.setdefault(playlist_id, {"items": [], "total": 0})
        playlist["items"] = [
            item for item in playlist["items"] if item.get("track", {}).get("uri") not in set(track_uris)
        ]
        playlist["total"] = len(playlist["items"])
        return {"snapshot_id": "mock"}

    def reorder_playlist_items(
        self, playlist_id: str, range_start: int, insert_before: int
    ) -> Dict[str, Any]:
        playlist = self.playlist_items.setdefault(playlist_id, {"items": [], "total": 0})
        items = playlist["items"]
        if 0 <= range_start < len(items):
            track = items.pop(range_start)
            insert_index = max(0, min(insert_before, len(items)))
            items.insert(insert_index, track)
        playlist["items"] = items
        return {"snapshot_id": "reordered"}

    def get_saved_tracks(self, limit: int = 20) -> Dict[str, Any]:
        saved_items = [
            {"track": self.tracks.get(track_id, {"id": track_id})}
            for track_id in list(self.saved_track_ids)[:limit]
        ]
        return {"items": saved_items, "total": len(self.saved_track_ids)}

    def save_tracks(self, track_ids: list[str]) -> Dict[str, Any]:
        self.saved_track_ids.update(track_ids)
        return {"saved": sorted(self.saved_track_ids)}

    def remove_saved_tracks(self, track_ids: list[str]) -> Dict[str, Any]:
        for track_id in track_ids:
            self.saved_track_ids.discard(track_id)
        return {"saved": sorted(self.saved_track_ids)}

    def get_current_user(self) -> Dict[str, Any]:
        return {"id": "user-1", "display_name": "Harmony Tester"}

    def get_top_tracks(self, limit: int = 20) -> Dict[str, Any]:
        return {"items": list(self.tracks.values())[:limit]}

    def get_top_artists(self, limit: int = 20) -> Dict[str, Any]:
        return {"items": [{"id": "artist-1", "name": "Tester"}]}

    def get_recommendations(
        self,
        seed_tracks: list[str] | None = None,
        seed_artists: list[str] | None = None,
        seed_genres: list[str] | None = None,
        limit: int = 20,
    ) -> Dict[str, Any]:
        payload = dict(self.recommendation_payload)
        payload.setdefault("tracks", [])
        payload.setdefault("seeds", [])
        return payload


class StubPlexClient:
    def __init__(self) -> None:
        self.libraries = {
            "MediaContainer": {
                "Directory": [
                    {"key": "1", "type": "artist", "title": "Music"},
                ]
            }
        }
        self.library_items = {
            ("1", "10"): {
                "MediaContainer": {"totalSize": 2, "Metadata": [{"ratingKey": "a"}, {"ratingKey": "b"}]}
            },
            ("1", "9"): {
                "MediaContainer": {"totalSize": 3, "Metadata": [{"ratingKey": "a"}]}
            },
            ("1", "8"): {
                "MediaContainer": {"totalSize": 5, "Metadata": [{"ratingKey": "t"}]}
            },
        }
        self.metadata = {"100": {"title": "Test Item", "year": 2020}}
        self.sessions = {"MediaContainer": {"size": 1, "Metadata": [{"title": "Session"}]}}
        self.session_history = {"MediaContainer": {"size": 1, "Metadata": [{"title": "History"}]}}
        self.playlists = {"MediaContainer": {"size": 1, "Metadata": [{"title": "Playlist"}]}}
        self.created_playlists: list[dict[str, Any]] = []
        self.playqueues: Dict[str, Any] = {}
        self.timeline_updates: list[dict[str, Any]] = []
        self.scrobbles: list[dict[str, Any]] = []
        self.unscrobbles: list[dict[str, Any]] = []
        self.ratings: list[dict[str, Any]] = []
        self.tags: Dict[str, Dict[str, list[str]]] = {}
        self.devices = {"MediaContainer": {"Device": [{"name": "Player"}]}}
        self.dvr = {"MediaContainer": {"Directory": [{"name": "DVR"}]}}
        self.livetv = {"MediaContainer": {"Directory": [{"name": "Channel"}]}}

    async def get_sessions(self) -> Dict[str, Any]:
        return self.sessions

    async def get_library_statistics(self) -> Dict[str, int]:
        return {"artists": 2, "albums": 3, "tracks": 5}

    async def get_libraries(self, params: Dict[str, Any] | None = None) -> Dict[str, Any]:
        return self.libraries

    async def get_library_items(self, section_id: str, params: Dict[str, Any] | None = None) -> Dict[str, Any]:
        type_value = (params or {}).get("type", "")
        return self.library_items.get((section_id, type_value), {"MediaContainer": {"Metadata": []}})

    async def get_metadata(self, item_id: str) -> Dict[str, Any]:
        return self.metadata[item_id]

    async def get_session_history(self, params: Dict[str, Any] | None = None) -> Dict[str, Any]:
        return self.session_history

    async def get_timeline(self, params: Dict[str, Any] | None = None) -> Dict[str, Any]:
        return {"timeline": params or {}}

    async def update_timeline(self, data: Dict[str, Any]) -> str:
        self.timeline_updates.append(data)
        return "ok"

    async def scrobble(self, data: Dict[str, Any]) -> str:
        self.scrobbles.append(data)
        return "ok"

    async def unscrobble(self, data: Dict[str, Any]) -> str:
        self.unscrobbles.append(data)
        return "ok"

    async def get_playlists(self) -> Dict[str, Any]:
        return self.playlists

    async def create_playlist(self, payload: Dict[str, Any]) -> Dict[str, Any]:
        self.created_playlists.append(payload)
        return {"status": "created", "payload": payload}

    async def update_playlist(self, playlist_id: str, payload: Dict[str, Any]) -> Dict[str, Any]:
        return {"status": "updated", "id": playlist_id, "payload": payload}

    async def delete_playlist(self, playlist_id: str) -> Dict[str, Any]:
        return {"status": "deleted", "id": playlist_id}

    async def create_playqueue(self, payload: Dict[str, Any]) -> Dict[str, Any]:
        identifier = str(len(self.playqueues) + 1)
        self.playqueues[identifier] = payload
        return {"playQueueID": identifier, "payload": payload}

    async def get_playqueue(self, playqueue_id: str) -> Dict[str, Any]:
        return self.playqueues.get(playqueue_id, {})

    async def rate_item(self, item_id: str, rating: int) -> str:
        self.ratings.append({"key": item_id, "rating": rating})
        return "ok"

    async def sync_tags(self, item_id: str, tags: Dict[str, list[str]]) -> Dict[str, Any]:
        self.tags[item_id] = tags
        return {"status": "tags-updated", "id": item_id, "tags": tags}

    async def get_devices(self) -> Dict[str, Any]:
        return self.devices

    async def get_dvr(self) -> Dict[str, Any]:
        return self.dvr

    async def get_live_tv(self, params: Dict[str, Any] | None = None) -> Dict[str, Any]:
        return self.livetv

    @asynccontextmanager
    async def listen_notifications(self):  # pragma: no cover - exercised via tests
        class _Message:
            def __init__(self) -> None:
                self.type = type("Type", (), {"name": "TEXT"})
                self.data = "event"

        class _Websocket:
            def __init__(self) -> None:
                self._sent = False

            def exception(self):
                return None

            def __aiter__(self):
                return self

            async def __anext__(self):
                if self._sent:
                    raise StopAsyncIteration
                self._sent = True
                return _Message()

        yield _Websocket()


class StubSoulseekClient:
    def __init__(self) -> None:
        self.downloads: Dict[int, Dict[str, Any]] = {}
        self.queue_positions: Dict[int, Dict[str, Any]] = {}
        self.uploads: Dict[str, Dict[str, Any]] = {
            "up-1": {"id": "up-1", "filename": "upload.flac", "state": "uploading", "progress": 40.0},
            "up-2": {"id": "up-2", "filename": "done.flac", "state": "completed", "progress": 100.0},
        }
        self.enqueued: list[Dict[str, Any]] = []
        self.user_records: Dict[str, Dict[str, Any]] = {
            "tester": {
                "address": {"host": "127.0.0.1", "port": 2234},
                "browse": {"files": ["song.mp3"]},
                "browsing-status": {"state": "idle"},
                "directory": {"path": "", "files": []},
                "info": {"username": "tester", "slots": 3},
                "status": {"online": True},
            }
        }

    async def get_download_status(self) -> Dict[str, Any]:
        return {"downloads": list(self.downloads.values())}

    async def search(self, query: str) -> Dict[str, Any]:
        return {"results": [query]}

    async def download(self, payload: Dict[str, Any]) -> Dict[str, Any]:
        for file_info in payload.get("files", []):
            identifier = int(file_info.get("download_id", 0))
            if identifier <= 0:
                continue
            entry = {
                "id": identifier,
                "filename": file_info.get("filename", "unknown"),
                "progress": 0.0,
                "state": "queued",
            }
            self.downloads[identifier] = entry
        return {"status": "queued"}

    async def cancel_download(self, download_id: str) -> Dict[str, Any]:
        identifier = int(download_id)
        if identifier in self.downloads:
            self.downloads[identifier]["state"] = "failed"
        return {"cancelled": download_id}

    async def get_download(self, download_id: str) -> Dict[str, Any]:
        identifier = int(download_id)
        return self.downloads.get(identifier, {"id": identifier, "state": "unknown"})

    async def get_all_downloads(self) -> list[Dict[str, Any]]:
        return list(self.downloads.values())

    async def remove_completed_downloads(self) -> Dict[str, Any]:
        before = len(self.downloads)
        self.downloads = {k: v for k, v in self.downloads.items() if v.get("state") != "completed"}
        removed = before - len(self.downloads)
        return {"removed": removed}

    async def get_queue_position(self, download_id: str) -> Dict[str, Any]:
        identifier = int(download_id)
        return self.queue_positions.get(identifier, {"position": None})

    async def enqueue(self, username: str, files: list[Dict[str, Any]]) -> Dict[str, Any]:
        job = {"username": username, "files": files}
        self.enqueued.append(job)
        return {"status": "enqueued", "job": job}

    async def cancel_upload(self, upload_id: str) -> Dict[str, Any]:
        upload = self.uploads.get(upload_id)
        if upload:
            upload["state"] = "cancelled"
        return {"cancelled": upload_id}

    async def get_upload(self, upload_id: str) -> Dict[str, Any]:
        return self.uploads.get(upload_id, {"id": upload_id, "state": "unknown"})

    async def get_uploads(self) -> list[Dict[str, Any]]:
        return [upload for upload in self.uploads.values() if upload.get("state") != "completed"]

    async def get_all_uploads(self) -> list[Dict[str, Any]]:
        return list(self.uploads.values())

    async def remove_completed_uploads(self) -> Dict[str, Any]:
        before = len(self.uploads)
        self.uploads = {k: v for k, v in self.uploads.items() if v.get("state") != "completed"}
        removed = before - len(self.uploads)
        return {"removed": removed}

    async def user_address(self, username: str) -> Dict[str, Any]:
        record = self.user_records.get(username, {})
        return record.get("address", {"host": None, "port": None})

    async def user_browse(self, username: str) -> Dict[str, Any]:
        record = self.user_records.get(username, {})
        return record.get("browse", {"files": []})

    async def user_browsing_status(self, username: str) -> Dict[str, Any]:
        record = self.user_records.get(username, {})
        return record.get("browsing-status", {"state": "unknown"})

    async def user_directory(self, username: str, path: str) -> Dict[str, Any]:
        record = self.user_records.setdefault(username, {})
        directory = record.get("directory", {"path": path, "files": []})
        directory = dict(directory)
        directory["path"] = path
        return directory

    async def user_info(self, username: str) -> Dict[str, Any]:
        record = self.user_records.get(username, {})
        return record.get("info", {"username": username})

    async def user_status(self, username: str) -> Dict[str, Any]:
        record = self.user_records.get(username, {})
        return record.get("status", {"online": False})

    def set_status(
        self,
        download_id: int,
        *,
        progress: float | None = None,
        state: str | None = None,
    ) -> None:
        entry = self.downloads.setdefault(
            download_id,
            {
                "id": download_id,
                "filename": f"download-{download_id}",
                "progress": 0.0,
                "state": "queued",
            },
        )
        if progress is not None:
            entry["progress"] = progress
        if state is not None:
            entry["state"] = state


@pytest.fixture(autouse=True)
def configure_environment(monkeypatch: pytest.MonkeyPatch) -> None:
    monkeypatch.setenv("HARMONY_DISABLE_WORKERS", "1")
    monkeypatch.setenv("DATABASE_URL", "sqlite:///./test.db")
    reset_engine_for_tests()
    db_path = Path("test.db")
    if db_path.exists():
        db_path.unlink()
    init_db()
    yield


@pytest.fixture
def client(monkeypatch: pytest.MonkeyPatch) -> SimpleTestClient:
    stub_spotify = StubSpotifyClient()
    stub_plex = StubPlexClient()
    stub_soulseek = StubSoulseekClient()
    engine = dependency_matching_engine()

    async def noop_start(self) -> None:  # type: ignore[override]
        return None

    async def noop_stop(self) -> None:  # type: ignore[override]
        return None

    # Prevent worker tasks during tests
    monkeypatch.setattr(SyncWorker, "start", noop_start)
    monkeypatch.setattr(MatchingWorker, "start", noop_start)
    monkeypatch.setattr(ScanWorker, "start", noop_start)
    monkeypatch.setattr(PlaylistSyncWorker, "start", noop_start)
    monkeypatch.setattr(SyncWorker, "stop", noop_stop)
    monkeypatch.setattr(MatchingWorker, "stop", noop_stop)
    monkeypatch.setattr(ScanWorker, "stop", noop_stop)
    monkeypatch.setattr(PlaylistSyncWorker, "stop", noop_stop)

    from app import dependencies as deps

    monkeypatch.setattr(deps, "get_spotify_client", lambda: stub_spotify)
    monkeypatch.setattr(deps, "get_plex_client", lambda: stub_plex)
    monkeypatch.setattr(deps, "get_soulseek_client", lambda: stub_soulseek)
    monkeypatch.setattr(deps, "get_matching_engine", lambda: engine)

    app.dependency_overrides[dependency_spotify_client] = lambda: stub_spotify
    app.dependency_overrides[dependency_plex_client] = lambda: stub_plex
    app.dependency_overrides[dependency_soulseek_client] = lambda: stub_soulseek
    app.dependency_overrides[dependency_matching_engine] = lambda: engine

    app.state.soulseek_stub = stub_soulseek
    app.state.plex_stub = stub_plex
    app.state.spotify_stub = stub_spotify
    app.state.sync_worker = SyncWorker(stub_soulseek)
    app.state.playlist_worker = PlaylistSyncWorker(stub_spotify, interval_seconds=0.1)

    with SimpleTestClient(app) as test_client:
        yield test_client

    app.dependency_overrides.clear()

===== tests/simple_client.py =====
from __future__ import annotations

import asyncio
import json
from types import TracebackType
from typing import Any, Dict, Optional, Type
from urllib.parse import urlencode

from fastapi import FastAPI


class SimpleResponse:
    def __init__(self, status_code: int, body: bytes, headers: Dict[str, str]) -> None:
        self.status_code = status_code
        self._body = body
        self.headers = headers

    def json(self) -> Any:
        if not self._body:
            return None
        return json.loads(self._body.decode("utf-8"))


class SimpleTestClient:
    def __init__(self, app: FastAPI) -> None:
        self.app = app
        self._loop = asyncio.new_event_loop()
        self._previous_loop: Optional[asyncio.AbstractEventLoop] = None

    def __enter__(self) -> "SimpleTestClient":
        try:
            self._previous_loop = asyncio.get_event_loop()
        except RuntimeError:
            self._previous_loop = None
        asyncio.get_event_loop_policy().set_event_loop(self._loop)
        self._loop.run_until_complete(self.app.router.startup())
        return self

    def __exit__(
        self,
        exc_type: Optional[Type[BaseException]],
        exc: Optional[BaseException],
        tb: Optional[TracebackType],
    ) -> None:
        self._loop.run_until_complete(self.app.router.shutdown())
        self._loop.close()
        if self._previous_loop is not None:
            asyncio.get_event_loop_policy().set_event_loop(self._previous_loop)

    def get(self, path: str, params: Optional[Dict[str, Any]] = None) -> SimpleResponse:
        return self._loop.run_until_complete(self._request("GET", path, params=params))

    def post(
        self,
        path: str,
        json_body: Optional[Dict[str, Any]] = None,
        json: Optional[Dict[str, Any]] = None,
    ) -> SimpleResponse:
        payload = json_body if json_body is not None else json
        return self._loop.run_until_complete(self._request("POST", path, json_body=payload))

    def put(self, path: str, json: Optional[Dict[str, Any]] = None) -> SimpleResponse:
        return self._loop.run_until_complete(self._request("PUT", path, json_body=json))

    def delete(self, path: str, json: Optional[Dict[str, Any]] = None) -> SimpleResponse:
        return self._loop.run_until_complete(self._request("DELETE", path, json_body=json))

    async def _request(
        self,
        method: str,
        path: str,
        params: Optional[Dict[str, Any]] = None,
        json_body: Optional[Dict[str, Any]] = None,
    ) -> SimpleResponse:
        query_string = urlencode(params or {})
        scope = {
            "type": "http",
            "http_version": "1.1",
            "method": method,
            "path": path,
            "raw_path": path.encode("utf-8"),
            "query_string": query_string.encode("utf-8"),
            "headers": [],
        }

        body = b""
        if json_body is not None:
            body = json.dumps(json_body).encode("utf-8")
            scope["headers"].append((b"content-type", b"application/json"))

        response_body = bytearray()
        response_headers: Dict[str, str] = {}
        status_code = 500
        request_complete = False

        async def receive() -> Dict[str, Any]:
            nonlocal request_complete
            if request_complete:
                return {"type": "http.disconnect"}
            request_complete = True
            return {"type": "http.request", "body": body, "more_body": False}

        async def send(message: Dict[str, Any]) -> None:
            nonlocal status_code, response_headers
            if message["type"] == "http.response.start":
                status_code = message["status"]
                response_headers = {key.decode(): value.decode() for key, value in message.get("headers", [])}
            elif message["type"] == "http.response.body":
                response_body.extend(message.get("body", b""))

        await self.app(scope, receive, send)
        return SimpleResponse(status_code, bytes(response_body), response_headers)

===== tests/test_beets.py =====
from __future__ import annotations

import subprocess
from pathlib import Path
from typing import Sequence
from unittest.mock import AsyncMock, MagicMock, patch

import pytest

from fastapi import FastAPI
from fastapi.testclient import TestClient

from app.core.beets_client import BeetsClient, BeetsClientError
from app.routers import beets_router


@pytest.fixture()
def api_client() -> TestClient:
    app = FastAPI()
    app.include_router(beets_router.router, prefix="/beets")
    return TestClient(app)


def _completed(args: Sequence[str], stdout: str = "") -> subprocess.CompletedProcess[str]:
    return subprocess.CompletedProcess(args=list(args), returncode=0, stdout=stdout, stderr="")


DEFAULT_RUN_KWARGS = {
    "capture_output": True,
    "text": True,
    "check": True,
    "timeout": 60.0,
}


def _assert_run_called(
    mock_run: MagicMock,
    expected_args: Sequence[str],
    *,
    env: dict | None = None,
) -> None:
    mock_run.assert_called_once()
    args, kwargs = mock_run.call_args
    assert list(args[0]) == list(expected_args)
    expected_kwargs = dict(DEFAULT_RUN_KWARGS)
    if env is not None:
        expected_kwargs["env"] = env
    assert kwargs == expected_kwargs


class TestImportFile:
    @patch("app.core.beets_client.subprocess.run")
    def test_success(self, mock_run: MagicMock) -> None:
        mock_run.return_value = _completed(["beet", "import", "-q", "track.mp3"], "imported\n")

        client = BeetsClient()

        result = client.import_file("track.mp3")

        assert result == "imported"
        _assert_run_called(mock_run, ["beet", "import", "-q", "track.mp3"])

    @patch("app.core.beets_client.subprocess.run")
    def test_options(self, mock_run: MagicMock) -> None:
        mock_run.return_value = _completed(["beet", "import", "-A", "file.mp3"])

        client = BeetsClient()

        client.import_file(Path("file.mp3"), quiet=False, autotag=False)

        _assert_run_called(mock_run, ["beet", "import", "-A", "file.mp3"])

    @patch("app.core.beets_client.subprocess.run")
    def test_called_process_error(self, mock_run: MagicMock) -> None:
        mock_run.side_effect = subprocess.CalledProcessError(
            1, ["beet", "import"], stderr="boom"
        )

        client = BeetsClient()

        with pytest.raises(BeetsClientError):
            client.import_file("track.mp3")

    @patch("app.core.beets_client.subprocess.run")
    def test_unexpected_error(self, mock_run: MagicMock) -> None:
        mock_run.side_effect = OSError("missing beet")

        client = BeetsClient()

        with pytest.raises(BeetsClientError):
            client.import_file("track.mp3")


class TestUpdate:
    @patch("app.core.beets_client.subprocess.run")
    def test_success(self, mock_run: MagicMock) -> None:
        mock_run.return_value = _completed(["beet", "update"], "done\n")

        client = BeetsClient()

        result = client.update()

        assert result == "done"
        _assert_run_called(mock_run, ["beet", "update"])

    @patch("app.core.beets_client.subprocess.run")
    def test_with_path(self, mock_run: MagicMock) -> None:
        mock_run.return_value = _completed(["beet", "update", "/library"])

        client = BeetsClient()

        client.update("/library")

        _assert_run_called(mock_run, ["beet", "update", "/library"])

    @patch("app.core.beets_client.subprocess.run")
    def test_failure(self, mock_run: MagicMock) -> None:
        mock_run.side_effect = subprocess.CalledProcessError(1, ["beet", "update"])

        client = BeetsClient()

        with pytest.raises(BeetsClientError):
            client.update()


class TestListAlbums:
    @patch("app.core.beets_client.subprocess.run")
    def test_success(self, mock_run: MagicMock) -> None:
        mock_run.return_value = _completed(["beet", "ls", "-a"], "One\nTwo\n")

        client = BeetsClient()

        result = client.list_albums()

        assert result == ["One", "Two"]
        _assert_run_called(mock_run, ["beet", "ls", "-a"])

    @patch("app.core.beets_client.subprocess.run")
    def test_failure(self, mock_run: MagicMock) -> None:
        mock_run.side_effect = subprocess.CalledProcessError(1, ["beet", "ls", "-a"])

        client = BeetsClient()

        with pytest.raises(BeetsClientError):
            client.list_albums()


class TestListTracks:
    @patch("app.core.beets_client.subprocess.run")
    def test_success(self, mock_run: MagicMock) -> None:
        mock_run.return_value = _completed([
            "beet",
            "ls",
            "-f",
            "$title",
        ], "Foo\nBar\n")

        client = BeetsClient()

        result = client.list_tracks()

        assert result == ["Foo", "Bar"]
        _assert_run_called(mock_run, ["beet", "ls", "-f", "$title"])

    @patch("app.core.beets_client.subprocess.run")
    def test_failure(self, mock_run: MagicMock) -> None:
        mock_run.side_effect = subprocess.CalledProcessError(
            1, ["beet", "ls", "-f", "$title"]
        )

        client = BeetsClient()

        with pytest.raises(BeetsClientError):
            client.list_tracks()


class TestStats:
    @patch("app.core.beets_client.subprocess.run")
    def test_success(self, mock_run: MagicMock) -> None:
        mock_run.return_value = _completed(["beet", "stats"], "tracks: 42\n")

        client = BeetsClient()

        result = client.stats()

        assert result == {"tracks": "42"}
        _assert_run_called(mock_run, ["beet", "stats"])

    @patch("app.core.beets_client.subprocess.run")
    def test_failure(self, mock_run: MagicMock) -> None:
        mock_run.side_effect = subprocess.CalledProcessError(1, ["beet", "stats"])

        client = BeetsClient()

        with pytest.raises(BeetsClientError):
            client.stats()

    @patch("app.core.beets_client.subprocess.run")
    def test_timeout(self, mock_run: MagicMock) -> None:
        mock_run.side_effect = subprocess.TimeoutExpired(
            cmd=["beet", "stats"], timeout=60.0
        )

        client = BeetsClient()

        with pytest.raises(BeetsClientError) as exc:
            client.stats()

        assert str(exc.value) == "Command timed out"


class TestAvailability:
    @patch("app.core.beets_client.subprocess.run")
    def test_available(self, mock_run: MagicMock) -> None:
        mock_run.return_value = _completed(["beet", "version"], "beets 1.6\n")

        client = BeetsClient()

        assert client.is_available() is True
        _assert_run_called(mock_run, ["beet", "version"])

    @patch("app.core.beets_client.subprocess.run")
    def test_not_available(self, mock_run: MagicMock) -> None:
        mock_run.side_effect = subprocess.CalledProcessError(1, ["beet", "version"])

        client = BeetsClient()

        assert client.is_available() is False


class TestRemove:
    @patch("app.core.beets_client.subprocess.run")
    def test_success(self, mock_run: MagicMock) -> None:
        mock_run.return_value = _completed(
            ["beet", "remove", "genre:rock"], "Removed 2 items\n"
        )

        client = BeetsClient()

        result = client.remove("genre:rock")

        assert result == {"success": True, "removed": 2}
        _assert_run_called(mock_run, ["beet", "remove", "genre:rock"])

    @patch("app.core.beets_client.subprocess.run")
    def test_force(self, mock_run: MagicMock) -> None:
        mock_run.return_value = _completed([
            "beet",
            "remove",
            "-f",
            "genre:rock",
            "year:2020",
        ], "Removed 10 items\n")

        client = BeetsClient()

        result = client.remove("genre:rock year:2020", force=True)

        assert result == {"success": True, "removed": 10}
        _assert_run_called(
            mock_run,
            ["beet", "remove", "-f", "genre:rock", "year:2020"],
        )

    @patch("app.core.beets_client.subprocess.run")
    def test_failure(self, mock_run: MagicMock) -> None:
        mock_run.side_effect = subprocess.CalledProcessError(
            1, ["beet", "remove", "genre:rock"], stderr="error"
        )

        client = BeetsClient()

        with pytest.raises(BeetsClientError):
            client.remove("genre:rock")

    @patch("app.core.beets_client.subprocess.run")
    def test_timeout(self, mock_run: MagicMock) -> None:
        mock_run.side_effect = subprocess.TimeoutExpired(
            cmd=["beet", "remove"], timeout=60.0
        )

        client = BeetsClient()

        with pytest.raises(BeetsClientError) as exc:
            client.remove("genre:rock")

        assert str(exc.value) == "Command timed out"

    def test_empty_query(self) -> None:
        client = BeetsClient()

        with pytest.raises(BeetsClientError):
            client.remove(" ")


class TestMove:
    @patch("app.core.beets_client.subprocess.run")
    def test_without_query(self, mock_run: MagicMock) -> None:
        mock_run.return_value = _completed(["beet", "move"], "Moved 5 items\n")

        client = BeetsClient()

        result = client.move()

        assert result == {"success": True, "moved": 5}
        _assert_run_called(mock_run, ["beet", "move"])

    @patch("app.core.beets_client.subprocess.run")
    def test_with_query(self, mock_run: MagicMock) -> None:
        mock_run.return_value = _completed(
            ["beet", "move", "artist:Radiohead"], "Moved 1 items\n"
        )

        client = BeetsClient()

        result = client.move("artist:Radiohead")

        assert result == {"success": True, "moved": 1}
        _assert_run_called(mock_run, ["beet", "move", "artist:Radiohead"])

    @patch("app.core.beets_client.subprocess.run")
    def test_failure(self, mock_run: MagicMock) -> None:
        mock_run.side_effect = subprocess.CalledProcessError(
            1, ["beet", "move"], stderr="fail"
        )

        client = BeetsClient()

        with pytest.raises(BeetsClientError):
            client.move()

    @patch("app.core.beets_client.subprocess.run")
    def test_timeout(self, mock_run: MagicMock) -> None:
        mock_run.side_effect = subprocess.TimeoutExpired(
            cmd=["beet", "move"], timeout=60.0
        )

        client = BeetsClient()

        with pytest.raises(BeetsClientError) as exc:
            client.move()

        assert str(exc.value) == "Command timed out"


class TestWrite:
    @patch("app.core.beets_client.subprocess.run")
    def test_without_query(self, mock_run: MagicMock) -> None:
        mock_run.return_value = _completed(["beet", "write"], "Wrote 4 items\n")

        client = BeetsClient()

        result = client.write()

        assert result == {"success": True, "written": 4}
        _assert_run_called(mock_run, ["beet", "write"])

    @patch("app.core.beets_client.subprocess.run")
    def test_with_query(self, mock_run: MagicMock) -> None:
        mock_run.return_value = _completed(
            ["beet", "write", "year:2020"], "No changes"
        )

        client = BeetsClient()

        result = client.write("year:2020")

        assert result == {"success": True, "output": "No changes"}
        _assert_run_called(mock_run, ["beet", "write", "year:2020"])

    @patch("app.core.beets_client.subprocess.run")
    def test_failure(self, mock_run: MagicMock) -> None:
        mock_run.side_effect = subprocess.CalledProcessError(
            1, ["beet", "write"], stderr="fail"
        )

        client = BeetsClient()

        with pytest.raises(BeetsClientError):
            client.write()

    @patch("app.core.beets_client.subprocess.run")
    def test_timeout(self, mock_run: MagicMock) -> None:
        mock_run.side_effect = subprocess.TimeoutExpired(
            cmd=["beet", "write"], timeout=60.0
        )

        client = BeetsClient()

        with pytest.raises(BeetsClientError) as exc:
            client.write()

        assert str(exc.value) == "Command timed out"


class TestFields:
    @patch("app.core.beets_client.subprocess.run")
    def test_fields(self, mock_run: MagicMock) -> None:
        mock_run.return_value = _completed([
            "beet",
            "fields",
        ], "artist\nalbum\n")

        client = BeetsClient()

        result = client.fields()

        assert result == ["artist", "album"]
        _assert_run_called(mock_run, ["beet", "fields"])

    @patch("app.core.beets_client.subprocess.run")
    def test_failure(self, mock_run: MagicMock) -> None:
        mock_run.side_effect = subprocess.CalledProcessError(
            1, ["beet", "fields"], stderr="oops"
        )

        client = BeetsClient()

        with pytest.raises(BeetsClientError):
            client.fields()

    @patch("app.core.beets_client.subprocess.run")
    def test_timeout(self, mock_run: MagicMock) -> None:
        mock_run.side_effect = subprocess.TimeoutExpired(
            cmd=["beet", "fields"], timeout=60.0
        )

        client = BeetsClient()

        with pytest.raises(BeetsClientError) as exc:
            client.fields()

        assert str(exc.value) == "Command timed out"


class TestQuery:
    @patch("app.core.beets_client.subprocess.run")
    def test_query(self, mock_run: MagicMock) -> None:
        mock_run.return_value = _completed([
            "beet",
            "ls",
            "-f",
            "$artist - $title",
            "genre:rock",
            "year:1990",
        ], "Artist - Song\n")

        client = BeetsClient()

        result = client.query("genre:rock year:1990", fmt="$artist - $title")

        assert result == ["Artist - Song"]
        _assert_run_called(
            mock_run,
            [
                "beet",
                "ls",
                "-f",
                "$artist - $title",
                "genre:rock",
                "year:1990",
            ],
        )

    def test_invalid_query(self) -> None:
        client = BeetsClient()

        with pytest.raises(BeetsClientError):
            client.query("\"")

    @patch("app.core.beets_client.subprocess.run")
    def test_failure(self, mock_run: MagicMock) -> None:
        mock_run.side_effect = subprocess.CalledProcessError(
            1, ["beet", "ls"], stderr="boom"
        )

        client = BeetsClient()

        with pytest.raises(BeetsClientError):
            client.query("genre:rock")

    @patch("app.core.beets_client.subprocess.run")
    def test_timeout(self, mock_run: MagicMock) -> None:
        mock_run.side_effect = subprocess.TimeoutExpired(
            cmd=["beet", "ls"], timeout=60.0
        )

        client = BeetsClient()

        with pytest.raises(BeetsClientError) as exc:
            client.query("genre:rock")

        assert str(exc.value) == "Command timed out"


class TestEnvironment:
    @patch("app.core.beets_client.subprocess.run")
    def test_env_passed(self, mock_run: MagicMock) -> None:
        mock_run.return_value = _completed(["beet", "stats"], "")

        client = BeetsClient(env={"BEETSDIR": "/tmp/beets"})

        client.stats()

        mock_run.assert_called_once()
        _, kwargs = mock_run.call_args
        assert kwargs["env"]["BEETSDIR"] == "/tmp/beets"
        assert kwargs["timeout"] == 60.0


class TestRouterImport:
    @patch("app.routers.beets_router.run_in_threadpool", new_callable=AsyncMock)
    def test_import_options(self, mock_pool: AsyncMock, api_client: TestClient) -> None:
        mock_pool.return_value = "Imported"

        response = api_client.post(
            "/beets/import",
            json={"path": "music", "quiet": False, "autotag": False},
        )

        assert response.status_code == 200
        assert response.json() == {"success": True, "message": "Imported"}
        mock_pool.assert_awaited_once()
        call_args = mock_pool.await_args
        method = call_args.args[0]
        assert method.__self__ is beets_router.beets_client
        assert method.__name__ == "import_file"
        assert call_args.args[1] == "music"
        assert call_args.kwargs == {"quiet": False, "autotag": False}


class TestRouterRemove:
    @patch("app.routers.beets_router.run_in_threadpool", new_callable=AsyncMock)
    def test_remove(self, mock_pool: AsyncMock, api_client: TestClient) -> None:
        mock_pool.return_value = {"success": True, "removed": 5}

        response = api_client.post(
            "/beets/remove",
            json={"query": "artist:Metallica year:1986", "force": True},
        )

        assert response.status_code == 200
        assert response.json() == {"success": True, "removed": 5}
        mock_pool.assert_awaited_once()
        call_args = mock_pool.await_args
        method = call_args.args[0]
        assert method.__self__ is beets_router.beets_client
        assert method.__name__ == "remove"
        assert call_args.args[1:] == ("artist:Metallica year:1986",)
        assert call_args.kwargs == {"force": True}

    @patch("app.routers.beets_router.run_in_threadpool", new_callable=AsyncMock)
    def test_remove_invalid_query(self, mock_pool: AsyncMock, api_client: TestClient) -> None:
        mock_pool.side_effect = BeetsClientError("Invalid query syntax: missing quote")

        response = api_client.post(
            "/beets/remove",
            json={"query": "artist:'Bad", "force": False},
        )

        assert response.status_code == 400
        assert response.json()["detail"] == "Invalid query syntax"

    def test_remove_empty_query(self, api_client: TestClient) -> None:
        response = api_client.post("/beets/remove", json={"query": ""})

        assert response.status_code == 400
        assert response.json()["detail"] == "Query must not be empty"


class TestRouterMove:
    @patch("app.routers.beets_router.run_in_threadpool", new_callable=AsyncMock)
    def test_move_with_query(self, mock_pool: AsyncMock, api_client: TestClient) -> None:
        mock_pool.return_value = {"success": True, "moved": 2}

        response = api_client.post(
            "/beets/move",
            json={"query": "artist:Radiohead"},
        )

        assert response.status_code == 200
        assert response.json() == {"success": True, "moved": 2}
        mock_pool.assert_awaited_once()
        call_args = mock_pool.await_args
        method = call_args.args[0]
        assert method.__self__ is beets_router.beets_client
        assert method.__name__ == "move"
        assert call_args.args[1:] == ("artist:Radiohead",)
        assert call_args.kwargs == {}

    @patch("app.routers.beets_router.run_in_threadpool", new_callable=AsyncMock)
    def test_move_without_query(self, mock_pool: AsyncMock, api_client: TestClient) -> None:
        mock_pool.return_value = {"success": True, "moved": 4}

        response = api_client.post("/beets/move", json={})

        assert response.status_code == 200
        assert response.json() == {"success": True, "moved": 4}
        mock_pool.assert_awaited_once()
        call_args = mock_pool.await_args
        method = call_args.args[0]
        assert method.__self__ is beets_router.beets_client
        assert method.__name__ == "move"
        assert call_args.args[1:] == (None,)
        assert call_args.kwargs == {}

    @patch("app.routers.beets_router.run_in_threadpool", new_callable=AsyncMock)
    def test_move_client_error(self, mock_pool: AsyncMock, api_client: TestClient) -> None:
        mock_pool.side_effect = BeetsClientError("Command failed")

        response = api_client.post("/beets/move", json={})

        assert response.status_code == 500
        assert response.json()["detail"] == "Command failed"


class TestRouterWrite:
    @patch("app.routers.beets_router.run_in_threadpool", new_callable=AsyncMock)
    def test_write_with_query(self, mock_pool: AsyncMock, api_client: TestClient) -> None:
        mock_pool.return_value = {"success": True, "written": 3}

        response = api_client.post(
            "/beets/write",
            json={"query": "year:2020"},
        )

        assert response.status_code == 200
        assert response.json() == {"success": True, "written": 3}
        mock_pool.assert_awaited_once()
        call_args = mock_pool.await_args
        method = call_args.args[0]
        assert method.__self__ is beets_router.beets_client
        assert method.__name__ == "write"
        assert call_args.args[1:] == ("year:2020",)
        assert call_args.kwargs == {}

    @patch("app.routers.beets_router.run_in_threadpool", new_callable=AsyncMock)
    def test_write_without_query(self, mock_pool: AsyncMock, api_client: TestClient) -> None:
        mock_pool.return_value = {"success": True, "output": "done"}

        response = api_client.post("/beets/write", json={})

        assert response.status_code == 200
        assert response.json() == {"success": True, "output": "done"}
        mock_pool.assert_awaited_once()
        call_args = mock_pool.await_args
        method = call_args.args[0]
        assert method.__self__ is beets_router.beets_client
        assert method.__name__ == "write"
        assert call_args.args[1:] == (None,)
        assert call_args.kwargs == {}


class TestRouterFields:
    @patch("app.routers.beets_router.run_in_threadpool", new_callable=AsyncMock)
    def test_fields(self, mock_pool: AsyncMock, api_client: TestClient) -> None:
        mock_pool.return_value = ["artist", "album"]

        response = api_client.get("/beets/fields")

        assert response.status_code == 200
        assert response.json() == {"fields": ["artist", "album"]}
        mock_pool.assert_awaited_once()
        call_args = mock_pool.await_args
        method = call_args.args[0]
        assert method.__self__ is beets_router.beets_client
        assert method.__name__ == "fields"
        assert call_args.args[1:] == ()
        assert call_args.kwargs == {}


class TestRouterQuery:
    @patch("app.routers.beets_router.run_in_threadpool", new_callable=AsyncMock)
    def test_query(self, mock_pool: AsyncMock, api_client: TestClient) -> None:
        mock_pool.return_value = ["Artist - Song"]

        response = api_client.post(
            "/beets/query",
            json={"query": "genre:rock", "format": "$artist - $title"},
        )

        assert response.status_code == 200
        assert response.json() == {"results": ["Artist - Song"]}
        mock_pool.assert_awaited_once()
        call_args = mock_pool.await_args
        method = call_args.args[0]
        assert method.__self__ is beets_router.beets_client
        assert method.__name__ == "query"
        assert call_args.args[1:] == ("genre:rock",)
        assert call_args.kwargs == {"fmt": "$artist - $title"}

    @patch("app.routers.beets_router.run_in_threadpool", new_callable=AsyncMock)
    def test_query_invalid(self, mock_pool: AsyncMock, api_client: TestClient) -> None:
        mock_pool.side_effect = BeetsClientError("Invalid query syntax: ")

        response = api_client.post(
            "/beets/query",
            json={"query": '"'},
        )

        assert response.status_code == 400
        assert response.json()["detail"] == "Invalid query syntax"


===== tests/test_matching.py =====
from __future__ import annotations

from app.core.matching_engine import MusicMatchingEngine
from tests.simple_client import SimpleTestClient


def test_match_confidence() -> None:
    engine = MusicMatchingEngine()
    spotify_track = {
        "id": "track-1",
        "name": "Test Song",
        "artists": [{"name": "Tester"}],
        "album": {"name": "Album"},
        "duration_ms": 200000,
    }
    plex_track = {
        "id": "100",
        "title": "Test Song",
        "artist": "Tester",
        "album": "Album",
        "duration": 200000,
    }
    score = engine.calculate_match_confidence(spotify_track, plex_track)
    assert score > 0.8


def test_matching_api_plex(client: SimpleTestClient) -> None:
    payload = {
        "spotify_track": {
            "id": "track-1",
            "name": "Test Song",
            "artists": [{"name": "Tester"}],
            "album": {"name": "Album"},
            "duration_ms": 200000,
        },
        "candidates": [
            {"id": "100", "title": "Test Song", "artist": "Tester", "album": "Album", "duration": 200000}
        ],
    }
    response = client.post("/matching/spotify-to-plex", json=payload)
    assert response.status_code == 200
    data = response.json()
    assert data["best_match"]["id"] == "100"
    assert data["confidence"] > 0.5


def test_matching_api_soulseek(client: SimpleTestClient) -> None:
    payload = {
        "spotify_track": {
            "id": "track-1",
            "name": "Test Song",
            "artists": [{"name": "Tester"}],
            "album": {"name": "Album"},
        },
        "candidates": [
            {"filename": "Tester - Test Song.mp3", "username": "Tester", "bitrate": 320}
        ],
    }
    response = client.post("/matching/spotify-to-soulseek", json=payload)
    assert response.status_code == 200
    assert response.json()["confidence"] > 0.5


def test_album_matching_engine() -> None:
    engine = MusicMatchingEngine()
    spotify_album = {
        "id": "album-1",
        "name": "Test Album",
        "artists": [{"name": "Tester"}],
        "total_tracks": 10,
        "release_date": "2020-05-01",
    }
    plex_albums = [
        {
            "ratingKey": "201",
            "title": "Test Album",
            "grandparentTitle": "Tester",
            "leafCount": 10,
            "year": 2020,
        },
        {
            "ratingKey": "202",
            "title": "Other Album",
            "grandparentTitle": "Tester",
            "leafCount": 8,
            "year": 2018,
        },
    ]
    match, score = engine.find_best_album_match(spotify_album, plex_albums)
    assert match["ratingKey"] == "201"
    assert score > 0.8


def test_matching_api_album(client: SimpleTestClient) -> None:
    payload = {
        "spotify_album": {
            "id": "album-1",
            "name": "Test Album",
            "artists": [{"name": "Tester"}],
            "total_tracks": 10,
            "release_date": "2020-05-01",
        },
        "candidates": [
            {
                "ratingKey": "201",
                "title": "Test Album",
                "grandparentTitle": "Tester",
                "leafCount": 10,
                "year": 2020,
            },
            {
                "ratingKey": "202",
                "title": "Other Album",
                "grandparentTitle": "Tester",
                "leafCount": 8,
                "year": 2018,
            },
        ],
    }
    response = client.post("/matching/spotify-to-plex-album", json=payload)
    assert response.status_code == 200
    data = response.json()
    assert data["best_match"]["ratingKey"] == "201"
    assert data["confidence"] > 0.8

===== tests/test_plex.py =====
from __future__ import annotations

import asyncio
from typing import Dict

from fastapi import status

from app.db import session_scope
from app.models import Setting
from app.workers.scan_worker import ScanWorker
from tests.simple_client import SimpleTestClient


def test_plex_status(client: SimpleTestClient) -> None:
    response = client.get("/plex/status")
    assert response.status_code == status.HTTP_200_OK
    payload = response.json()
    assert payload["status"] == "connected"
    assert payload["library"] == {"artists": 2, "albums": 3, "tracks": 5}


def test_library_endpoints(client: SimpleTestClient) -> None:
    response = client.get("/plex/library/sections")
    assert response.status_code == status.HTTP_200_OK
    assert response.json()["MediaContainer"]["Directory"][0]["title"] == "Music"

    response = client.get("/plex/library/sections/1/all", params={"type": "8"})
    assert response.status_code == status.HTTP_200_OK
    assert "MediaContainer" in response.json()

    response = client.get("/plex/library/metadata/100")
    assert response.status_code == status.HTTP_200_OK
    assert response.json()["title"] == "Test Item"


def test_session_endpoints(client: SimpleTestClient) -> None:
    response = client.get("/plex/status/sessions")
    assert response.status_code == status.HTTP_200_OK
    assert response.json()["MediaContainer"]["size"] == 1

    response = client.get("/plex/status/sessions/history/all")
    assert response.status_code == status.HTTP_200_OK
    assert response.json()["MediaContainer"]["size"] == 1


def test_timeline_and_scrobble(client: SimpleTestClient) -> None:
    response = client.get("/plex/timeline", params={"ratingKey": "1"})
    assert response.status_code == status.HTTP_200_OK
    assert response.json()["timeline"] == {"ratingKey": "1"}

    response = client.post("/plex/timeline", json={"time": 1000})
    assert response.status_code == status.HTTP_200_OK
    assert response.json() == "ok"

    response = client.post("/plex/scrobble", json={"key": "100"})
    assert response.status_code == status.HTTP_200_OK
    assert response.json() == "ok"

    response = client.post("/plex/unscrobble", json={"key": "100"})
    assert response.status_code == status.HTTP_200_OK
    assert response.json() == "ok"


def test_playlists_and_playqueue(client: SimpleTestClient) -> None:
    response = client.get("/plex/playlists")
    assert response.status_code == status.HTTP_200_OK

    response = client.post("/plex/playlists", json={"title": "New"})
    assert response.status_code == status.HTTP_200_OK
    assert response.json()["status"] == "created"

    response = client.put("/plex/playlists/42", json={"title": "Updated"})
    assert response.status_code == status.HTTP_200_OK
    assert response.json()["status"] == "updated"

    response = client.delete("/plex/playlists/42")
    assert response.status_code == status.HTTP_200_OK
    assert response.json()["status"] == "deleted"

    response = client.post("/plex/playQueues", json={"uri": "library://1"})
    assert response.status_code == status.HTTP_200_OK
    playqueue_id = response.json()["playQueueID"]

    response = client.get(f"/plex/playQueues/{playqueue_id}")
    assert response.status_code == status.HTTP_200_OK
    assert response.json()["uri"] == "library://1"


def test_rating_and_tags(client: SimpleTestClient) -> None:
    response = client.post("/plex/rate", json={"key": "100", "rating": 5})
    assert response.status_code == status.HTTP_200_OK
    assert response.json() == "ok"

    response = client.post("/plex/tags/100", json={"collection": ["Favorites"]})
    assert response.status_code == status.HTTP_200_OK
    assert response.json()["tags"] == {"collection": ["Favorites"]}


def test_devices_and_livetv(client: SimpleTestClient) -> None:
    response = client.get("/plex/devices")
    assert response.status_code == status.HTTP_200_OK
    assert response.json()["MediaContainer"]["Device"][0]["name"] == "Player"

    response = client.get("/plex/dvr")
    assert response.status_code == status.HTTP_200_OK
    assert response.json()["MediaContainer"]["Directory"][0]["name"] == "DVR"

    response = client.get("/plex/livetv")
    assert response.status_code == status.HTTP_200_OK
    assert response.json()["MediaContainer"]["Directory"][0]["name"] == "Channel"


def test_notifications(client: SimpleTestClient) -> None:
    response = client.get("/plex/notifications")
    assert response.status_code == status.HTTP_200_OK
    assert b"data: event" in response._body


def test_scan_worker_updates_status(client: SimpleTestClient) -> None:
    plex_stub = client.app.state.plex_stub
    worker = ScanWorker(plex_stub)

    asyncio.get_event_loop().run_until_complete(worker._perform_scan())

    with session_scope() as session:
        stored_settings: Dict[str, str] = {
            setting.key: setting.value
            for setting in session.query(Setting).all()
            if setting.key.startswith("plex_")
        }

    assert stored_settings["plex_artist_count"] == "2"
    assert stored_settings["plex_album_count"] == "3"
    assert stored_settings["plex_track_count"] == "5"
    assert "T" in stored_settings["plex_last_scan"]


===== tests/test_settings.py =====
from __future__ import annotations

from typing import List


def _extract_history_for_key(history: List[dict], key: str) -> List[dict]:
    return [entry for entry in history if entry["key"] == key]


def test_settings_history_tracking(client) -> None:
    response = client.post("/settings", json={"key": "theme", "value": "light"})
    assert response.status_code == 200

    response = client.post("/settings", json={"key": "theme", "value": "dark"})
    assert response.status_code == 200

    response = client.post("/settings", json={"key": "notifications", "value": "enabled"})
    assert response.status_code == 200

    history_response = client.get("/settings/history")
    assert history_response.status_code == 200
    payload = history_response.json()

    assert "history" in payload
    history_entries = payload["history"]
    assert len(history_entries) >= 3

    theme_history = _extract_history_for_key(history_entries, "theme")
    assert len(theme_history) == 2

    first_entry, second_entry = theme_history[0], theme_history[1]
    assert first_entry["new_value"] == "dark"
    assert first_entry["old_value"] == "light"
    assert second_entry["new_value"] == "light"
    assert second_entry["old_value"] is None
    assert first_entry["changed_at"] >= second_entry["changed_at"]

===== tests/test_soulseek.py =====
from __future__ import annotations

from tests.simple_client import SimpleTestClient


def test_soulseek_status(client: SimpleTestClient) -> None:
    response = client.get("/soulseek/status")
    assert response.status_code == 200
    assert response.json()["status"] == "connected"


def test_soulseek_search(client: SimpleTestClient) -> None:
    response = client.post("/soulseek/search", json={"query": "Test"})
    assert response.status_code == 200
    assert response.json()["results"] == ["Test"]


def test_soulseek_download_flow(client: SimpleTestClient) -> None:
    download_payload = {
        "username": "tester",
        "files": [{"filename": "song.mp3", "size": 123}],
    }
    response = client.post("/soulseek/download", json=download_payload)
    assert response.status_code == 200
    payload = response.json()
    assert payload["status"] == "queued"
    download_id = payload["detail"]["downloads"][0]["id"]

    response = client.get("/soulseek/downloads")
    assert response.status_code == 200
    downloads = response.json()["downloads"]
    download = next(item for item in downloads if item["id"] == download_id)
    assert download["state"] == "queued"
    assert download["progress"] == 0.0

    stub = client.app.state.soulseek_stub
    stub.set_status(download_id, progress=25.0, state="downloading")
    client._loop.run_until_complete(client.app.state.sync_worker.refresh_downloads())

    response = client.get("/soulseek/downloads")
    downloads = response.json()["downloads"]
    download = next(item for item in downloads if item["id"] == download_id)
    assert download["state"] == "downloading"
    assert download["progress"] > 0

    stub.set_status(download_id, progress=100.0, state="completed")
    client._loop.run_until_complete(client.app.state.sync_worker.refresh_downloads())

    response = client.get("/soulseek/downloads")
    downloads = response.json()["downloads"]
    download = next(item for item in downloads if item["id"] == download_id)
    assert download["state"] == "completed"
    assert download["progress"] == 100.0


def test_soulseek_download_cancellation(client: SimpleTestClient) -> None:
    download_payload = {
        "username": "tester",
        "files": [{"filename": "song.mp3", "size": 123}],
    }
    response = client.post("/soulseek/download", json=download_payload)
    assert response.status_code == 200
    download_id = response.json()["detail"]["downloads"][0]["id"]

    response = client.delete(f"/soulseek/download/{download_id}")
    assert response.status_code == 200
    assert response.json()["cancelled"] is True

    response = client.get("/soulseek/downloads")
    downloads = response.json()["downloads"]
    download = next(item for item in downloads if item["id"] == download_id)
    assert download["state"] == "failed"

    response = client.delete("/soulseek/download/1")
    assert response.status_code == 200
    assert response.json()["cancelled"] is True


def test_soulseek_download_management_endpoints(client: SimpleTestClient) -> None:
    payload = {
        "username": "tester",
        "files": [{"filename": "song.mp3", "size": 123}],
    }
    response = client.post("/soulseek/download", json=payload)
    assert response.status_code == 200
    download_id = response.json()["detail"]["downloads"][0]["id"]

    stub = client.app.state.soulseek_stub
    stub.queue_positions[download_id] = {"position": 3}
    stub.set_status(download_id, state="completed", progress=100.0)

    detail = client.get(f"/soulseek/download/{download_id}")
    assert detail.status_code == 200
    assert detail.json()["id"] == download_id

    queue = client.get(f"/soulseek/download/{download_id}/queue")
    assert queue.status_code == 200
    assert queue.json()["position"] == 3

    all_downloads = client.get("/soulseek/downloads/all")
    assert all_downloads.status_code == 200
    downloads = all_downloads.json()["downloads"]
    assert any(item["id"] == download_id for item in downloads)

    removed = client.delete("/soulseek/downloads/completed")
    assert removed.status_code == 200
    assert removed.json()["removed"] >= 1

    queue_after = client.get(f"/soulseek/download/{download_id}/queue")
    assert queue_after.status_code == 200


def test_soulseek_enqueue_endpoint(client: SimpleTestClient) -> None:
    payload = {
        "username": "tester",
        "files": [{"filename": "other.mp3", "size": 321}],
    }
    response = client.post("/soulseek/enqueue", json=payload)
    assert response.status_code == 200
    body = response.json()
    assert body["status"] == "enqueued"
    assert body["job"]["files"][0]["filename"] == "other.mp3"


def test_soulseek_upload_endpoints(client: SimpleTestClient) -> None:
    stub = client.app.state.soulseek_stub
    uploads = client.get("/soulseek/uploads")
    assert uploads.status_code == 200
    assert len(uploads.json()["uploads"]) == 1

    all_uploads = client.get("/soulseek/uploads/all")
    assert all_uploads.status_code == 200
    assert len(all_uploads.json()["uploads"]) == 2

    detail = client.get("/soulseek/upload/up-1")
    assert detail.status_code == 200
    assert detail.json()["id"] == "up-1"

    cancel = client.delete("/soulseek/upload/up-1")
    assert cancel.status_code == 200
    assert cancel.json()["cancelled"] == "up-1"

    removed = client.delete("/soulseek/uploads/completed")
    assert removed.status_code == 200
    assert removed.json()["removed"] >= 1

    assert stub.uploads["up-1"]["state"] == "cancelled"


def test_soulseek_user_endpoints(client: SimpleTestClient) -> None:
    address = client.get("/soulseek/user/tester/address")
    assert address.status_code == 200
    assert address.json()["host"] == "127.0.0.1"

    browse = client.get("/soulseek/user/tester/browse")
    assert browse.status_code == 200
    assert browse.json()["files"] == ["song.mp3"]

    status = client.get("/soulseek/user/tester/browsing_status")
    assert status.status_code == 200
    assert status.json()["state"] == "idle"

    directory = client.get("/soulseek/user/tester/directory", params={"path": "/music"})
    assert directory.status_code == 200
    assert directory.json()["path"] == "/music"

    info = client.get("/soulseek/user/tester/info")
    assert info.status_code == 200
    assert info.json()["username"] == "tester"

    user_status = client.get("/soulseek/user/tester/status")
    assert user_status.status_code == 200
    assert user_status.json()["online"] is True

===== tests/test_spotify.py =====
from __future__ import annotations

from tests.simple_client import SimpleTestClient

from app.db import session_scope
from app.models import Playlist
from app.workers.playlist_sync_worker import PlaylistSyncWorker


def test_playlist_sync_worker_persists_playlists(client: SimpleTestClient) -> None:
    stub = client.app.state.spotify_stub
    stub.playlists = [
        {"id": "playlist-1", "name": "Focus", "tracks": {"total": 12}},
        {"id": "playlist-2", "name": "Relax", "track_count": 8},
    ]

    worker = PlaylistSyncWorker(stub, interval_seconds=0.1)
    client._loop.run_until_complete(worker.sync_once())

    with session_scope() as session:
        records = session.query(Playlist).all()
        assert len(records) == 2

    response = client.get("/spotify/playlists")
    assert response.status_code == 200
    playlists = response.json()["playlists"]
    assert {entry["id"] for entry in playlists} == {"playlist-1", "playlist-2"}
    first = next(item for item in playlists if item["id"] == "playlist-1")
    assert first["track_count"] == 12

    stub.playlists = [
        {"id": "playlist-1", "name": "Focus Updated", "tracks": {"total": 15}},
    ]
    client._loop.run_until_complete(worker.sync_once())

    response = client.get("/spotify/playlists")
    assert response.status_code == 200
    playlists = response.json()["playlists"]
    assert len(playlists) == 2
    updated = next(item for item in playlists if item["id"] == "playlist-1")
    assert updated["name"] == "Focus Updated"
    assert updated["track_count"] == 15
    assert playlists[0]["id"] == "playlist-1"


def test_audio_features_endpoints(client: SimpleTestClient) -> None:
    stub = client.app.state.spotify_stub
    stub.audio_features["track-2"] = {"id": "track-2", "danceability": 0.7}

    single = client.get("/spotify/audio-features/track-1")
    assert single.status_code == 200
    assert single.json()["audio_features"]["id"] == "track-1"

    multiple = client.get("/spotify/audio-features", params={"ids": "track-1,track-2"})
    assert multiple.status_code == 200
    features = multiple.json()["audio_features"]
    assert isinstance(features, list)
    assert {item["id"] for item in features} == {"track-1", "track-2"}


def test_playlist_items_endpoint(client: SimpleTestClient) -> None:
    stub = client.app.state.spotify_stub
    stub.playlist_items["playlist-42"] = {
        "items": [{"track": {"id": "track-1"}}, {"track": {"id": "track-2"}}],
        "total": 2,
    }

    response = client.get("/spotify/playlists/playlist-42/tracks")
    assert response.status_code == 200
    body = response.json()
    assert body["total"] == 2
    assert len(body["items"]) == 2


def test_save_and_remove_tracks(client: SimpleTestClient) -> None:
    stub = client.app.state.spotify_stub

    save_response = client.put("/spotify/me/tracks", json={"ids": ["track-1", "track-2"]})
    assert save_response.status_code == 200
    assert stub.saved_track_ids == {"track-1", "track-2"}

    saved = client.get("/spotify/me/tracks")
    assert saved.status_code == 200
    data = saved.json()
    assert data["total"] == 2

    remove_response = client.delete("/spotify/me/tracks", json={"ids": ["track-1"]})
    assert remove_response.status_code == 200
    assert stub.saved_track_ids == {"track-2"}


def test_recommendations_endpoint(client: SimpleTestClient) -> None:
    stub = client.app.state.spotify_stub
    stub.recommendation_payload = {
        "tracks": [{"id": "track-3"}],
        "seeds": [{"type": "track", "id": "track-1"}],
    }

    response = client.get(
        "/spotify/recommendations",
        params={"seed_tracks": "track-1", "limit": 1},
    )
    assert response.status_code == 200
    body = response.json()
    assert body["tracks"] == [{"id": "track-3"}]
    assert body["seeds"] == [{"type": "track", "id": "track-1"}]

