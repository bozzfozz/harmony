// FILE: .github/workflows/autopush.yml
name: CI

on:
  push:
    branches: [ main ]
  pull_request:

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
      - name: Run tests
        run: pytest

// FILE: .gitignore
__pycache__/
*.pyc
harmony.db

// FILE: CHANGELOG.md
# Changelog

Alle nennenswerten Änderungen dieses Projekts werden in dieser Datei dokumentiert.

## v1.x.x – Service-Konfiguration über die UI
- Einstellungen für Spotify, Plex und Soulseek sind jetzt direkt in der UI pflegbar.

## v1.x.x – Harmony AppHeader
- Neuer Harmony AppHeader im Frontend hinzugefügt.

## v1.6.0 – Harmony Web UI
- Vollständige Web-Oberfläche mit Spotify, Plex, Soulseek, Matching und Settings implementiert.
- Globale Suche, Filter, Notifications und Theme-Steuerung über den AppHeader.
- Realtime-Updates via SSE für Soulseek-Downloads und Plex-Scans integriert.
- Services, Hooks und Tests für API-Aufrufe, Matching-Flows und Formularspeicherung hinzugefügt.

## v1.5.0 – Frontend-Grundstruktur
- Frontend-Grundstruktur mit Navbar, Sidebar, Routing und ersten Pages erstellt.
- React + Vite Setup mit Tailwind, shadcn/ui und Radix UI eingerichtet.
- Navigationslayout bestehend aus fixer Navbar, Sidebar und mobilem Drawer hinzugefügt.
- Erste UI-Module (Cards, Tabellen, Formulare, Toasts) vorbereitet.

## v0.3.0 – Theme-System
- Theme-System (Light/Dark) integriert.
- CSS-Variablen für Farben und Radii definiert und in Tailwind verfügbar gemacht.
- Dark-Mode Toggle inklusive Persistenz eingebaut.

## v1.4.0 – Spotify API Vollintegration
- Vollständige Spotify-Integration inkl. Playlist-Sync, Audio-Features, Recommendations und Benutzerbibliothek.
- Erweiterter Spotify-Router mit neuen Endpunkten für Playlists (Add/Remove/Reorder), Profil, Top-Tracks/-Artists.
- PlaylistSyncWorker synchronisiert persistierte Playlists regelmäßig in die Datenbank.

## v1.3.0 – Persistente Playlists
- Neuer Playlist-Sync-Prozess speichert Playlists persistent und liefert Änderungszeitpunkte.
- `/spotify/playlists` gibt Track-Anzahl und Timestamps aus der Datenbank zurück.

## v1.2.0 – Soulseek Downloadstatus
- Soulseek-Downloads werden mit Fortschritt und Zeitstempeln in SQLite abgelegt.
- API liefert Statusabfragen inklusive Fortschritt; Downloads können abgebrochen werden.
- Hintergrund-SyncWorker pollt slskd und aktualisiert persistierte Einträge.

## v1.1.0 – Beets-Integration
- Beets CLI via `BeetsClient` angebunden (Import, Update, Remove, Move, Write, Query, Stats).
- Dockerfiles und Compose-Setup für konsistenten Start angepasst.

## v1.0.0 – Initiale Version
- FastAPI-Anwendung mit Spotify-, Plex- und Soulseek-Routern.
- SQLite + SQLAlchemy für Persistenz, inklusive Testabdeckung mittels Pytest.

// FILE: CHANGES_REVIEW.md
# Code Review Zusammenfassung

## Router & API
- Alle Router binden nun konsistente JSON-Schemata ein und liefern eindeutige HTTP-Fehlercodes.
- Plex- und Soulseek-Router verwenden strukturierte Antwortmodelle und protokollieren API-Ausfälle.
- Matching-Router persistiert Ergebnisse transaktionssicher und gibt bei Datenbankfehlern klare Fehlermeldungen aus.
- Soulseek-Downloads lassen sich inklusive Fortschritt abrufen; Abbrüche markieren Einträge als `failed`.

## Datenbank & Worker
- `session_scope()` wird in allen Workern eingesetzt, um atomare Transaktionen und Rollbacks sicherzustellen.
- Verbesserte Logging-Ausgaben erleichtern das Debugging fehlgeschlagener Hintergrundjobs.
- `downloads`-Tabelle enthält Status, Fortschritt und Aktualisierungszeitpunkt; Sync-Worker pollt Soulseek für Updates.

## Dokumentation
- README um Neuerungen in v1.2.0 ergänzt.
- CHANGELOG auf Version 1.2.0 aktualisiert.
- Dokumentation und Changelog beschreiben den Soulseek-Download-Fortschritt.

// FILE: Dockerfile
FROM python:3.11-slim

ENV PYTHONUNBUFFERED=1 \
    POETRY_VIRTUALENVS_CREATE=false \
    PIP_NO_CACHE_DIR=1

WORKDIR /app

COPY requirements.txt ./
RUN pip install --upgrade pip && pip install -r requirements.txt

COPY . .

EXPOSE 8000

# Standard: Production
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]

// FILE: README.md
# Harmony Backend

Harmony ist ein FastAPI-Backend, das Spotify, Plex, Soulseek (slskd), Beets sowie eine eigene Matching-Engine und Hintergrund-Worker
zu einem gemeinsamen Musik-Hub kombiniert. Die Anwendung bündelt Bibliotheken, Downloads und Metadaten, synchronisiert sie zyklisch
und stellt einheitliche JSON-APIs für Automatisierungen und Frontend-Clients bereit.

## Features

- **Vollständige Spotify-Integration** für Suche, Playlists, Audio-Features, Empfehlungen und Benutzerbibliotheken.
- **Async Plex-Client** mit Zugriff auf Bibliotheken, Sessions, PlayQueues, Live-TV und Echtzeit-Benachrichtigungen.
- **Soulseek-Anbindung** inklusive Download-/Upload-Verwaltung, Warteschlangen und Benutzerinformationen.
- **Beets CLI Bridge** zum Importieren, Aktualisieren, Verschieben und Abfragen der lokalen Musikbibliothek.
- **Matching-Engine** zur Ermittlung der besten Kandidaten zwischen Spotify ↔ Plex/Soulseek inklusive Persistierung.
- **SQLite-Datenbank** mit SQLAlchemy-Modellen für Playlists, Downloads, Matches und Settings.
- **Hintergrund-Worker** für Soulseek-Synchronisation, Matching-Queue, Plex-Scans und Spotify-Playlist-Sync.
- **Docker & GitHub Actions** für reproduzierbare Builds, Tests und Continuous Integration.

## Architekturüberblick

Harmony folgt einer klar getrennten Schichten-Architektur:

- **Core**: Enthält API-Clients (`spotify_client.py`, `plex_client.py`, `soulseek_client.py`, `beets_client.py`) und die Matching-Engine.
- **Routers**: FastAPI-Router kapseln die öffentlich erreichbaren Endpunkte (Spotify, Plex, Soulseek, Matching, Settings, Beets).
- **Workers**: Asynchrone Tasks synchronisieren Playlists, Soulseek-Downloads, Plex-Statistiken und Matching-Jobs.
- **Datenbank-Layer**: `app/db.py`, SQLAlchemy-Modelle und -Schemas verwalten persistente Zustände.

Eine ausführliche Beschreibung der Komponenten findest du in [`docs/architecture.md`](docs/architecture.md).

## Setup-Anleitung

### Voraussetzungen

- Python 3.11
- SQLite (im Lieferumfang enthalten)
- Optional: Docker und Docker Compose

### Lokales Setup

```bash
python -m venv .venv
source .venv/bin/activate
pip install --upgrade pip
pip install -r requirements.txt
uvicorn app.main:app --reload
```

Konfiguriere erforderliche Umgebungsvariablen (siehe Tabelle unten), bevor du den Server startest.

### Docker

```bash
docker build -t harmony-backend .
docker run --env-file .env -p 8000:8000 harmony-backend
```

### Docker Compose

```bash
docker compose up --build
```

Das Dev-Override (`docker-compose.override.yml`) aktiviert Hot-Reloading und Debug-Logging.

### GitHub Actions

Der Workflow [`.github/workflows/autopush.yml`](.github/workflows/autopush.yml) führt bei jedem Push auf `main` sowie bei Pull
Requests die Test-Suite (`pytest`) unter Python 3.11 aus.

## Konfiguration

| Variable | Beschreibung |
| --- | --- |
| `SPOTIFY_CLIENT_ID` | Spotify OAuth Client ID |
| `SPOTIFY_CLIENT_SECRET` | Spotify OAuth Client Secret |
| `SPOTIFY_REDIRECT_URI` | Redirect URI für den OAuth-Flow |
| `SPOTIFY_SCOPE` | Optionaler Scope für Spotify Berechtigungen |
| `PLEX_BASE_URL` | Basis-URL des Plex-Servers |
| `PLEX_TOKEN` | Plex Auth Token |
| `PLEX_LIBRARY` | Name der Plex-Musikbibliothek |
| `SLSKD_URL` | Basis-URL des Soulseek-Daemons |
| `SLSKD_API_KEY` | API-Key für slskd (falls gesetzt) |
| `DATABASE_URL` | SQLAlchemy Verbindungsstring (Standard: `sqlite:///./harmony.db`) |
| `HARMONY_LOG_LEVEL` | Log-Level (`INFO`, `DEBUG`, …) |
| `HARMONY_DISABLE_WORKERS` | `1` deaktiviert alle Hintergrund-Worker (z. B. für Tests) |

## API-Endpoints

Eine vollständige Referenz der FastAPI-Routen befindet sich in [`docs/api.md`](docs/api.md). Die wichtigsten Gruppen im Überblick:

- **Spotify** (`/spotify`): Status, Suche, Track-Details, Audio-Features, Benutzerbibliothek, Playlists, Empfehlungen.
- **Plex** (`/plex`): Status & Statistiken, Bibliotheken, PlayQueues, Playlists, Timeline, Bewertungen, Benachrichtigungen.
- **Soulseek** (`/soulseek`): Status, Suche, Downloads/Uploads, Warteschlangen, Benutzerverzeichnisse und -infos.
- **Matching** (`/matching`): Spotify→Plex, Spotify→Soulseek sowie Album-Matching.
- **Settings** (`/settings`): Key-Value Einstellungen inkl. History.
- **Beets** (`/beets`): Import, Update, Query, Stats und Dateimanipulation via CLI.

## Tests & CI

```bash
pytest
```

Die Tests mocken externe Dienste und können lokal wie auch via GitHub Actions ausgeführt werden. Für deterministische
Runs sollten die Worker mit `HARMONY_DISABLE_WORKERS=1` deaktiviert werden.

## Lizenz

Das Projekt steht derzeit ohne explizite Lizenzdatei zur Verfügung. Ohne eine veröffentlichte Lizenz gelten sämtliche Rechte
als vorbehalten.

// FILE: ToDo.md
# ToDo

- ✅ Backend-Struktur mit FastAPI, SQLAlchemy und SQLite aufbauen
- ✅ Core-Clients für Spotify, Plex und Soulseek implementieren
- ✅ Matching-Engine integrieren
- ✅ Tests mit Pytest erstellen
- ✅ Docker- und CI-Konfiguration hinzufügen
- ✅ Erweiterte Frontend-Integration

## Theme Follow-ups

- [ ] Mehr Farbvarianten für Charts validieren
- [ ] High-Contrast Mode überlegen
- [ ] Animationsdauer anpassen

// FILE: app/__init__.py

// FILE: app/config.py
"""Application configuration utilities for Harmony."""
from __future__ import annotations

import os
from dataclasses import dataclass
from typing import Optional


@dataclass(slots=True)
class SpotifyConfig:
    client_id: Optional[str]
    client_secret: Optional[str]
    redirect_uri: Optional[str]
    scope: str


@dataclass(slots=True)
class PlexConfig:
    base_url: Optional[str]
    token: Optional[str]
    library_name: Optional[str]


@dataclass(slots=True)
class SoulseekConfig:
    base_url: str
    api_key: Optional[str]


@dataclass(slots=True)
class LoggingConfig:
    level: str


@dataclass(slots=True)
class DatabaseConfig:
    url: str


@dataclass(slots=True)
class AppConfig:
    spotify: SpotifyConfig
    plex: PlexConfig
    soulseek: SoulseekConfig
    logging: LoggingConfig
    database: DatabaseConfig


DEFAULT_DB_URL = "sqlite:///./harmony.db"
DEFAULT_SOULSEEK_URL = "http://localhost:5030"
DEFAULT_SPOTIFY_SCOPE = (
    "user-library-read playlist-read-private playlist-read-collaborative"
)


def load_config() -> AppConfig:
    """Load application configuration from environment variables."""

    spotify = SpotifyConfig(
        client_id=os.getenv("SPOTIFY_CLIENT_ID"),
        client_secret=os.getenv("SPOTIFY_CLIENT_SECRET"),
        redirect_uri=os.getenv("SPOTIFY_REDIRECT_URI"),
        scope=os.getenv("SPOTIFY_SCOPE", DEFAULT_SPOTIFY_SCOPE),
    )

    plex = PlexConfig(
        base_url=os.getenv("PLEX_BASE_URL") or os.getenv("PLEX_URL"),
        token=os.getenv("PLEX_TOKEN"),
        library_name=os.getenv("PLEX_LIBRARY"),
    )

    soulseek = SoulseekConfig(
        base_url=os.getenv("SLSKD_URL", DEFAULT_SOULSEEK_URL),
        api_key=os.getenv("SLSKD_API_KEY"),
    )

    logging = LoggingConfig(level=os.getenv("HARMONY_LOG_LEVEL", "INFO"))
    database = DatabaseConfig(url=os.getenv("DATABASE_URL", DEFAULT_DB_URL))

    return AppConfig(
        spotify=spotify,
        plex=plex,
        soulseek=soulseek,
        logging=logging,
        database=database,
    )

// FILE: app/core/__init__.py

// FILE: app/core/beets_client.py
from __future__ import annotations

from pathlib import Path
from typing import Mapping, Sequence
import os
import shlex
import subprocess
import re

from app.utils.logging_config import get_logger


class BeetsClientError(RuntimeError):
    """Raised when execution of a beets command fails."""


logger = get_logger("beets_client")


class BeetsClient:
    """Thin wrapper around the :mod:`beets` CLI."""

    def __init__(
        self,
        env: Mapping[str, str] | None = None,
        timeout: float = 60.0,
    ) -> None:
        self._env = {**os.environ, **env} if env else None
        self._timeout = timeout

    def _run(self, args: Sequence[str]) -> subprocess.CompletedProcess[str]:
        """Execute *args* with the ``beet`` CLI and return the process result."""

        command = " ".join(args)
        logger.info("Executing beets command: %s", command)

        try:
            run_kwargs = dict(capture_output=True, text=True, check=True)
            if self._env is not None:
                run_kwargs["env"] = self._env
            result = subprocess.run(list(args), timeout=self._timeout, **run_kwargs)
        except subprocess.TimeoutExpired as exc:
            logger.error("Beets command timed out: %s", command)
            raise BeetsClientError("Command timed out") from exc
        except subprocess.CalledProcessError as exc:
            stderr = (exc.stderr or "").strip()
            if stderr:
                logger.error("Beets command failed (%s): %s", command, stderr)
            else:
                logger.error("Beets command failed (%s)", command)
            raise BeetsClientError(stderr or f"Command '{command}' failed") from exc
        except Exception as exc:  # pragma: no cover - defensive
            logger.exception("Unexpected error while executing '%s'", command)
            raise BeetsClientError(f"Unexpected error running '{command}'") from exc

        stdout = (result.stdout or "").strip()
        if stdout:
            logger.info("Beets command output: %s", stdout)

        return result

    def import_file(
        self, path: str | Path, quiet: bool = True, autotag: bool = True
    ) -> str:
        """Import *path* into the beets library using ``beet import``."""

        args: list[str] = ["beet", "import"]
        if quiet:
            args.append("-q")
        if not autotag:
            args.append("-A")
        args.append(str(path))

        result = self._run(args)
        return (result.stdout or "").strip()

    def update(self, path: str | Path | None = None) -> str:
        """Run ``beet update`` optionally scoped to *path*."""

        args: list[str] = ["beet", "update"]
        if path is not None:
            args.append(str(path))

        result = self._run(args)
        return (result.stdout or "").strip()

    def list_albums(self) -> list[str]:
        """Return a list of album names from ``beet ls -a``."""

        result = self._run(["beet", "ls", "-a"])
        stdout = result.stdout or ""
        albums = [line for line in stdout.splitlines() if line.strip()]
        logger.debug("Parsed albums: %s", albums)
        return albums

    def list_tracks(self) -> list[str]:
        """Return a list of track titles from ``beet ls -f '$title'``."""

        result = self._run(["beet", "ls", "-f", "$title"])
        stdout = result.stdout or ""
        tracks = [line for line in stdout.splitlines() if line.strip()]
        logger.debug("Parsed tracks: %s", tracks)
        return tracks

    def stats(self) -> dict[str, str]:
        """Return parsed key/value pairs from ``beet stats``."""

        result = self._run(["beet", "stats"])
        stdout = result.stdout or ""
        stats: dict[str, str] = {}
        for line in stdout.splitlines():
            if ":" not in line:
                continue
            key, value = line.split(":", 1)
            key = key.strip()
            value = value.strip()
            if key:
                stats[key] = value
        logger.debug("Parsed stats: %s", stats)
        return stats

    def is_available(self) -> bool:
        """Return ``True`` when the ``beet`` CLI is reachable."""

        try:
            self._run(["beet", "version"])
        except BeetsClientError:
            return False
        return True

    def remove(self, query: str, force: bool = False) -> dict[str, object]:
        """Remove items matching *query* using ``beet remove``."""

        query_args = self._parse_query(query)
        args: list[str] = ["beet", "remove"]
        if force:
            args.append("-f")
        args.extend(query_args)

        result = self._run(args)
        parsed = self._parse_count_output(result.stdout, "Removed", "removed")
        logger.debug("Parsed remove output: %s", parsed)
        return parsed

    def move(self, query: str | None = None) -> dict[str, object]:
        """Move items in the library using ``beet move`` with an optional query."""

        args: list[str] = ["beet", "move"]
        if query:
            args.extend(self._parse_query(query))

        result = self._run(args)
        parsed = self._parse_count_output(result.stdout, "Moved", "moved")
        logger.debug("Parsed move output: %s", parsed)
        return parsed

    def write(self, query: str | None = None) -> dict[str, object]:
        """Write tags for items using ``beet write`` with an optional query."""

        args: list[str] = ["beet", "write"]
        if query:
            args.extend(self._parse_query(query))

        result = self._run(args)
        parsed = self._parse_count_output(result.stdout, "Wrote", "written")
        logger.debug("Parsed write output: %s", parsed)
        return parsed

    def fields(self) -> list[str]:
        """Return the list of available fields from ``beet fields``."""

        result = self._run(["beet", "fields"])
        stdout = result.stdout or ""
        fields = [line for line in stdout.splitlines() if line.strip()]
        logger.debug("Parsed fields: %s", fields)
        return fields

    def query(
        self, query: str, fmt: str = "$artist - $album - $title"
    ) -> list[str]:
        """Return formatted items for *query* via ``beet ls``."""

        query_args = self._parse_query(query)
        args: list[str] = ["beet", "ls", "-f", fmt]
        args.extend(query_args)

        result = self._run(args)
        stdout = result.stdout or ""
        results = [line for line in stdout.splitlines() if line.strip()]
        logger.debug("Parsed query results: %s", results)
        return results

    @staticmethod
    def _parse_query(query: str) -> list[str]:
        if not query or not query.strip():
            raise BeetsClientError("Query must not be empty")
        try:
            parts = shlex.split(query)
        except ValueError as exc:  # pragma: no cover - defensive
            raise BeetsClientError(f"Invalid query syntax: {exc}") from exc
        return parts

    @staticmethod
    def _parse_count_output(
        stdout: str | None, verb: str, key: str
    ) -> dict[str, object]:
        output = (stdout or "").strip()
        pattern = rf"{verb} (\d+) items"
        match = re.search(pattern, output)
        if match:
            count = int(match.group(1))
            return {"success": True, key: count}
        return {"success": True, "output": output}

// FILE: app/core/matching_engine.py
"""Music matching logic used by Harmony."""
from __future__ import annotations

import re
import unicodedata
from difflib import SequenceMatcher
from typing import Dict, Iterable, Optional, Tuple


class MusicMatchingEngine:
    """Provides fuzzy matching utilities across Spotify, Plex and Soulseek."""

    def _normalize(self, value: Optional[str]) -> str:
        if not value:
            return ""
        normalized = unicodedata.normalize("NFKD", value)
        normalized = normalized.encode("ascii", "ignore").decode("ascii")
        normalized = re.sub(r"[^a-z0-9]+", " ", normalized.lower())
        return normalized.strip()

    def _ratio(self, a: Optional[str], b: Optional[str]) -> float:
        na, nb = self._normalize(a), self._normalize(b)
        if not na or not nb:
            return 0.0
        return SequenceMatcher(None, na, nb).ratio()

    def calculate_match_confidence(self, spotify_track: Dict[str, str], plex_track: Dict[str, str]) -> float:
        title_score = self._ratio(spotify_track.get("name"), plex_track.get("title"))
        artist_score = self._ratio(
            (spotify_track.get("artists") or [{}])[0].get("name") if isinstance(spotify_track.get("artists"), list) else spotify_track.get("artist"),
            plex_track.get("artist") or plex_track.get("grandparentTitle"),
        )
        album_score = self._ratio(
            (spotify_track.get("album") or {}).get("name") if isinstance(spotify_track.get("album"), dict) else spotify_track.get("album"),
            plex_track.get("album") or plex_track.get("parentTitle"),
        )
        duration_spotify = spotify_track.get("duration_ms")
        duration_plex = plex_track.get("duration")
        duration_score = 0.0
        if duration_spotify and duration_plex:
            duration_score = 1.0 - min(abs(duration_spotify - duration_plex) / max(duration_spotify, duration_plex), 1)

        return round((title_score * 0.5) + (artist_score * 0.3) + (album_score * 0.15) + (duration_score * 0.05), 4)

    def find_best_match(
        self, spotify_track: Dict[str, str], plex_candidates: Iterable[Dict[str, str]]
    ) -> Tuple[Optional[Dict[str, str]], float]:
        best_match: Optional[Dict[str, str]] = None
        best_score = 0.0
        for candidate in plex_candidates:
            score = self.calculate_match_confidence(spotify_track, candidate)
            if score > best_score:
                best_score = score
                best_match = candidate
        return best_match, best_score

    def calculate_slskd_match_confidence(
        self, spotify_track: Dict[str, str], soulseek_entry: Dict[str, str]
    ) -> float:
        title_score = self._ratio(spotify_track.get("name"), soulseek_entry.get("filename"))
        artist = (
            (spotify_track.get("artists") or [{}])[0].get("name")
            if isinstance(spotify_track.get("artists"), list)
            else spotify_track.get("artist")
        )
        artist_score = self._ratio(artist, soulseek_entry.get("username"))
        bitrate_score = 1.0 if soulseek_entry.get("bitrate", 0) >= 256 else 0.5
        return round((title_score * 0.6) + (artist_score * 0.2) + (bitrate_score * 0.2), 4)

    def _extract_album_artist(self, album: Dict[str, str]) -> Optional[str]:
        artists = album.get("artists")
        if isinstance(artists, list) and artists:
            primary_artist = artists[0]
            if isinstance(primary_artist, dict):
                return primary_artist.get("name")
            return str(primary_artist)
        return album.get("artist") or album.get("grandparentTitle")

    def _album_track_count(self, album: Dict[str, str]) -> Optional[int]:
        for key in ("total_tracks", "trackCount", "leafCount", "childCount", "track_count"):
            value = album.get(key)
            if isinstance(value, int):
                return value
            if isinstance(value, str) and value.isdigit():
                return int(value)
        tracks = album.get("tracks")
        if isinstance(tracks, dict):
            items = tracks.get("items")
            if isinstance(items, list):
                return len(items)
        if isinstance(tracks, list):
            return len(tracks)
        return None

    def _album_year(self, album: Dict[str, str]) -> Optional[int]:
        for key in ("year", "release_year"):
            value = album.get(key)
            if isinstance(value, int):
                return value
            if isinstance(value, str) and value.isdigit():
                return int(value)
        release_date = album.get("release_date")
        if isinstance(release_date, str) and release_date:
            if len(release_date) >= 4 and release_date[:4].isdigit():
                return int(release_date[:4])
        originally_available_at = album.get("originallyAvailableAt")
        if isinstance(originally_available_at, str) and originally_available_at:
            if originally_available_at[:4].isdigit():
                return int(originally_available_at[:4])
        return None

    def calculate_album_confidence(
        self, spotify_album: Dict[str, str], plex_album: Dict[str, str]
    ) -> float:
        """Calculate similarity score between Spotify and Plex albums."""

        name_score = self._ratio(spotify_album.get("name"), plex_album.get("title"))
        spotify_artist = self._extract_album_artist(spotify_album)
        plex_artist = self._extract_album_artist(plex_album) or plex_album.get("parentTitle")
        artist_score = self._ratio(spotify_artist, plex_artist)

        spotify_tracks = self._album_track_count(spotify_album)
        plex_tracks = self._album_track_count(plex_album)
        track_count_score = 0.0
        if spotify_tracks and plex_tracks:
            diff = abs(spotify_tracks - plex_tracks)
            max_count = max(spotify_tracks, plex_tracks)
            track_count_score = 1.0 - min(diff / max_count, 1)

        spotify_year = self._album_year(spotify_album)
        plex_year = self._album_year(plex_album)
        year_score = 0.0
        if spotify_year and plex_year:
            year_score = 1.0 if spotify_year == plex_year else 0.0

        score = (name_score * 0.4) + (artist_score * 0.4) + (track_count_score * 0.1) + (year_score * 0.1)
        return round(score, 4)

    def find_best_album_match(
        self, spotify_album: Dict[str, str], plex_albums: Iterable[Dict[str, str]]
    ) -> Tuple[Optional[Dict[str, str]], float]:
        """Find the highest scoring Plex album for the given Spotify album."""

        best_match: Optional[Dict[str, str]] = None
        best_score = 0.0
        for candidate in plex_albums:
            score = self.calculate_album_confidence(spotify_album, candidate)
            if score > best_score:
                best_score = score
                best_match = candidate
        return best_match, best_score

// FILE: app/core/plex_client.py
"""Async Plex client built on top of the public Plex API."""
from __future__ import annotations

import asyncio
from contextlib import asynccontextmanager
from typing import Any, AsyncIterator, Dict, List

import aiohttp

from app.config import PlexConfig
from app.logging import get_logger

logger = get_logger(__name__)


class PlexClientError(RuntimeError):
    """Raised when the Plex API returns an error response."""


class PlexClient:
    """Asynchronous Plex API wrapper.

    The client intentionally exposes only the pieces of the API that are
    required by Harmony.  All HTTP communication is performed with
    :mod:`aiohttp` and a very small retry helper is used to increase
    robustness when Plex temporarily fails to respond.
    """

    _DEFAULT_TIMEOUT = aiohttp.ClientTimeout(total=30)
    _RETRY_ATTEMPTS = 3
    _RETRY_BASE_DELAY = 0.25

    def __init__(self, config: PlexConfig) -> None:
        if not (config.base_url and config.token):
            raise ValueError("Plex configuration is incomplete")
        self._base_url = config.base_url.rstrip("/")
        self._token = config.token
        self._session: aiohttp.ClientSession | None = None
        self._lock = asyncio.Lock()

    async def _ensure_session(self) -> aiohttp.ClientSession:
        async with self._lock:
            if self._session is None or self._session.closed:
                self._session = aiohttp.ClientSession(timeout=self._DEFAULT_TIMEOUT)
        assert self._session is not None
        return self._session

    def _build_url(self, path: str) -> str:
        if not path.startswith("/"):
            path = f"/{path}"
        return f"{self._base_url}{path}"

    def _build_headers(self) -> Dict[str, str]:
        return {"X-Plex-Token": self._token}

    async def _request(
        self,
        method: str,
        path: str,
        *,
        params: Dict[str, Any] | None = None,
        data: Dict[str, Any] | None = None,
        json_body: Dict[str, Any] | None = None,
        expect_json: bool = True,
    ) -> Any:
        url = self._build_url(path)
        attempt = 0
        last_exception: Exception | None = None
        while attempt < self._RETRY_ATTEMPTS:
            attempt += 1
            session = await self._ensure_session()
            try:
                async with session.request(
                    method,
                    url,
                    headers=self._build_headers(),
                    params=params,
                    data=data,
                    json=json_body,
                ) as response:
                    if response.status >= 400:
                        text = await response.text()
                        raise PlexClientError(
                            f"Plex {method} {url} failed with status {response.status}: {text}"
                        )
                    if expect_json:
                        return await response.json(content_type=None)
                    return await response.text()
            except Exception as exc:  # pragma: no cover - defensive logging
                last_exception = exc
                logger.warning(
                    "Plex request error (%s %s attempt %d/%d): %s",
                    method,
                    url,
                    attempt,
                    self._RETRY_ATTEMPTS,
                    exc,
                )
                if attempt >= self._RETRY_ATTEMPTS:
                    break
                await asyncio.sleep(self._RETRY_BASE_DELAY * attempt)
        assert last_exception is not None
        raise last_exception

    async def _get(self, path: str, params: Dict[str, Any] | None = None) -> Any:
        return await self._request("GET", path, params=params)

    async def _post(
        self,
        path: str,
        *,
        params: Dict[str, Any] | None = None,
        data: Dict[str, Any] | None = None,
        json_body: Dict[str, Any] | None = None,
        expect_json: bool = True,
    ) -> Any:
        return await self._request(
            "POST", path, params=params, data=data, json_body=json_body, expect_json=expect_json
        )

    async def _put(
        self,
        path: str,
        *,
        params: Dict[str, Any] | None = None,
        data: Dict[str, Any] | None = None,
        json_body: Dict[str, Any] | None = None,
    ) -> Any:
        return await self._request("PUT", path, params=params, data=data, json_body=json_body)

    async def _delete(self, path: str, params: Dict[str, Any] | None = None) -> Any:
        return await self._request("DELETE", path, params=params)

    async def get_libraries(self, params: Dict[str, Any] | None = None) -> Any:
        """Return all Plex library sections."""

        return await self._get("/library/sections", params=params)

    async def get_library_items(
        self, section_id: str, params: Dict[str, Any] | None = None
    ) -> Any:
        """Return items for a given library section."""

        return await self._get(f"/library/sections/{section_id}/all", params=params)

    async def get_metadata(self, item_id: str) -> Any:
        return await self._get(f"/library/metadata/{item_id}")

    async def get_sessions(self) -> Any:
        return await self._get("/status/sessions")

    async def get_session_history(self, params: Dict[str, Any] | None = None) -> Any:
        return await self._get("/status/sessions/history/all", params=params)

    async def get_timeline(self, params: Dict[str, Any] | None = None) -> Any:
        return await self._get("/:/timeline", params=params)

    async def update_timeline(self, data: Dict[str, Any]) -> Any:
        return await self._post("/:/timeline", data=data, expect_json=False)

    async def scrobble(self, data: Dict[str, Any]) -> Any:
        return await self._post("/:/scrobble", data=data, expect_json=False)

    async def unscrobble(self, data: Dict[str, Any]) -> Any:
        return await self._post("/:/unscrobble", data=data, expect_json=False)

    async def get_playlists(self) -> Any:
        return await self._get("/playlists")

    async def create_playlist(self, payload: Dict[str, Any]) -> Any:
        return await self._post("/playlists", json_body=payload)

    async def update_playlist(self, playlist_id: str, payload: Dict[str, Any]) -> Any:
        return await self._put(f"/playlists/{playlist_id}", json_body=payload)

    async def delete_playlist(self, playlist_id: str) -> Any:
        return await self._delete(f"/playlists/{playlist_id}")

    async def create_playqueue(self, payload: Dict[str, Any]) -> Any:
        return await self._post("/playQueues", json_body=payload)

    async def get_playqueue(self, playqueue_id: str) -> Any:
        return await self._get(f"/playQueues/{playqueue_id}")

    async def rate_item(self, item_id: str, rating: int) -> Any:
        payload = {"key": item_id, "rating": rating}
        return await self._post("/:/rate", data=payload, expect_json=False)

    async def sync_tags(self, item_id: str, tags: Dict[str, List[str]]) -> Any:
        payload = {"key": item_id, **tags}
        return await self._post("/:/settags", json_body=payload)

    async def get_devices(self) -> Any:
        return await self._get("/devices")

    async def get_dvr(self) -> Any:
        return await self._get("/livetv/dvrs")

    async def get_live_tv(self, params: Dict[str, Any] | None = None) -> Any:
        return await self._get("/livetv", params=params)

    async def get_library_statistics(self) -> Dict[str, int]:
        """Compute high level statistics for the Plex music library."""

        stats = {"artists": 0, "albums": 0, "tracks": 0}
        libraries = await self.get_libraries()
        container = libraries.get("MediaContainer", {}) if isinstance(libraries, dict) else {}
        for section in container.get("Directory", []):
            if section.get("type") != "artist":
                continue
            section_id = section.get("key")
            if not section_id:
                continue
            items = await self.get_library_items(section_id, params={"type": "10"})
            section_container = (
                items.get("MediaContainer", {}) if isinstance(items, dict) else {}
            )
            stats["artists"] += int(section_container.get("totalSize", 0))

            albums = await self.get_library_items(section_id, params={"type": "9"})
            album_container = (
                albums.get("MediaContainer", {}) if isinstance(albums, dict) else {}
            )
            stats["albums"] += int(album_container.get("totalSize", 0))

            tracks = await self.get_library_items(section_id, params={"type": "8"})
            track_container = (
                tracks.get("MediaContainer", {}) if isinstance(tracks, dict) else {}
            )
            stats["tracks"] += int(track_container.get("totalSize", 0))
        return stats

    @asynccontextmanager
    async def listen_notifications(self) -> AsyncIterator[aiohttp.ClientWebSocketResponse]:
        """Connect to the Plex websocket notification endpoint."""

        session = await self._ensure_session()
        url = self._build_url("/:/websocket/notifications")
        headers = self._build_headers()
        async with session.ws_connect(url, headers=headers) as websocket:
            yield websocket

    async def close(self) -> None:
        if self._session and not self._session.closed:
            await self._session.close()


// FILE: app/core/soulseek_client.py
"""Async client for the slskd REST API."""
from __future__ import annotations

import asyncio
import time
from collections import deque
from typing import Any, Dict, List, Optional

import aiohttp

from app.config import SoulseekConfig
from app.logging import get_logger


logger = get_logger(__name__)


class SoulseekClientError(RuntimeError):
    pass


class SoulseekClient:
    RATE_LIMIT_COUNT = 35
    RATE_LIMIT_WINDOW = 220.0

    def __init__(
        self,
        config: SoulseekConfig,
        session: Optional[aiohttp.ClientSession] = None,
    ) -> None:
        self._config = config
        self._session = session
        self._session_owner = session is None
        self._timestamps: deque[float] = deque(maxlen=self.RATE_LIMIT_COUNT)
        self._lock = asyncio.Lock()
        self._max_retries = 3

    async def _ensure_session(self) -> aiohttp.ClientSession:
        if self._session is None or self._session.closed:
            self._session = aiohttp.ClientSession()
        return self._session

    def _build_url(self, path: str) -> str:
        base = self._config.base_url.rstrip("/")
        return f"{base}/api/v0/{path.lstrip('/')}"

    def _build_headers(self) -> Dict[str, str]:
        headers = {"Content-Type": "application/json"}
        if self._config.api_key:
            headers["X-API-Key"] = self._config.api_key
        return headers

    async def _respect_rate_limit(self) -> None:
        async with self._lock:
            now = time.monotonic()
            while self._timestamps and now - self._timestamps[0] > self.RATE_LIMIT_WINDOW:
                self._timestamps.popleft()
            if len(self._timestamps) >= self.RATE_LIMIT_COUNT:
                wait_time = self.RATE_LIMIT_WINDOW - (now - self._timestamps[0])
                if wait_time > 0:
                    await asyncio.sleep(wait_time)
            self._timestamps.append(time.monotonic())

    async def _request(self, method: str, path: str, **kwargs: Any) -> Any:
        await self._respect_rate_limit()
        session = await self._ensure_session()
        url = self._build_url(path)
        headers = kwargs.pop("headers", {})
        headers = {**self._build_headers(), **headers}

        backoff = 0.5
        for attempt in range(1, self._max_retries + 1):
            try:
                async with session.request(method, url, headers=headers, **kwargs) as response:
                    if response.status >= 400:
                        content = await response.text()
                        raise SoulseekClientError(
                            f"slskd error {response.status}: {content[:200]}"
                        )
                    if "application/json" in response.headers.get("Content-Type", ""):
                        return await response.json()
                    return await response.text()
            except (aiohttp.ClientError, SoulseekClientError) as exc:
                if attempt == self._max_retries:
                    logger.error("Soulseek request failed: %s", exc)
                    raise
                await asyncio.sleep(backoff)
                backoff *= 2

    async def close(self) -> None:
        if self._session_owner and self._session and not self._session.closed:
            await self._session.close()

    async def search(self, query: str) -> Dict[str, Any]:
        payload = {"searchText": query, "filterResponses": True}
        return await self._request("POST", "searches", json=payload)

    async def download(self, payload: Dict[str, Any]) -> Dict[str, Any]:
        username = payload.get("username")
        if not username:
            raise ValueError("username is required for download requests")
        downloads = payload.get("files")
        if not isinstance(downloads, list) or not downloads:
            raise ValueError("files must be a non-empty list")
        return await self._request("POST", f"transfers/downloads/{username}", json=downloads)

    async def get_download_status(self) -> Dict[str, Any]:
        return await self._request("GET", "transfers/downloads")

    async def cancel_download(self, download_id: str) -> Dict[str, Any]:
        return await self._request("DELETE", f"transfers/downloads/{download_id}")

    async def get_download(self, download_id: str) -> Dict[str, Any]:
        return await self._request("GET", f"transfers/downloads/{download_id}")

    async def get_all_downloads(self) -> List[Dict[str, Any]]:
        result = await self._request("GET", "transfers/downloads/all")
        if isinstance(result, list):
            return result
        if isinstance(result, dict) and "downloads" in result:
            payload = result["downloads"]
            return payload if isinstance(payload, list) else [payload]
        return [result]

    async def remove_completed_downloads(self) -> Dict[str, Any]:
        return await self._request("DELETE", "transfers/downloads/completed")

    async def get_queue_position(self, download_id: str) -> Dict[str, Any]:
        return await self._request("GET", f"transfers/downloads/{download_id}/queue")

    async def enqueue(self, username: str, files: List[Dict[str, Any]]) -> Dict[str, Any]:
        if not username:
            raise ValueError("username is required for enqueue requests")
        if not isinstance(files, list) or not files:
            raise ValueError("files must be a non-empty list")
        payload = {"username": username, "files": files}
        return await self._request("POST", "transfers/enqueue", json=payload)

    async def cancel_upload(self, upload_id: str) -> Dict[str, Any]:
        return await self._request("DELETE", f"transfers/uploads/{upload_id}")

    async def get_upload(self, upload_id: str) -> Dict[str, Any]:
        return await self._request("GET", f"transfers/uploads/{upload_id}")

    async def get_uploads(self) -> List[Dict[str, Any]]:
        result = await self._request("GET", "transfers/uploads")
        if isinstance(result, list):
            return result
        if isinstance(result, dict) and "uploads" in result:
            payload = result["uploads"]
            return payload if isinstance(payload, list) else [payload]
        return [result]

    async def get_all_uploads(self) -> List[Dict[str, Any]]:
        result = await self._request("GET", "transfers/uploads/all")
        if isinstance(result, list):
            return result
        if isinstance(result, dict) and "uploads" in result:
            payload = result["uploads"]
            return payload if isinstance(payload, list) else [payload]
        return [result]

    async def remove_completed_uploads(self) -> Dict[str, Any]:
        return await self._request("DELETE", "transfers/uploads/completed")

    async def user_address(self, username: str) -> Dict[str, Any]:
        return await self._request("GET", f"users/{username}/address")

    async def user_browse(self, username: str) -> Dict[str, Any]:
        return await self._request("GET", f"users/{username}/browse")

    async def user_browsing_status(self, username: str) -> Dict[str, Any]:
        return await self._request("GET", f"users/{username}/browsing-status")

    async def user_directory(self, username: str, path: str) -> Dict[str, Any]:
        return await self._request("GET", f"users/{username}/directory", params={"path": path})

    async def user_info(self, username: str) -> Dict[str, Any]:
        return await self._request("GET", f"users/{username}/info")

    async def user_status(self, username: str) -> Dict[str, Any]:
        return await self._request("GET", f"users/{username}/status")

// FILE: app/core/spotify_client.py
"""Spotify client wrapper used by Harmony."""
from __future__ import annotations

import threading
import time
from typing import Any, Dict, List, Optional

from app.config import SpotifyConfig
from app.logging import get_logger

try:  # pragma: no cover - import guard
    import spotipy
    from spotipy import Spotify
    from spotipy.oauth2 import SpotifyOAuth
    from spotipy.exceptions import SpotifyException
except Exception:  # pragma: no cover - during tests we mock the client
    spotipy = None
    Spotify = Any  # type: ignore
    SpotifyOAuth = Any  # type: ignore

    class SpotifyException(Exception):  # type: ignore
        http_status: Optional[int] = None


logger = get_logger(__name__)


class SpotifyClient:
    """High level client around Spotipy with rate limiting and retries."""

    def __init__(
        self,
        config: SpotifyConfig,
        client: Optional[Spotify] = None,
        rate_limit_seconds: float = 0.2,
        max_retries: int = 3,
    ) -> None:
        self._config = config
        self._rate_limit_seconds = rate_limit_seconds
        self._max_retries = max_retries
        self._lock = threading.Lock()
        self._last_request_time = 0.0

        if client is not None:
            self._client = client
        else:
            if spotipy is None:
                raise RuntimeError("spotipy is required for SpotifyClient but is not installed")
            if not (config.client_id and config.client_secret and config.redirect_uri):
                raise ValueError("Spotify configuration is incomplete")

            auth_manager = SpotifyOAuth(
                client_id=config.client_id,
                client_secret=config.client_secret,
                redirect_uri=config.redirect_uri,
                scope=config.scope,
            )
            self._client = spotipy.Spotify(auth_manager=auth_manager)

    def _respect_rate_limit(self) -> None:
        with self._lock:
            now = time.monotonic()
            elapsed = now - self._last_request_time
            if elapsed < self._rate_limit_seconds:
                time.sleep(self._rate_limit_seconds - elapsed)
            self._last_request_time = time.monotonic()

    def _execute(self, func, *args, **kwargs):
        backoff = 0.5
        for attempt in range(1, self._max_retries + 1):
            self._respect_rate_limit()
            try:
                return func(*args, **kwargs)
            except SpotifyException as exc:  # pragma: no cover - network errors are mocked in tests
                status = getattr(exc, "http_status", None)
                if status not in {429, 502, 503} or attempt == self._max_retries:
                    logger.error("Spotify API request failed", exc_info=exc)
                    raise
                logger.warning("Retrying Spotify API request due to status %s", status)
                time.sleep(backoff)
                backoff *= 2
            except Exception as exc:  # pragma: no cover
                if attempt == self._max_retries:
                    raise
                logger.warning("Retrying Spotify API request due to %s", exc)
                time.sleep(backoff)
                backoff *= 2

    def is_authenticated(self) -> bool:
        try:
            profile = self._execute(self._client.current_user)
        except Exception:
            return False
        return bool(profile)

    def search_tracks(self, query: str, limit: int = 20) -> Dict[str, Any]:
        return self._execute(self._client.search, q=query, type="track", limit=limit)

    def search_artists(self, query: str, limit: int = 20) -> Dict[str, Any]:
        return self._execute(self._client.search, q=query, type="artist", limit=limit)

    def search_albums(self, query: str, limit: int = 20) -> Dict[str, Any]:
        return self._execute(self._client.search, q=query, type="album", limit=limit)

    def get_user_playlists(self, limit: int = 50) -> Dict[str, Any]:
        return self._execute(self._client.current_user_playlists, limit=limit)

    def get_track_details(self, track_id: str) -> Dict[str, Any]:
        return self._execute(self._client.track, track_id)

    def get_audio_features(self, track_id: str) -> Dict[str, Any]:
        features = self._execute(self._client.audio_features, [track_id]) or []
        return features[0] if features else {}

    def get_multiple_audio_features(self, track_ids: List[str]) -> Dict[str, Any]:
        features = self._execute(self._client.audio_features, track_ids)
        return {"audio_features": features or []}

    def get_playlist_items(self, playlist_id: str, limit: int = 100) -> Dict[str, Any]:
        return self._execute(self._client.playlist_items, playlist_id, limit=limit)

    def add_tracks_to_playlist(self, playlist_id: str, track_uris: List[str]) -> Dict[str, Any]:
        return self._execute(self._client.playlist_add_items, playlist_id, track_uris)

    def remove_tracks_from_playlist(self, playlist_id: str, track_uris: List[str]) -> Dict[str, Any]:
        return self._execute(
            self._client.playlist_remove_all_occurrences_of_items, playlist_id, track_uris
        )

    def reorder_playlist_items(
        self, playlist_id: str, range_start: int, insert_before: int
    ) -> Dict[str, Any]:
        return self._execute(
            self._client.playlist_reorder_items,
            playlist_id,
            range_start=range_start,
            insert_before=insert_before,
        )

    def get_saved_tracks(self, limit: int = 20) -> Dict[str, Any]:
        return self._execute(self._client.current_user_saved_tracks, limit=limit)

    def save_tracks(self, track_ids: List[str]) -> Dict[str, Any]:
        return self._execute(self._client.current_user_saved_tracks_add, track_ids)

    def remove_saved_tracks(self, track_ids: List[str]) -> Dict[str, Any]:
        return self._execute(self._client.current_user_saved_tracks_delete, track_ids)

    def get_current_user(self) -> Dict[str, Any]:
        return self._execute(self._client.current_user)

    def get_top_tracks(self, limit: int = 20) -> Dict[str, Any]:
        return self._execute(self._client.current_user_top_tracks, limit=limit)

    def get_top_artists(self, limit: int = 20) -> Dict[str, Any]:
        return self._execute(self._client.current_user_top_artists, limit=limit)

    def get_recommendations(
        self,
        seed_tracks: Optional[List[str]] = None,
        seed_artists: Optional[List[str]] = None,
        seed_genres: Optional[List[str]] = None,
        limit: int = 20,
    ) -> Dict[str, Any]:
        params: Dict[str, Any] = {"limit": limit}
        if seed_tracks:
            params["seed_tracks"] = seed_tracks
        if seed_artists:
            params["seed_artists"] = seed_artists
        if seed_genres:
            params["seed_genres"] = seed_genres
        return self._execute(self._client.recommendations, **params)

// FILE: app/db.py
"""Database configuration and helper utilities."""
from __future__ import annotations

from contextlib import contextmanager
from pathlib import Path
from typing import Iterator, Optional

from sqlalchemy import Engine, create_engine
from sqlalchemy.engine import make_url
from sqlalchemy.orm import DeclarativeBase, Session, sessionmaker

from app.config import load_config


class Base(DeclarativeBase):
    pass


_engine: Optional[Engine] = None
SessionLocal: Optional[sessionmaker[Session]] = None
_configured_database_url: Optional[str] = None
_initializing_db: bool = False


def _build_engine(database_url: str) -> Engine:
    connect_args = {"check_same_thread": False} if database_url.startswith("sqlite") else {}
    return create_engine(database_url, connect_args=connect_args)


def _resolve_sqlite_path(database_url: str) -> Optional[Path]:
    try:
        url = make_url(database_url)
    except Exception:  # pragma: no cover - defensive parsing
        return None

    if url.get_backend_name() != "sqlite":
        return None

    database = url.database or ""
    if database in {":memory:", ""}:
        return None

    return Path(database)


def _ensure_engine(*, auto_init: bool = True) -> None:
    global _engine, SessionLocal, _configured_database_url, _initializing_db

    config = load_config()
    database_url = config.database.url
    sqlite_path = _resolve_sqlite_path(database_url)

    reuse_existing = False
    if _engine is not None and database_url == _configured_database_url:
        if sqlite_path is None or sqlite_path.exists() or not auto_init:
            reuse_existing = True

    if reuse_existing:
        return

    if _engine is not None:
        _engine.dispose()

    _engine = _build_engine(database_url)
    SessionLocal = sessionmaker(
        bind=_engine,
        autoflush=False,
        autocommit=False,
        expire_on_commit=False,
    )
    _configured_database_url = database_url

    if (
        auto_init
        and not _initializing_db
        and sqlite_path is not None
        and not sqlite_path.exists()
    ):
        init_db()


def get_session() -> Session:
    if SessionLocal is None:
        _ensure_engine()
    assert SessionLocal is not None  # For type checkers
    return SessionLocal()


@contextmanager
def session_scope() -> Iterator[Session]:
    session = get_session()
    try:
        yield session
        session.commit()
    except Exception:
        session.rollback()
        raise
    finally:
        session.close()


def init_db() -> None:
    global _initializing_db

    if _initializing_db:
        return

    _initializing_db = True
    try:
        _ensure_engine(auto_init=False)
        assert _engine is not None
        from app import models  # Import models for metadata

        Base.metadata.create_all(bind=_engine)
    finally:
        _initializing_db = False


def reset_engine_for_tests() -> None:
    """Reset the cached engine/session so tests get a clean database handle."""

    global _engine, SessionLocal, _configured_database_url, _initializing_db

    if _engine is not None:
        _engine.dispose()

    _engine = None
    SessionLocal = None
    _configured_database_url = None
    _initializing_db = False


__all__ = [
    "Base",
    "SessionLocal",
    "get_session",
    "session_scope",
    "init_db",
    "reset_engine_for_tests",
    "_engine",
]

// FILE: app/dependencies.py
"""FastAPI dependency providers."""
from __future__ import annotations

from functools import lru_cache
from typing import Generator

from sqlalchemy.orm import Session

from app.config import AppConfig, load_config
from app.core.matching_engine import MusicMatchingEngine
from app.core.plex_client import PlexClient
from app.core.soulseek_client import SoulseekClient
from app.core.spotify_client import SpotifyClient
from app.db import get_session


@lru_cache()
def get_app_config() -> AppConfig:
    return load_config()


@lru_cache()
def get_spotify_client() -> SpotifyClient:
    return SpotifyClient(get_app_config().spotify)


@lru_cache()
def get_plex_client() -> PlexClient:
    return PlexClient(get_app_config().plex)


@lru_cache()
def get_soulseek_client() -> SoulseekClient:
    return SoulseekClient(get_app_config().soulseek)


@lru_cache()
def get_matching_engine() -> MusicMatchingEngine:
    return MusicMatchingEngine()


def get_db() -> Generator[Session, None, None]:
    session = get_session()
    try:
        yield session
    finally:
        session.close()

// FILE: app/logging.py
"""Logging configuration utilities."""
from __future__ import annotations

import logging
import sys
from typing import Optional


LOG_FORMAT = "%(asctime)s [%(levelname)s] %(name)s: %(message)s"


def configure_logging(level: str = "INFO", log_file: Optional[str] = None) -> None:
    """Configure application wide logging handlers."""
    handlers: list[logging.Handler] = [logging.StreamHandler(sys.stdout)]
    if log_file:
        handlers.append(logging.FileHandler(log_file))

    logging.basicConfig(
        level=getattr(logging, level.upper(), logging.INFO),
        format=LOG_FORMAT,
        handlers=handlers,
        force=True,
    )


def get_logger(name: str) -> logging.Logger:
    return logging.getLogger(name)

// FILE: app/main.py
"""Entry point for the Harmony FastAPI application."""
from __future__ import annotations

import os

import inspect

from fastapi import FastAPI

from app.dependencies import (
    get_app_config,
    get_matching_engine,
    get_plex_client,
    get_soulseek_client,
    get_spotify_client,
)
from app.db import init_db
from app.logging import configure_logging, get_logger
from app.routers import matching_router, plex_router, settings_router, soulseek_router, spotify_router
from app.workers import MatchingWorker, PlaylistSyncWorker, ScanWorker, SyncWorker

app = FastAPI(title="Harmony Backend", version="1.4.0")
logger = get_logger(__name__)

app.include_router(spotify_router, prefix="/spotify", tags=["Spotify"])
app.include_router(plex_router, prefix="/plex", tags=["Plex"])
app.include_router(soulseek_router, prefix="/soulseek", tags=["Soulseek"])
app.include_router(matching_router, prefix="/matching", tags=["Matching"])
app.include_router(settings_router, prefix="/settings", tags=["Settings"])


@app.on_event("startup")
async def startup_event() -> None:
    config = get_app_config()
    configure_logging(config.logging.level)
    init_db()
    logger.info("Database initialised")

    if os.getenv("HARMONY_DISABLE_WORKERS") not in {"1", "true", "TRUE"}:
        soulseek_client = get_soulseek_client()
        matching_engine = get_matching_engine()
        plex_client = get_plex_client()
        spotify_client = get_spotify_client()

        app.state.sync_worker = SyncWorker(soulseek_client)
        await app.state.sync_worker.start()

        app.state.matching_worker = MatchingWorker(matching_engine)
        await app.state.matching_worker.start()

        app.state.scan_worker = ScanWorker(plex_client)
        await app.state.scan_worker.start()

        app.state.playlist_worker = PlaylistSyncWorker(spotify_client)
        await app.state.playlist_worker.start()

    logger.info("Harmony application started")


@app.on_event("shutdown")
async def shutdown_event() -> None:
    if worker := getattr(app.state, "sync_worker", None):
        await worker.stop()
    if worker := getattr(app.state, "matching_worker", None):
        await worker.stop()
    if worker := getattr(app.state, "scan_worker", None):
        await worker.stop()
    if worker := getattr(app.state, "playlist_worker", None):
        await worker.stop()
    try:
        plex_client = get_plex_client()
    except ValueError:
        plex_client = None
    close_fn = getattr(plex_client, "close", None)
    if callable(close_fn):
        result = close_fn()
        if inspect.isawaitable(result):
            await result
    logger.info("Harmony application stopped")


@app.get("/")
async def root() -> dict[str, str]:
    return {"status": "ok", "version": app.version}

// FILE: app/models.py
"""Database models for Harmony."""
from __future__ import annotations

from datetime import datetime

from sqlalchemy import Column, DateTime, Float, Integer, String, Text

from app.db import Base


class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    username = Column(String(255), unique=True, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)


class Playlist(Base):
    __tablename__ = "playlists"

    id = Column(String(128), primary_key=True)
    name = Column(String(512), nullable=False)
    track_count = Column(Integer, nullable=False, default=0)
    updated_at = Column(
        DateTime,
        default=datetime.utcnow,
        onupdate=datetime.utcnow,
        nullable=False,
    )


class Download(Base):
    __tablename__ = "downloads"

    id = Column(Integer, primary_key=True, index=True)
    filename = Column(String(1024), nullable=False)
    state = Column(String(50), nullable=False, default="queued")
    progress = Column(Float, nullable=False, default=0.0)
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(
        DateTime,
        default=datetime.utcnow,
        onupdate=datetime.utcnow,
        nullable=False,
    )


class Match(Base):
    __tablename__ = "matches"

    id = Column(Integer, primary_key=True, index=True)
    source = Column(String(50), nullable=False)
    spotify_track_id = Column(String(128), index=True, nullable=False)
    target_id = Column(String(128), nullable=True)
    confidence = Column(Float, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)


class Setting(Base):
    __tablename__ = "settings"

    id = Column(Integer, primary_key=True, index=True)
    key = Column(String(255), unique=True, nullable=False)
    value = Column(Text, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)


class SettingHistory(Base):
    __tablename__ = "settings_history"

    id = Column(Integer, primary_key=True, index=True)
    key = Column(String(255), nullable=False)
    old_value = Column(Text, nullable=True)
    new_value = Column(Text, nullable=True)
    changed_at = Column(DateTime, default=datetime.utcnow, nullable=False)

// FILE: app/routers/__init__.py
"""Expose API routers."""
from .matching_router import router as matching_router
from .plex_router import router as plex_router
from .settings_router import router as settings_router
from .soulseek_router import router as soulseek_router
from .spotify_router import router as spotify_router

__all__ = [
    "matching_router",
    "plex_router",
    "settings_router",
    "soulseek_router",
    "spotify_router",
]

// FILE: app/routers/beets_router.py
from typing import List, Optional

from fastapi import APIRouter, HTTPException
from fastapi.concurrency import run_in_threadpool
from pydantic import BaseModel

from app.core.beets_client import BeetsClient, BeetsClientError
from app.utils.logging_config import get_logger

logger = get_logger("beets_router")

router = APIRouter()
beets_client = BeetsClient()


# ----------------------------
# Request / Response Schemas
# ----------------------------


class ImportRequest(BaseModel):
    path: str
    quiet: bool = True
    autotag: bool = True


class ImportResponse(BaseModel):
    success: bool
    message: str


class UpdateRequest(BaseModel):
    path: Optional[str] = None


class UpdateResponse(BaseModel):
    success: bool
    message: str


class RemoveRequest(BaseModel):
    query: str
    force: bool = False


class RemoveResponse(BaseModel):
    success: bool
    removed: Optional[int] = None
    output: Optional[str] = None


class MoveRequest(BaseModel):
    query: Optional[str] = None


class MoveResponse(BaseModel):
    success: bool
    moved: Optional[int] = None
    output: Optional[str] = None


class WriteRequest(BaseModel):
    query: Optional[str] = None


class WriteResponse(BaseModel):
    success: bool
    written: Optional[int] = None
    output: Optional[str] = None


class ListAlbumsResponse(BaseModel):
    albums: List[str]


class ListTracksResponse(BaseModel):
    tracks: List[str]


class FieldsResponse(BaseModel):
    fields: List[str]


class QueryRequest(BaseModel):
    query: str
    format: str = "$artist - $album - $title"


class QueryResponse(BaseModel):
    results: List[str]


# ----------------------------
# Helper functions
# ----------------------------


async def _call_client(method, *args, **kwargs):
    try:
        return await run_in_threadpool(method, *args, **kwargs)
    except BeetsClientError as exc:
        detail = str(exc)
        if detail.startswith("Invalid query syntax"):
            logger.error("Invalid query syntax: %s", detail)
            raise HTTPException(status_code=400, detail="Invalid query syntax") from exc
        if detail == "Query must not be empty":
            logger.error("Empty query provided")
            raise HTTPException(status_code=400, detail=detail) from exc
        logger.error("Beets client error: %s", detail)
        raise HTTPException(status_code=500, detail=detail) from exc
    except Exception as exc:  # pragma: no cover - defensive
        logger.error("Unexpected error running beets: %s", exc)
        raise HTTPException(status_code=500, detail=str(exc)) from exc


# ----------------------------
# Endpoints
# ----------------------------


@router.post("/import", response_model=ImportResponse)
async def import_music(req: ImportRequest) -> ImportResponse:
    """Import new music into the Beets library."""

    output = await _call_client(
        beets_client.import_file,
        req.path,
        quiet=req.quiet,
        autotag=req.autotag,
    )
    return ImportResponse(success=True, message=output or "Import completed")


@router.post("/update", response_model=UpdateResponse)
async def update_library(req: UpdateRequest) -> UpdateResponse:
    """Update Beets library metadata, optionally for a specific path."""

    output = await _call_client(beets_client.update, req.path)
    return UpdateResponse(success=True, message=output or "Library updated")


@router.post(
    "/remove", response_model=RemoveResponse, response_model_exclude_none=True
)
async def remove_items(req: RemoveRequest) -> RemoveResponse:
    """Remove library items that match a query."""

    result = await _call_client(beets_client.remove, req.query, force=req.force)
    return RemoveResponse(**result)


@router.post(
    "/move", response_model=MoveResponse, response_model_exclude_none=True
)
async def move_items(req: MoveRequest) -> MoveResponse:
    """Move files in the Beets library, optionally filtering by a query."""

    result = await _call_client(beets_client.move, req.query)
    return MoveResponse(**result)


@router.post(
    "/write", response_model=WriteResponse, response_model_exclude_none=True
)
async def write_tags(req: WriteRequest) -> WriteResponse:
    """Write tags to files, optionally filtering by a query."""

    result = await _call_client(beets_client.write, req.query)
    return WriteResponse(**result)


@router.get("/albums", response_model=ListAlbumsResponse)
async def list_albums() -> ListAlbumsResponse:
    """List all albums managed by Beets."""

    albums = await _call_client(beets_client.list_albums)
    return ListAlbumsResponse(albums=albums)


@router.get("/tracks", response_model=ListTracksResponse)
async def list_tracks() -> ListTracksResponse:
    """List all track titles managed by Beets."""

    tracks = await _call_client(beets_client.list_tracks)
    return ListTracksResponse(tracks=tracks)


@router.get("/stats")
async def library_stats() -> dict:
    """Return statistics about the Beets library."""

    stats = await _call_client(beets_client.stats)
    return {"stats": stats}


@router.get("/fields", response_model=FieldsResponse)
async def list_fields() -> FieldsResponse:
    """Return all available Beets fields."""

    fields = await _call_client(beets_client.fields)
    return FieldsResponse(fields=fields)


@router.post("/query", response_model=QueryResponse)
async def run_query(req: QueryRequest) -> QueryResponse:
    """Execute a formatted Beets query."""

    results = await _call_client(
        beets_client.query, req.query, fmt=req.format
    )
    return QueryResponse(results=results)

// FILE: app/routers/matching_router.py
"""Matching endpoints for Harmony."""
from __future__ import annotations

from typing import Any, Dict, Optional

from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session

from app.core.matching_engine import MusicMatchingEngine
from app.dependencies import get_db, get_matching_engine
from app.logging import get_logger
from app.models import Match
from app.schemas import AlbumMatchingRequest, MatchingRequest, MatchingResponse

logger = get_logger(__name__)

router = APIRouter()


def _extract_target_id(candidate: Optional[Dict[str, Any]]) -> Optional[str]:
    if not candidate:
        return None
    for key in ("id", "ratingKey", "filename"):
        value = candidate.get(key)
        if value is not None:
            return str(value)
    return None


def _persist_match(session: Session, match: Match) -> None:
    """Persist a match, rolling back on failure."""

    try:
        session.add(match)
        session.commit()
    except Exception as exc:  # pragma: no cover - database failure is exceptional
        session.rollback()
        logger.error("Failed to persist match %s: %s", match, exc)
        raise HTTPException(status_code=500, detail="Failed to store match result") from exc


@router.post("/spotify-to-plex", response_model=MatchingResponse)
def spotify_to_plex(
    payload: MatchingRequest,
    engine: MusicMatchingEngine = Depends(get_matching_engine),
    session: Session = Depends(get_db),
) -> MatchingResponse:
    """Match a Spotify track against Plex candidates and persist the result."""

    best_match, confidence = engine.find_best_match(payload.spotify_track, payload.candidates)
    target_id = _extract_target_id(best_match)
    match = Match(
        source="spotify-to-plex",
        spotify_track_id=str(payload.spotify_track.get("id")),
        target_id=target_id,
        confidence=confidence,
    )
    _persist_match(session, match)
    return MatchingResponse(best_match=best_match, confidence=confidence)


@router.post("/spotify-to-soulseek", response_model=MatchingResponse)
def spotify_to_soulseek(
    payload: MatchingRequest,
    engine: MusicMatchingEngine = Depends(get_matching_engine),
    session: Session = Depends(get_db),
) -> MatchingResponse:
    """Match a Spotify track against Soulseek candidates and persist the result."""

    best_candidate: Optional[Dict[str, Any]] = None
    best_score = 0.0
    for candidate in payload.candidates:
        score = engine.calculate_slskd_match_confidence(payload.spotify_track, candidate)
        if score > best_score:
            best_score = score
            best_candidate = candidate
    target_id = _extract_target_id(best_candidate)
    match = Match(
        source="spotify-to-soulseek",
        spotify_track_id=str(payload.spotify_track.get("id")),
        target_id=target_id,
        confidence=best_score,
    )
    _persist_match(session, match)
    return MatchingResponse(best_match=best_candidate, confidence=best_score)


@router.post("/spotify-to-plex-album", response_model=MatchingResponse)
def spotify_to_plex_album(
    payload: AlbumMatchingRequest, engine: MusicMatchingEngine = Depends(get_matching_engine)
) -> MatchingResponse:
    """Return the best matching Plex album for the provided Spotify album."""

    best_match, confidence = engine.find_best_album_match(payload.spotify_album, payload.candidates)
    return MatchingResponse(best_match=best_match, confidence=confidence)

// FILE: app/routers/plex_router.py
"""Extended Plex API endpoints exposed through FastAPI."""
from __future__ import annotations

from typing import Any, AsyncIterator, Dict

from fastapi import APIRouter, Depends, HTTPException, Request, status
from fastapi.responses import StreamingResponse

from app.core.plex_client import PlexClient, PlexClientError
from app.dependencies import get_plex_client
from app.logging import get_logger

logger = get_logger(__name__)

router = APIRouter()


def _collect_query_params(request: Request) -> Dict[str, Any]:
    return {key: value for key, value in request.query_params.multi_items()}


@router.get("/status")
async def plex_status(client: PlexClient = Depends(get_plex_client)) -> Dict[str, Any]:
    try:
        sessions = await client.get_sessions()
        stats = await client.get_library_statistics()
    except Exception as exc:  # pragma: no cover - defensive logging
        logger.error("Failed to query Plex status: %s", exc)
        return {"status": "disconnected"}
    return {"status": "connected", "sessions": sessions, "library": stats}


@router.get("/library/sections")
async def list_libraries(
    request: Request, client: PlexClient = Depends(get_plex_client)
) -> Dict[str, Any]:
    try:
        params = _collect_query_params(request)
        return await client.get_libraries(params=params or None)
    except PlexClientError as exc:
        raise HTTPException(status_code=status.HTTP_502_BAD_GATEWAY, detail=str(exc)) from exc


@router.get("/libraries", include_in_schema=False)
async def list_libraries_legacy(
    request: Request, client: PlexClient = Depends(get_plex_client)
) -> Dict[str, Any]:
    """Backward compatible alias for :func:`list_libraries`."""

    return await list_libraries(request, client)


@router.get("/library/sections/{section_id}/all")
async def browse_library(
    section_id: str, request: Request, client: PlexClient = Depends(get_plex_client)
) -> Dict[str, Any]:
    try:
        params = _collect_query_params(request)
        return await client.get_library_items(section_id, params=params or None)
    except PlexClientError as exc:
        raise HTTPException(status_code=status.HTTP_502_BAD_GATEWAY, detail=str(exc)) from exc


@router.get("/library/{section_id}/items", include_in_schema=False)
async def browse_library_legacy(
    section_id: str, request: Request, client: PlexClient = Depends(get_plex_client)
) -> Dict[str, Any]:
    """Backward compatible alias for :func:`browse_library`."""

    return await browse_library(section_id, request, client)


@router.get("/library/metadata/{item_id}")
async def fetch_metadata(item_id: str, client: PlexClient = Depends(get_plex_client)) -> Dict[str, Any]:
    try:
        return await client.get_metadata(item_id)
    except PlexClientError as exc:
        raise HTTPException(status_code=status.HTTP_502_BAD_GATEWAY, detail=str(exc)) from exc


@router.get("/metadata/{item_id}", include_in_schema=False)
async def fetch_metadata_legacy(
    item_id: str, client: PlexClient = Depends(get_plex_client)
) -> Dict[str, Any]:
    """Backward compatible alias for :func:`fetch_metadata`."""

    return await fetch_metadata(item_id, client)


@router.get("/status/sessions")
async def active_sessions(client: PlexClient = Depends(get_plex_client)) -> Dict[str, Any]:
    return await client.get_sessions()


@router.get("/sessions", include_in_schema=False)
async def active_sessions_legacy(client: PlexClient = Depends(get_plex_client)) -> Dict[str, Any]:
    """Backward compatible alias for :func:`active_sessions`."""

    return await active_sessions(client)


@router.get("/status/sessions/history/all")
async def session_history(
    request: Request, client: PlexClient = Depends(get_plex_client)
) -> Dict[str, Any]:
    params = _collect_query_params(request)
    return await client.get_session_history(params=params or None)


@router.get("/history", include_in_schema=False)
async def session_history_legacy(
    request: Request, client: PlexClient = Depends(get_plex_client)
) -> Dict[str, Any]:
    """Backward compatible alias for :func:`session_history`."""

    return await session_history(request, client)


@router.get("/timeline")
async def get_timeline(
    request: Request, client: PlexClient = Depends(get_plex_client)
) -> Dict[str, Any]:
    params = _collect_query_params(request)
    return await client.get_timeline(params=params or None)


@router.post("/timeline")
async def post_timeline(payload: Dict[str, Any], client: PlexClient = Depends(get_plex_client)) -> str:
    return await client.update_timeline(payload)


@router.post("/scrobble")
async def post_scrobble(payload: Dict[str, Any], client: PlexClient = Depends(get_plex_client)) -> str:
    return await client.scrobble(payload)


@router.post("/unscrobble")
async def post_unscrobble(payload: Dict[str, Any], client: PlexClient = Depends(get_plex_client)) -> str:
    return await client.unscrobble(payload)


@router.get("/playlists")
async def list_playlists(client: PlexClient = Depends(get_plex_client)) -> Dict[str, Any]:
    return await client.get_playlists()


@router.post("/playlists")
async def create_playlist(
    payload: Dict[str, Any], client: PlexClient = Depends(get_plex_client)
) -> Dict[str, Any]:
    return await client.create_playlist(payload)


@router.put("/playlists/{playlist_id}")
async def update_playlist(
    playlist_id: str, payload: Dict[str, Any], client: PlexClient = Depends(get_plex_client)
) -> Dict[str, Any]:
    return await client.update_playlist(playlist_id, payload)


@router.delete("/playlists/{playlist_id}")
async def delete_playlist(playlist_id: str, client: PlexClient = Depends(get_plex_client)) -> Dict[str, Any]:
    return await client.delete_playlist(playlist_id)


@router.post("/playQueues")
async def create_playqueue(
    payload: Dict[str, Any], client: PlexClient = Depends(get_plex_client)
) -> Dict[str, Any]:
    return await client.create_playqueue(payload)


@router.get("/playQueues/{playqueue_id}")
async def get_playqueue(playqueue_id: str, client: PlexClient = Depends(get_plex_client)) -> Dict[str, Any]:
    return await client.get_playqueue(playqueue_id)


@router.post("/rate")
async def rate_item(payload: Dict[str, Any], client: PlexClient = Depends(get_plex_client)) -> str:
    item_id = payload.get("key")
    rating = payload.get("rating")
    if not item_id or rating is None:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Both 'key' and 'rating' must be provided",
        )
    return await client.rate_item(str(item_id), int(rating))


@router.post("/rate/{item_id}", include_in_schema=False)
async def rate_item_legacy(
    item_id: str, rating: int, client: PlexClient = Depends(get_plex_client)
) -> str:
    """Backward compatible alias for :func:`rate_item`."""

    return await client.rate_item(item_id, rating)


@router.post("/tags/{item_id}")
async def sync_tags(
    item_id: str, payload: Dict[str, Any], client: PlexClient = Depends(get_plex_client)
) -> Dict[str, Any]:
    tags = {key: value for key, value in payload.items() if isinstance(value, list)}
    return await client.sync_tags(item_id, tags)


@router.get("/devices")
async def list_devices(client: PlexClient = Depends(get_plex_client)) -> Dict[str, Any]:
    return await client.get_devices()


@router.get("/dvr")
async def list_dvr(client: PlexClient = Depends(get_plex_client)) -> Dict[str, Any]:
    return await client.get_dvr()


@router.get("/livetv")
async def list_live_tv(
    request: Request, client: PlexClient = Depends(get_plex_client)
) -> Dict[str, Any]:
    params = _collect_query_params(request)
    return await client.get_live_tv(params=params or None)


@router.get("/notifications")
async def listen_notifications(client: PlexClient = Depends(get_plex_client)) -> StreamingResponse:
    async def event_stream() -> AsyncIterator[bytes]:
        try:
            async with client.listen_notifications() as websocket:
                async for message in websocket:
                    if message.type.name == "TEXT":
                        yield f"data: {message.data}\n\n".encode("utf-8")
                    elif message.type.name == "ERROR":
                        logger.error("Plex notification stream error: %s", websocket.exception())
                        break
        except Exception as exc:  # pragma: no cover - defensive logging
            logger.error("Failed to stream Plex notifications: %s", exc)
            yield f"event: error\ndata: {exc}\n\n".encode("utf-8")

    return StreamingResponse(event_stream(), media_type="text/event-stream")


// FILE: app/routers/settings_router.py
"""Settings management endpoints."""
from __future__ import annotations

from datetime import datetime

from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy import select
from sqlalchemy.orm import Session

from app.dependencies import get_db
from app.models import Setting, SettingHistory
from app.schemas import SettingsHistoryResponse, SettingsPayload, SettingsResponse

router = APIRouter()


@router.get("", response_model=SettingsResponse)
def get_settings(session: Session = Depends(get_db)) -> SettingsResponse:
    settings = session.execute(select(Setting)).scalars().all()
    settings_dict = {setting.key: setting.value for setting in settings}
    updated_at = max((setting.updated_at or setting.created_at for setting in settings), default=datetime.utcnow())
    return SettingsResponse(settings=settings_dict, updated_at=updated_at)


@router.post("", response_model=SettingsResponse)
def update_setting(payload: SettingsPayload, session: Session = Depends(get_db)) -> SettingsResponse:
    if not payload.key:
        raise HTTPException(status_code=400, detail="Key must not be empty")
    setting = session.execute(select(Setting).where(Setting.key == payload.key)).scalar_one_or_none()
    now = datetime.utcnow()

    history_entry = SettingHistory(
        key=payload.key,
        old_value=setting.value if setting is not None else None,
        new_value=payload.value,
        changed_at=now,
    )
    session.add(history_entry)

    if setting is None:
        setting = Setting(key=payload.key, value=payload.value, updated_at=now)
        session.add(setting)
    else:
        setting.value = payload.value
        setting.updated_at = now
    session.commit()
    return get_settings(session)


@router.get("/history", response_model=SettingsHistoryResponse)
def get_settings_history(session: Session = Depends(get_db)) -> SettingsHistoryResponse:
    history_entries = (
        session.execute(
            select(SettingHistory).order_by(SettingHistory.changed_at.desc()).limit(50)
        )
        .scalars()
        .all()
    )
    return SettingsHistoryResponse(history=history_entries)

// FILE: app/routers/soulseek_router.py
"""Soulseek API endpoints."""
from __future__ import annotations

import asyncio
from datetime import datetime
from typing import Any, Dict, List

from fastapi import APIRouter, Depends, HTTPException, Query, Request
from sqlalchemy import select
from sqlalchemy.orm import Session

from app.core.soulseek_client import SoulseekClient, SoulseekClientError
from app.dependencies import get_db, get_soulseek_client
from app.logging import get_logger
from app.models import Download
from app.schemas import (
    SoulseekCancelResponse,
    SoulseekDownloadRequest,
    SoulseekDownloadResponse,
    SoulseekDownloadStatus,
    SoulseekSearchRequest,
    SoulseekSearchResponse,
    StatusResponse,
)

logger = get_logger(__name__)

router = APIRouter()


def _translate_error(message: str, exc: SoulseekClientError) -> HTTPException:
    logger.error("%s: %s", message, exc)
    return HTTPException(status_code=502, detail=message)


@router.get("/status", response_model=StatusResponse)
async def soulseek_status(client: SoulseekClient = Depends(get_soulseek_client)) -> StatusResponse:
    """Return connectivity status for the Soulseek daemon."""

    try:
        await client.get_download_status()
    except Exception as exc:  # pragma: no cover - defensive
        logger.warning("Soulseek status check failed: %s", exc)
        return StatusResponse(status="disconnected")
    return StatusResponse(status="connected")


@router.post("/search", response_model=SoulseekSearchResponse)
async def soulseek_search(
    payload: SoulseekSearchRequest,
    client: SoulseekClient = Depends(get_soulseek_client),
) -> SoulseekSearchResponse:
    """Perform a Soulseek search and normalise the JSON response."""

    try:
        results = await client.search(payload.query)
    except SoulseekClientError as exc:
        logger.error("Soulseek search failed: %s", exc)
        raise HTTPException(status_code=502, detail="Soulseek search failed") from exc
    items: list[Any]
    raw_payload: Dict[str, Any] | None = None
    if isinstance(results, dict):
        raw_payload = results
        extracted = results.get("results", [])
        items = extracted if isinstance(extracted, list) else [extracted]
    elif isinstance(results, list):
        items = results
    else:
        items = [results] if results else []
    return SoulseekSearchResponse(results=items, raw=raw_payload)


@router.post("/download", response_model=SoulseekDownloadResponse)
async def soulseek_download(
    payload: SoulseekDownloadRequest,
    request: Request,
    session: Session = Depends(get_db),
    client: SoulseekClient = Depends(get_soulseek_client),
) -> SoulseekDownloadResponse:
    """Queue a Soulseek download job and persist queued entries."""

    if not payload.files:
        raise HTTPException(status_code=400, detail="No files provided for download")

    created_downloads: List[Dict[str, Any]] = []
    job_files: List[Dict[str, Any]] = []
    try:
        for file_info in payload.files:
            filename = str(file_info.get("filename") or file_info.get("name") or "unknown")
            download = Download(filename=filename, state="queued", progress=0.0)
            session.add(download)
            session.flush()

            payload_copy = dict(file_info)
            payload_copy.setdefault("filename", filename)
            payload_copy["download_id"] = download.id
            job_files.append(payload_copy)

            created_downloads.append(
                {
                    "id": download.id,
                    "filename": filename,
                    "state": download.state,
                    "progress": download.progress,
                }
            )
        session.commit()
    except Exception as exc:  # pragma: no cover - defensive
        session.rollback()
        logger.error("Failed to persist download request: %s", exc)
        raise HTTPException(status_code=500, detail="Failed to queue download") from exc

    job = {"username": payload.username, "files": job_files}

    worker = getattr(request.app.state, "sync_worker", None)
    try:
        if worker is not None and hasattr(worker, "enqueue"):
            await worker.enqueue(job)
        else:
            await client.download(job)
    except Exception as exc:
        if isinstance(exc, asyncio.CancelledError):  # pragma: no cover - defensive
            raise
        logger.error("Soulseek rejected download queue request: %s", exc)
        for record in job_files:
            download = session.get(Download, record["download_id"])
            if download is None:
                continue
            download.state = "failed"
            download.updated_at = datetime.utcnow()
        session.commit()
        raise HTTPException(status_code=502, detail="Soulseek download failed") from exc

    detail: Dict[str, Any] = {"downloads": created_downloads}
    return SoulseekDownloadResponse(status="queued", detail=detail)


@router.get("/downloads", response_model=SoulseekDownloadStatus)
def soulseek_downloads(session: Session = Depends(get_db)) -> SoulseekDownloadStatus:
    """Return persisted download progress from the database."""

    stmt = select(Download).order_by(Download.created_at.desc())
    downloads = session.execute(stmt).scalars().all()
    return SoulseekDownloadStatus(downloads=downloads)


@router.delete("/download/{download_id}", response_model=SoulseekCancelResponse)
async def soulseek_cancel(
    download_id: int,
    session: Session = Depends(get_db),
    client: SoulseekClient = Depends(get_soulseek_client),
) -> SoulseekCancelResponse:
    """Cancel a Soulseek download by identifier."""

    download = session.get(Download, download_id)
    if download is None:
        raise HTTPException(status_code=404, detail="Download not found")

    try:
        await client.cancel_download(str(download_id))
    except SoulseekClientError as exc:
        raise _translate_error("Failed to cancel download", exc)

    download.state = "failed"
    if download.progress < 0:
        download.progress = 0.0
    elif download.progress > 100:
        download.progress = 100.0
    download.updated_at = datetime.utcnow()
    session.commit()

    return SoulseekCancelResponse(cancelled=True)


@router.get("/download/{download_id}")
async def soulseek_download_detail(
    download_id: str,
    client: SoulseekClient = Depends(get_soulseek_client),
) -> Dict[str, Any]:
    try:
        return await client.get_download(download_id)
    except SoulseekClientError as exc:
        raise _translate_error("Failed to fetch download", exc) from exc


@router.get("/downloads/all")
async def soulseek_all_downloads(client: SoulseekClient = Depends(get_soulseek_client)) -> Dict[str, Any]:
    try:
        downloads = await client.get_all_downloads()
    except SoulseekClientError as exc:
        raise _translate_error("Failed to fetch downloads", exc) from exc
    return {"downloads": downloads}


@router.delete("/downloads/completed")
async def soulseek_remove_completed_downloads(
    client: SoulseekClient = Depends(get_soulseek_client),
) -> Dict[str, Any]:
    try:
        return await client.remove_completed_downloads()
    except SoulseekClientError as exc:
        raise _translate_error("Failed to remove completed downloads", exc) from exc


@router.get("/download/{download_id}/queue")
async def soulseek_download_queue(
    download_id: str,
    client: SoulseekClient = Depends(get_soulseek_client),
) -> Dict[str, Any]:
    try:
        return await client.get_queue_position(download_id)
    except SoulseekClientError as exc:
        raise _translate_error("Failed to fetch queue position", exc) from exc


@router.post("/enqueue")
async def soulseek_enqueue(
    payload: SoulseekDownloadRequest,
    client: SoulseekClient = Depends(get_soulseek_client),
) -> Dict[str, Any]:
    try:
        return await client.enqueue(payload.username, payload.files)
    except SoulseekClientError as exc:
        raise _translate_error("Failed to enqueue downloads", exc) from exc


@router.delete("/upload/{upload_id}")
async def soulseek_cancel_upload(
    upload_id: str,
    client: SoulseekClient = Depends(get_soulseek_client),
) -> Dict[str, Any]:
    try:
        return await client.cancel_upload(upload_id)
    except SoulseekClientError as exc:
        raise _translate_error("Failed to cancel upload", exc) from exc


@router.get("/upload/{upload_id}")
async def soulseek_upload_detail(
    upload_id: str,
    client: SoulseekClient = Depends(get_soulseek_client),
) -> Dict[str, Any]:
    try:
        return await client.get_upload(upload_id)
    except SoulseekClientError as exc:
        raise _translate_error("Failed to fetch upload", exc) from exc


@router.get("/uploads")
async def soulseek_uploads(client: SoulseekClient = Depends(get_soulseek_client)) -> Dict[str, Any]:
    try:
        uploads = await client.get_uploads()
    except SoulseekClientError as exc:
        raise _translate_error("Failed to fetch uploads", exc) from exc
    return {"uploads": uploads}


@router.get("/uploads/all")
async def soulseek_all_uploads(client: SoulseekClient = Depends(get_soulseek_client)) -> Dict[str, Any]:
    try:
        uploads = await client.get_all_uploads()
    except SoulseekClientError as exc:
        raise _translate_error("Failed to fetch all uploads", exc) from exc
    return {"uploads": uploads}


@router.delete("/uploads/completed")
async def soulseek_remove_completed_uploads(
    client: SoulseekClient = Depends(get_soulseek_client),
) -> Dict[str, Any]:
    try:
        return await client.remove_completed_uploads()
    except SoulseekClientError as exc:
        raise _translate_error("Failed to remove completed uploads", exc) from exc


@router.get("/user/{username}/address")
async def soulseek_user_address(
    username: str,
    client: SoulseekClient = Depends(get_soulseek_client),
) -> Dict[str, Any]:
    try:
        return await client.user_address(username)
    except SoulseekClientError as exc:
        raise _translate_error("Failed to fetch user address", exc) from exc


@router.get("/user/{username}/browse")
async def soulseek_user_browse(
    username: str,
    client: SoulseekClient = Depends(get_soulseek_client),
) -> Dict[str, Any]:
    try:
        return await client.user_browse(username)
    except SoulseekClientError as exc:
        raise _translate_error("Failed to browse user", exc) from exc


@router.get("/user/{username}/browsing_status")
async def soulseek_user_browsing_status(
    username: str,
    client: SoulseekClient = Depends(get_soulseek_client),
) -> Dict[str, Any]:
    try:
        return await client.user_browsing_status(username)
    except SoulseekClientError as exc:
        raise _translate_error("Failed to fetch user browsing status", exc) from exc


@router.get("/user/{username}/directory")
async def soulseek_user_directory(
    username: str,
    path: str = Query(..., description="Directory path to browse"),
    client: SoulseekClient = Depends(get_soulseek_client),
) -> Dict[str, Any]:
    try:
        return await client.user_directory(username, path)
    except SoulseekClientError as exc:
        raise _translate_error("Failed to fetch user directory", exc) from exc


@router.get("/user/{username}/info")
async def soulseek_user_info(
    username: str,
    client: SoulseekClient = Depends(get_soulseek_client),
) -> Dict[str, Any]:
    try:
        return await client.user_info(username)
    except SoulseekClientError as exc:
        raise _translate_error("Failed to fetch user info", exc) from exc


@router.get("/user/{username}/status")
async def soulseek_user_status(
    username: str,
    client: SoulseekClient = Depends(get_soulseek_client),
) -> Dict[str, Any]:
    try:
        return await client.user_status(username)
    except SoulseekClientError as exc:
        raise _translate_error("Failed to fetch user status", exc) from exc

// FILE: app/routers/spotify_router.py
"""Spotify API endpoints."""
from __future__ import annotations

from typing import List, Optional

from fastapi import APIRouter, Depends, HTTPException, Query
from pydantic import BaseModel
from sqlalchemy.orm import Session

from app.core.spotify_client import SpotifyClient
from app.dependencies import get_db, get_spotify_client
from app.models import Playlist
from app.schemas import (
    AudioFeaturesResponse,
    PlaylistItemsResponse,
    PlaylistResponse,
    RecommendationsResponse,
    SavedTracksResponse,
    SpotifySearchResponse,
    StatusResponse,
    TrackDetailResponse,
    UserProfileResponse,
)

router = APIRouter()


class PlaylistTracksPayload(BaseModel):
    uris: List[str]


class PlaylistReorderPayload(BaseModel):
    range_start: int
    insert_before: int


class TrackIdsPayload(BaseModel):
    ids: List[str]


@router.get("/status", response_model=StatusResponse)
def spotify_status(client: SpotifyClient = Depends(get_spotify_client)) -> StatusResponse:
    status = "connected" if client.is_authenticated() else "unauthenticated"
    return StatusResponse(status=status)


@router.get("/search/tracks", response_model=SpotifySearchResponse)
def search_tracks(
    query: str = Query(..., min_length=1),
    client: SpotifyClient = Depends(get_spotify_client),
) -> SpotifySearchResponse:
    response = client.search_tracks(query)
    items = response.get("tracks", {}).get("items", [])
    return SpotifySearchResponse(items=items)


@router.get("/search/artists", response_model=SpotifySearchResponse)
def search_artists(
    query: str = Query(..., min_length=1),
    client: SpotifyClient = Depends(get_spotify_client),
) -> SpotifySearchResponse:
    response = client.search_artists(query)
    items = response.get("artists", {}).get("items", [])
    return SpotifySearchResponse(items=items)


@router.get("/search/albums", response_model=SpotifySearchResponse)
def search_albums(
    query: str = Query(..., min_length=1),
    client: SpotifyClient = Depends(get_spotify_client),
) -> SpotifySearchResponse:
    response = client.search_albums(query)
    items = response.get("albums", {}).get("items", [])
    return SpotifySearchResponse(items=items)


@router.get("/playlists", response_model=PlaylistResponse)
def list_playlists(db: Session = Depends(get_db)) -> PlaylistResponse:
    playlists = db.query(Playlist).order_by(Playlist.updated_at.desc()).all()
    return PlaylistResponse(playlists=playlists)


@router.get("/track/{track_id}", response_model=TrackDetailResponse)
def get_track_details(
    track_id: str,
    client: SpotifyClient = Depends(get_spotify_client),
) -> TrackDetailResponse:
    details = client.get_track_details(track_id)
    if not details:
        raise HTTPException(status_code=404, detail="Track not found")
    return TrackDetailResponse(track=details)


@router.get("/audio-features/{track_id}", response_model=AudioFeaturesResponse)
def get_audio_features(
    track_id: str,
    client: SpotifyClient = Depends(get_spotify_client),
) -> AudioFeaturesResponse:
    features = client.get_audio_features(track_id)
    if not features:
        raise HTTPException(status_code=404, detail="Audio features not found")
    return AudioFeaturesResponse(audio_features=features)


@router.get("/audio-features", response_model=AudioFeaturesResponse)
def get_multiple_audio_features(
    ids: str = Query(..., min_length=1),
    client: SpotifyClient = Depends(get_spotify_client),
) -> AudioFeaturesResponse:
    track_ids = [item.strip() for item in ids.split(",") if item.strip()]
    if not track_ids:
        raise HTTPException(status_code=400, detail="No track IDs provided")
    features = client.get_multiple_audio_features(track_ids)
    return AudioFeaturesResponse(audio_features=features.get("audio_features", []))


@router.get(
    "/playlists/{playlist_id}/tracks",
    response_model=PlaylistItemsResponse,
)
def get_playlist_items(
    playlist_id: str,
    limit: int = Query(100, ge=1, le=100),
    client: SpotifyClient = Depends(get_spotify_client),
) -> PlaylistItemsResponse:
    items = client.get_playlist_items(playlist_id, limit=limit)
    total = items.get("total")
    if total is None:
        total = items.get("tracks", {}).get("total")
    if total is None:
        total = len(items.get("items", []))
    return PlaylistItemsResponse(
        items=items.get("items", []),
        total=total,
    )


@router.post(
    "/playlists/{playlist_id}/tracks",
    response_model=StatusResponse,
)
def add_tracks_to_playlist(
    playlist_id: str,
    payload: PlaylistTracksPayload,
    client: SpotifyClient = Depends(get_spotify_client),
) -> StatusResponse:
    if not payload.uris:
        raise HTTPException(status_code=400, detail="No track URIs provided")
    client.add_tracks_to_playlist(playlist_id, payload.uris)
    return StatusResponse(status="tracks-added")


@router.delete(
    "/playlists/{playlist_id}/tracks",
    response_model=StatusResponse,
)
def remove_tracks_from_playlist(
    playlist_id: str,
    payload: PlaylistTracksPayload,
    client: SpotifyClient = Depends(get_spotify_client),
) -> StatusResponse:
    if not payload.uris:
        raise HTTPException(status_code=400, detail="No track URIs provided")
    client.remove_tracks_from_playlist(playlist_id, payload.uris)
    return StatusResponse(status="tracks-removed")


@router.put(
    "/playlists/{playlist_id}/reorder",
    response_model=StatusResponse,
)
def reorder_playlist(
    playlist_id: str,
    payload: PlaylistReorderPayload,
    client: SpotifyClient = Depends(get_spotify_client),
) -> StatusResponse:
    client.reorder_playlist_items(
        playlist_id,
        range_start=payload.range_start,
        insert_before=payload.insert_before,
    )
    return StatusResponse(status="playlist-reordered")


@router.get("/me/tracks", response_model=SavedTracksResponse)
def get_saved_tracks(
    limit: int = Query(20, ge=1, le=50),
    client: SpotifyClient = Depends(get_spotify_client),
) -> SavedTracksResponse:
    saved = client.get_saved_tracks(limit=limit)
    return SavedTracksResponse(items=saved.get("items", []), total=saved.get("total", len(saved.get("items", []))))


@router.put("/me/tracks", response_model=StatusResponse)
def save_tracks(
    payload: TrackIdsPayload,
    client: SpotifyClient = Depends(get_spotify_client),
) -> StatusResponse:
    if not payload.ids:
        raise HTTPException(status_code=400, detail="No track IDs provided")
    client.save_tracks(payload.ids)
    return StatusResponse(status="tracks-saved")


@router.delete("/me/tracks", response_model=StatusResponse)
def remove_saved_tracks(
    payload: TrackIdsPayload,
    client: SpotifyClient = Depends(get_spotify_client),
) -> StatusResponse:
    if not payload.ids:
        raise HTTPException(status_code=400, detail="No track IDs provided")
    client.remove_saved_tracks(payload.ids)
    return StatusResponse(status="tracks-removed")


@router.get("/me", response_model=UserProfileResponse)
def get_current_user(
    client: SpotifyClient = Depends(get_spotify_client),
) -> UserProfileResponse:
    profile = client.get_current_user()
    return UserProfileResponse(profile=profile)


@router.get("/me/top/tracks", response_model=SpotifySearchResponse)
def get_top_tracks(
    limit: int = Query(20, ge=1, le=50),
    client: SpotifyClient = Depends(get_spotify_client),
) -> SpotifySearchResponse:
    response = client.get_top_tracks(limit=limit)
    return SpotifySearchResponse(items=response.get("items", []))


@router.get("/me/top/artists", response_model=SpotifySearchResponse)
def get_top_artists(
    limit: int = Query(20, ge=1, le=50),
    client: SpotifyClient = Depends(get_spotify_client),
) -> SpotifySearchResponse:
    response = client.get_top_artists(limit=limit)
    return SpotifySearchResponse(items=response.get("items", []))


@router.get("/recommendations", response_model=RecommendationsResponse)
def get_recommendations(
    seed_tracks: Optional[str] = Query(None),
    seed_artists: Optional[str] = Query(None),
    seed_genres: Optional[str] = Query(None),
    limit: int = Query(20, ge=1, le=100),
    client: SpotifyClient = Depends(get_spotify_client),
) -> RecommendationsResponse:
    def _split(value: Optional[str]) -> Optional[List[str]]:
        if value is None:
            return None
        result = [item.strip() for item in value.split(",") if item.strip()]
        return result or None

    response = client.get_recommendations(
        seed_tracks=_split(seed_tracks),
        seed_artists=_split(seed_artists),
        seed_genres=_split(seed_genres),
        limit=limit,
    )
    return RecommendationsResponse(
        tracks=response.get("tracks", []),
        seeds=response.get("seeds", []),
    )

// FILE: app/schemas.py
"""Pydantic schemas for request and response bodies."""
from __future__ import annotations

from datetime import datetime
from typing import Any, Dict, List, Optional, Union

from pydantic import BaseModel, Field, ConfigDict


class StatusResponse(BaseModel):
    status: str
    artist_count: Optional[int] = None
    album_count: Optional[int] = None
    track_count: Optional[int] = None
    last_scan: Optional[datetime] = None


class SpotifySearchResponse(BaseModel):
    items: List[Dict[str, Any]]


class PlaylistEntry(BaseModel):
    id: str
    name: str
    track_count: int
    updated_at: datetime

    model_config = ConfigDict(from_attributes=True)


class PlaylistResponse(BaseModel):
    playlists: List[PlaylistEntry]


class TrackDetailResponse(BaseModel):
    track: Dict[str, Any]


class AudioFeaturesResponse(BaseModel):
    audio_features: Union[Dict[str, Any], List[Dict[str, Any]]]


class PlaylistItemsResponse(BaseModel):
    items: List[Dict[str, Any]]
    total: int


class SavedTracksResponse(BaseModel):
    items: List[Dict[str, Any]]
    total: int


class UserProfileResponse(BaseModel):
    profile: Dict[str, Any]


class RecommendationsResponse(BaseModel):
    tracks: List[Dict[str, Any]]
    seeds: List[Dict[str, Any]]


class SoulseekSearchRequest(BaseModel):
    query: str


class SoulseekDownloadRequest(BaseModel):
    username: str = Field(..., description="Soulseek username hosting the files")
    files: List[Dict[str, Any]] = Field(..., description="List of files to download")


class SoulseekSearchResponse(BaseModel):
    """Response payload for Soulseek search results."""

    results: List[Any]
    raw: Optional[Dict[str, Any]] = None


class SoulseekDownloadResponse(BaseModel):
    """Response payload when a Soulseek download is queued."""

    status: str
    detail: Optional[Dict[str, Any]] = None


class SoulseekDownloadEntry(BaseModel):
    id: int
    filename: str
    state: str
    progress: float
    created_at: datetime
    updated_at: datetime

    model_config = ConfigDict(from_attributes=True)


class SoulseekDownloadStatus(BaseModel):
    downloads: List[SoulseekDownloadEntry]


class SoulseekCancelResponse(BaseModel):
    cancelled: bool


class MatchingRequest(BaseModel):
    spotify_track: Dict[str, Any]
    candidates: List[Dict[str, Any]]


class MatchingResponse(BaseModel):
    best_match: Optional[Dict[str, Any]]
    confidence: float


class AlbumMatchingRequest(BaseModel):
    spotify_album: Dict[str, Any]
    candidates: List[Dict[str, Any]]


class SettingsPayload(BaseModel):
    key: str
    value: Optional[str]


class SettingsResponse(BaseModel):
    settings: Dict[str, Optional[str]]
    updated_at: datetime


class SettingsHistoryEntry(BaseModel):
    key: str
    old_value: Optional[str]
    new_value: Optional[str]
    changed_at: datetime

    model_config = ConfigDict(from_attributes=True)


class SettingsHistoryResponse(BaseModel):
    history: List[SettingsHistoryEntry]

// FILE: app/utils/__init__.py
"""Utility helpers for Harmony."""

from .logging_config import configure_logging, get_logger  # noqa: F401

__all__ = ["configure_logging", "get_logger"]

// FILE: app/utils/logging_config.py
"""Compatibility wrapper exposing logging helpers for legacy imports."""

from __future__ import annotations

from app.logging import configure_logging, get_logger

__all__ = ["configure_logging", "get_logger"]

// FILE: app/workers/__init__.py
"""Background worker exports."""
from .matching_worker import MatchingWorker
from .playlist_sync_worker import PlaylistSyncWorker
from .scan_worker import ScanWorker
from .sync_worker import SyncWorker

__all__ = ["MatchingWorker", "PlaylistSyncWorker", "ScanWorker", "SyncWorker"]

// FILE: app/workers/matching_worker.py
"""Background worker handling deferred matching operations."""
from __future__ import annotations

import asyncio
from typing import Any, Dict

from app.core.matching_engine import MusicMatchingEngine
from app.db import session_scope
from app.logging import get_logger
from app.models import Match

logger = get_logger(__name__)


class MatchingWorker:
    def __init__(self, engine: MusicMatchingEngine) -> None:
        self._engine = engine
        self._queue: asyncio.Queue[Dict[str, Any]] = asyncio.Queue()
        self._task: asyncio.Task | None = None
        self._running = asyncio.Event()

    async def start(self) -> None:
        if self._task is None or self._task.done():
            self._running.set()
            self._task = asyncio.create_task(self._run())

    async def stop(self) -> None:
        self._running.clear()
        if self._task:
            await self._queue.put({"_shutdown": True})
            await self._task

    @property
    def queue(self) -> asyncio.Queue[Dict[str, Any]]:
        return self._queue

    async def _run(self) -> None:
        logger.info("MatchingWorker started")
        while self._running.is_set():
            job = await self._queue.get()
            try:
                if job.get("_shutdown"):
                    break
                await self._process_job(job)
            except Exception as exc:  # pragma: no cover
                logger.error("Failed to process matching job: %s", exc)
            finally:
                self._queue.task_done()
        logger.info("MatchingWorker stopped")

    async def _process_job(self, job: Dict[str, Any]) -> None:
        job_type = job.get("type")
        spotify_track = job.get("spotify_track")
        candidates = job.get("candidates", [])
        if not spotify_track or not candidates:
            logger.warning("Invalid matching job received: %s", job)
            return
        if job_type == "spotify-to-plex":
            best_match, confidence = self._engine.find_best_match(spotify_track, candidates)
        else:
            best_match = None
            confidence = 0.0
            for candidate in candidates:
                score = self._engine.calculate_slskd_match_confidence(spotify_track, candidate)
                if score > confidence:
                    confidence = score
                    best_match = candidate
        self._store_match(job_type, spotify_track, best_match, confidence)

    def _store_match(
        self,
        job_type: str,
        spotify_track: Dict[str, Any],
        best_match: Dict[str, Any] | None,
        confidence: float,
    ) -> None:
        with session_scope() as session:
            match = Match(
                source=job_type,
                spotify_track_id=str(spotify_track.get("id")),
                target_id=str(best_match.get("id")) if best_match and best_match.get("id") else None,
                confidence=confidence,
            )
            session.add(match)

// FILE: app/workers/playlist_sync_worker.py
"""Background worker that synchronises Spotify playlists into the database."""
from __future__ import annotations

import asyncio
from datetime import datetime
from typing import Any, Iterable

from app.core.spotify_client import SpotifyClient
from app.db import session_scope
from app.logging import get_logger
from app.models import Playlist

logger = get_logger(__name__)


class PlaylistSyncWorker:
    """Periodically fetches playlists for the authenticated user."""

    def __init__(self, spotify_client: SpotifyClient, interval_seconds: float = 900.0) -> None:
        self._client = spotify_client
        self._interval = interval_seconds
        self._task: asyncio.Task[None] | None = None
        self._running = False

    async def start(self) -> None:
        if self._task is None or self._task.done():
            self._running = True
            self._task = asyncio.create_task(self._run())

    async def stop(self) -> None:
        self._running = False
        if self._task is not None:
            self._task.cancel()
            try:
                await self._task
            except asyncio.CancelledError:  # pragma: no cover - cancellation lifecycle
                pass
            self._task = None

    async def _run(self) -> None:
        logger.info("PlaylistSyncWorker started")
        try:
            while self._running:
                await self.sync_once()
                await asyncio.sleep(self._interval)
        except asyncio.CancelledError:  # pragma: no cover - cancellation lifecycle
            logger.debug("PlaylistSyncWorker cancelled")
            raise
        finally:
            self._running = False
            logger.info("PlaylistSyncWorker stopped")

    async def sync_once(self) -> None:
        """Fetch playlists from Spotify and persist them."""

        try:
            response = self._client.get_user_playlists()
        except Exception as exc:  # pragma: no cover - defensive logging
            logger.error("Failed to fetch playlists from Spotify: %s", exc)
            return

        items: list[dict[str, Any]] = []
        if isinstance(response, dict):
            raw_items = response.get("items")
            if isinstance(raw_items, Iterable):
                items = [item for item in raw_items if isinstance(item, dict)]
        elif isinstance(response, list):
            items = [item for item in response if isinstance(item, dict)]

        if not items:
            logger.debug("No playlists received from Spotify")
            return

        now = datetime.utcnow()
        processed = 0

        with session_scope() as session:
            for payload in items:
                playlist_id = payload.get("id")
                name = payload.get("name")
                if not playlist_id or not name:
                    continue

                track_count = self._extract_track_count(payload)
                playlist = session.get(Playlist, str(playlist_id))

                if playlist is None:
                    playlist = Playlist(
                        id=str(playlist_id),
                        name=str(name),
                        track_count=track_count,
                    )
                    playlist.updated_at = now
                    session.add(playlist)
                else:
                    playlist.name = str(name)
                    playlist.track_count = track_count
                    playlist.updated_at = now

                processed += 1

        logger.info("Synced %s playlists from Spotify", processed)

    @staticmethod
    def _extract_track_count(payload: dict[str, Any]) -> int:
        """Safely derive the track count from a playlist payload."""

        track_count: int = 0
        tracks = payload.get("tracks")
        if isinstance(tracks, dict):
            total = tracks.get("total")
            try:
                track_count = int(total)
            except (TypeError, ValueError):
                track_count = 0
        elif isinstance(tracks, Iterable) and not isinstance(tracks, (str, bytes)):
            track_count = sum(1 for _ in tracks)
        else:
            try:
                track_count = int(payload.get("track_count", 0))
            except (TypeError, ValueError):
                track_count = 0

        return max(track_count, 0)

// FILE: app/workers/scan_worker.py
"""Worker that periodically scans the Plex library."""
from __future__ import annotations

import asyncio
from datetime import datetime

from sqlalchemy import select

from app.core.plex_client import PlexClient
from app.db import session_scope
from app.logging import get_logger
from app.models import Setting

logger = get_logger(__name__)


class ScanWorker:
    def __init__(self, plex_client: PlexClient, interval_seconds: int = 600) -> None:
        self._client = plex_client
        self._interval = interval_seconds
        self._task: asyncio.Task | None = None
        self._running = asyncio.Event()

    async def start(self) -> None:
        if self._task is None or self._task.done():
            self._running.set()
            self._task = asyncio.create_task(self._run())

    async def stop(self) -> None:
        self._running.clear()
        if self._task:
            self._task.cancel()
            try:
                await self._task
            except asyncio.CancelledError:  # pragma: no cover
                pass

    async def _run(self) -> None:
        logger.info("ScanWorker started")
        while self._running.is_set():
            await self._perform_scan()
            await asyncio.sleep(self._interval)
        logger.info("ScanWorker stopped")

    async def _perform_scan(self) -> None:
        try:
            stats = await self._client.get_library_statistics()
        except Exception as exc:  # pragma: no cover
            logger.error("Failed to scan Plex library: %s", exc)
            return

        artist_count = stats.get("artists", 0)
        album_count = stats.get("albums", 0)
        track_count = stats.get("tracks", 0)

        now = datetime.utcnow()
        with session_scope() as session:
            self._upsert_setting(session, "plex_artist_count", str(artist_count), now)
            self._upsert_setting(session, "plex_album_count", str(album_count), now)
            self._upsert_setting(session, "plex_track_count", str(track_count), now)
            self._upsert_setting(
                session, "plex_last_scan", now.isoformat(timespec="seconds"), now
            )
        logger.info(
            "Plex scan complete: %d artists, %d albums, %d tracks",
            artist_count,
            album_count,
            track_count,
        )

    @staticmethod
    def _upsert_setting(session, key: str, value: str, timestamp: datetime) -> None:
        setting = session.execute(
            select(Setting).where(Setting.key == key)
        ).scalar_one_or_none()
        if setting is None:
            session.add(
                Setting(
                    key=key,
                    value=value,
                    created_at=timestamp,
                    updated_at=timestamp,
                )
            )
        else:
            setting.value = value
            setting.updated_at = timestamp

// FILE: app/workers/sync_worker.py
"""Background worker for processing Soulseek download jobs."""
from __future__ import annotations

import asyncio
from datetime import datetime
from typing import Any, Dict, Iterable

from app.core.soulseek_client import SoulseekClient
from app.db import session_scope
from app.logging import get_logger
from app.models import Download

logger = get_logger(__name__)

ALLOWED_STATES = {"queued", "downloading", "completed", "failed"}


class SyncWorker:
    def __init__(self, soulseek_client: SoulseekClient) -> None:
        self._client = soulseek_client
        self._queue: asyncio.Queue[Dict[str, Any]] = asyncio.Queue()
        self._task: asyncio.Task | None = None
        self._running = asyncio.Event()
        self._poll_interval = 2.0

    @property
    def queue(self) -> asyncio.Queue[Dict[str, Any]]:
        return self._queue

    def is_running(self) -> bool:
        return self._running.is_set() and self._task is not None and not self._task.done()

    async def start(self) -> None:
        if self._task is None or self._task.done():
            self._running.set()
            self._task = asyncio.create_task(self._run())

    async def stop(self) -> None:
        self._running.clear()
        if self._task:
            await self._queue.put({"_shutdown": True})
            await self._task

    async def enqueue(self, job: Dict[str, Any]) -> None:
        """Submit a download job for processing."""

        if self.is_running():
            await self._queue.put(job)
            return
        await self._process_job(job)
        await self.refresh_downloads()

    async def _run(self) -> None:
        logger.info("SyncWorker started")
        try:
            while self._running.is_set():
                job: Dict[str, Any] | None = None
                try:
                    job = await asyncio.wait_for(self._queue.get(), timeout=self._poll_interval)
                except asyncio.TimeoutError:
                    await self.refresh_downloads()
                    continue

                try:
                    if job.get("_shutdown"):
                        break
                    await self._process_job(job)
                    await self.refresh_downloads()
                except Exception as exc:  # pragma: no cover - defensive
                    logger.error("Failed to process sync job: %s", exc)
                finally:
                    self._queue.task_done()
        finally:
            self._running.clear()
            logger.info("SyncWorker stopped")

    async def _process_job(self, job: Dict[str, Any]) -> None:
        username = job.get("username")
        files = job.get("files", [])
        if not username or not files:
            logger.warning("Invalid download job received: %s", job)
            return

        try:
            await self._client.download({"username": username, "files": files})
        except Exception as exc:  # pragma: no cover - defensive
            logger.error("Failed to queue Soulseek download: %s", exc)
            self._mark_failed(files)
            raise

    async def refresh_downloads(self) -> None:
        """Poll Soulseek for download progress and persist it."""

        try:
            response = await self._client.get_download_status()
        except Exception as exc:  # pragma: no cover - defensive
            logger.warning("Unable to obtain Soulseek download status: %s", exc)
            return

        downloads: Iterable[Dict[str, Any]]
        if isinstance(response, dict):
            downloads = response.get("downloads", []) or []
        elif isinstance(response, list):
            downloads = response
        else:  # pragma: no cover - defensive
            downloads = []

        if not downloads:
            return

        with session_scope() as session:
            for payload in downloads:
                download_id = payload.get("download_id") or payload.get("id")
                if download_id is None:
                    continue

                download = session.get(Download, int(download_id))
                if download is None:
                    continue

                state = str(payload.get("state", download.state))
                if state not in ALLOWED_STATES:
                    state = download.state

                progress_value = payload.get("progress", download.progress)
                try:
                    progress = float(progress_value)
                except (TypeError, ValueError):
                    progress = download.progress

                if progress < 0:
                    progress = 0.0
                elif progress > 100:
                    progress = 100.0

                if state == "queued" and 0 < progress < 100:
                    state = "downloading"
                elif state == "completed":
                    progress = 100.0

                download.state = state
                download.progress = progress
                download.updated_at = datetime.utcnow()

    def _mark_failed(self, files: Iterable[Dict[str, Any]]) -> None:
        download_ids = []
        for file_info in files:
            identifier = file_info.get("download_id") or file_info.get("id")
            if identifier is not None:
                download_ids.append(int(identifier))

        if not download_ids:
            return

        with session_scope() as session:
            for download_id in download_ids:
                download = session.get(Download, download_id)
                if download is None:
                    continue
                download.state = "failed"
                download.updated_at = datetime.utcnow()

// FILE: docker-compose.override.yml
version: "3.9"

services:
  backend:
    command: ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000", "--reload"]
    environment:
      - DATABASE_URL=sqlite:///./harmony.db
      - HARMONY_LOG_LEVEL=DEBUG

// FILE: docker-compose.yml
version: "3.9"

services:
  backend:
    build: .
    container_name: harmony-backend
    environment:
      - DATABASE_URL=sqlite:///./harmony.db
      - HARMONY_LOG_LEVEL=INFO
    ports:
      - "8000:8000"
    volumes:
      - ./:/app

// FILE: docs/api.md
# API-Referenz

Die folgenden Tabellen geben einen Überblick über die wichtigsten REST-Endpunkte des Harmony-Backends. Beispiel-Requests orientieren
sich an den in `app/routers` definierten Routen. Alle Antworten sind JSON-codiert.

## Spotify (`/spotify`)

| Methode | Pfad | Beschreibung |
| --- | --- | --- |
| `GET` | `/spotify/status` | Prüft, ob der Spotify-Client authentifiziert ist. |
| `GET` | `/spotify/search/tracks?query=...` | Sucht nach Tracks (weitere Endpunkte für Artists/Albums identisch). |
| `GET` | `/spotify/track/{track_id}` | Liefert Track-Details. |
| `GET` | `/spotify/audio-features/{track_id}` | Einzelne Audio-Features. |
| `GET` | `/spotify/audio-features?ids=ID1,ID2` | Mehrere Audio-Features in einem Request. |
| `GET` | `/spotify/playlists` | Listet persistierte Playlists aus der Datenbank. |
| `GET` | `/spotify/playlists/{playlist_id}/tracks` | Holt Playlist-Items (optional `limit`). |
| `POST` | `/spotify/playlists/{playlist_id}/tracks` | Fügt Tracks per URIs hinzu. |
| `DELETE` | `/spotify/playlists/{playlist_id}/tracks` | Entfernt Tracks anhand von URIs. |
| `PUT` | `/spotify/playlists/{playlist_id}/reorder` | Sortiert Playlist neu. |
| `GET` | `/spotify/me` | Gibt das Spotify-Benutzerprofil zurück. |
| `GET` | `/spotify/me/tracks` | Listet gespeicherte Tracks (`limit`). |
| `PUT`/`DELETE` | `/spotify/me/tracks` | Speichert bzw. entfernt gespeicherte Tracks (Payload: `{"ids": [...]}`). |
| `GET` | `/spotify/me/top/{type}` | Top-Tracks oder Artists. |
| `GET` | `/spotify/recommendations` | Empfehlungen anhand Seed-Parametern. |

**Beispiel:**

```http
GET /spotify/search/tracks?query=daft%20punk HTTP/1.1
Authorization: Bearer <token>
```

```json
{
  "items": [
    {
      "id": "2cGxRwrMyEAp8dEbuZaVv6",
      "name": "Harder, Better, Faster, Stronger",
      "artists": [{"name": "Daft Punk"}],
      "album": {"name": "Discovery"}
    }
  ]
}
```

## Plex (`/plex`)

| Methode | Pfad | Beschreibung |
| --- | --- | --- |
| `GET` | `/plex/status` | Liefert Sitzungen und Bibliotheksstatistiken. |
| `GET` | `/plex/library/sections` | Listet Bibliotheken (Alias: `/plex/libraries`). |
| `GET` | `/plex/library/sections/{section_id}/all` | Durchsucht eine Bibliothek (Alias: `/plex/library/{section_id}/items`). |
| `GET` | `/plex/library/metadata/{item_id}` | Metadaten für ein Item. |
| `GET` | `/plex/status/sessions` | Aktive Sessions (Alias: `/plex/sessions`). |
| `GET` | `/plex/status/sessions/history/all` | Wiedergabeverlauf (Alias: `/plex/history`). |
| `GET`/`POST` | `/plex/timeline` | Holt bzw. aktualisiert Timeline-Daten. |
| `POST` | `/plex/scrobble` / `/plex/unscrobble` | Spielposition melden. |
| `GET`/`POST`/`PUT`/`DELETE` | `/plex/playlists` | Playlist-Verwaltung. |
| `POST` | `/plex/playQueues` | Erstellt PlayQueues. |
| `GET` | `/plex/playQueues/{playqueue_id}` | Lädt eine bestehende PlayQueue. |
| `POST` | `/plex/rate` | Bewertet ein Item. |
| `POST` | `/plex/tags/{item_id}` | Synchronisiert Tags. |
| `GET` | `/plex/devices` | Verfügbare Geräte. |
| `GET` | `/plex/dvr` | DVR-Daten. |
| `GET` | `/plex/livetv` | Live-TV-Informationen. |
| `GET` | `/plex/notifications` | Server-Sent Events Stream für Plex-Benachrichtigungen. |

**Beispiel:**

```http
GET /plex/library/sections/1/all?type=10 HTTP/1.1
X-Plex-Token: <token>
```

```json
{
  "MediaContainer": {
    "Metadata": [
      {"ratingKey": "123", "title": "Discovery", "parentTitle": "Daft Punk"}
    ]
  }
}
```

## Soulseek (`/soulseek`)

| Methode | Pfad | Beschreibung |
| --- | --- | --- |
| `GET` | `/soulseek/status` | Prüft die Verbindung zum slskd-Daemon. |
| `POST` | `/soulseek/search` | Führt eine Suche aus (`{"query": "artist"}`). |
| `POST` | `/soulseek/download` | Persistiert Downloads und stößt Worker an. |
| `GET` | `/soulseek/downloads` | Liefert gespeicherte Downloads aus der DB. |
| `GET` | `/soulseek/download/{id}` | Holt Detailinformationen direkt vom Client. |
| `DELETE` | `/soulseek/download/{id}` | Bricht einen Download ab. |
| `GET` | `/soulseek/downloads/all` | Delegiert an `SoulseekClient.get_all_downloads()`. |
| `DELETE` | `/soulseek/downloads/completed` | Entfernt erledigte Downloads. |
| `GET` | `/soulseek/download/{id}/queue` | Fragt Queue-Positionen ab. |
| `POST` | `/soulseek/enqueue` | Fügt mehrere Dateien der Warteschlange hinzu. |
| `GET` | `/soulseek/uploads` | Lädt Uploads. |
| `GET` | `/soulseek/uploads/all` | Alle Uploads. |
| `DELETE` | `/soulseek/upload/{id}` | Bricht einen Upload ab. |
| `DELETE` | `/soulseek/uploads/completed` | Entfernt erledigte Uploads. |
| `GET` | `/soulseek/user/{username}/address` | IP/Port eines Benutzers. |
| `GET` | `/soulseek/user/{username}/browse` | Lädt die Verzeichnisstruktur. |
| `GET` | `/soulseek/user/{username}/directory?path=...` | Abfrage eines Unterordners. |
| `GET` | `/soulseek/user/{username}/info` | Benutzerinformationen. |
| `GET` | `/soulseek/user/{username}/status` | Online-Status. |

**Beispiel:**

```http
POST /soulseek/download HTTP/1.1
Content-Type: application/json

{
  "username": "dj_user",
  "files": [
    {"filename": "Daft Punk - Harder.mp3", "size": 5120000}
  ]
}
```

```json
{
  "status": "queued",
  "detail": {
    "downloads": [
      {"id": 1, "filename": "Daft Punk - Harder.mp3", "state": "queued", "progress": 0.0}
    ]
  }
}
```

## Matching (`/matching`)

| Methode | Pfad | Beschreibung |
| --- | --- | --- |
| `POST` | `/matching/spotify-to-plex` | Matcht einen Spotify-Track gegen Plex-Kandidaten und speichert das Ergebnis. |
| `POST` | `/matching/spotify-to-soulseek` | Bewertet Spotify vs. Soulseek-Kandidaten. |
| `POST` | `/matching/spotify-to-plex-album` | Liefert das beste Album-Match. |

**Beispiel:**

```http
POST /matching/spotify-to-plex HTTP/1.1
Content-Type: application/json

{
  "spotify_track": {"id": "2cGxRwrMyEAp8dEbuZaVv6", "name": "Harder, Better, Faster, Stronger"},
  "candidates": [
    {"id": "123", "title": "Harder Better Faster Stronger", "album": "Discovery"}
  ]
}
```

```json
{
  "best_match": {"id": "123", "title": "Harder Better Faster Stronger", "album": "Discovery"},
  "confidence": 0.98
}
```

## Settings (`/settings`)

| Methode | Pfad | Beschreibung |
| --- | --- | --- |
| `GET` | `/settings` | Liefert alle Settings als Key-Value-Map inklusive `updated_at`. |
| `POST` | `/settings` | Legt/aktualisiert einen Eintrag (`{"key": "plex_artist_count", "value": "123"}`). |
| `GET` | `/settings/history` | Zeigt die letzten 50 Änderungen mit Zeitstempel. |

## Beets (`/beets`)

| Methode | Pfad | Beschreibung |
| --- | --- | --- |
| `POST` | `/beets/import` | Führt `beet import` aus (Payload: `{"path": "/music"}`). |
| `POST` | `/beets/update` | Aktualisiert Metadaten (`beet update`). |
| `POST` | `/beets/remove` | Entfernt Items nach Query (`{"query": "artist:Daft Punk"}`). |
| `POST` | `/beets/move` | Verschiebt Dateien (optional Query). |
| `POST` | `/beets/write` | Schreibt Tags auf Basis einer Query. |
| `GET` | `/beets/albums` | Listet Albumtitel. |
| `GET` | `/beets/tracks` | Listet Tracks. |
| `GET` | `/beets/stats` | Gibt Statistiken (`beet stats`). |
| `GET` | `/beets/fields` | Zeigt verfügbare Feldnamen. |
| `POST` | `/beets/query` | Führt eine Query mit Format-String aus. |

**Beispiel:**

```http
POST /beets/query HTTP/1.1
Content-Type: application/json

{
  "query": "artist:Daft Punk",
  "format": "$artist - $album - $title"
}
```

```json
{
  "results": [
    "Daft Punk - Discovery - Harder, Better, Faster, Stronger"
  ]
}
```

// FILE: docs/architecture.md
# Architekturübersicht

Die Harmony-Anwendung folgt einer modularen FastAPI-Architektur, die interne und externe Komponenten klar voneinander trennt.
Das folgende textuelle Diagramm beschreibt den Aufbau:

```
+----------------------------+
|          Clients           |
| SpotifyClient, PlexClient, |
| SoulseekClient, BeetsClient|
+-------------+--------------+
              |
              v
+-------------+--------------+
|            Core            |
| MatchingEngine, Utilities  |
+-------------+--------------+
              |
              v
+-------------+--------------+
|           Routers          |
| Spotify / Plex / Soulseek  |
| Matching / Settings / Beets|
+------+------+-------------+
       |      |
       |      v
       |   Background Workers
       |   (Sync, Matching,   
       |    Scan, Playlist)   
       v                      
+------+------+-------------+
|        Datenbank           |
| SQLAlchemy Modelle         |
+----------------------------+
```

## Komponenten im Detail

### Core

- **SpotifyClient** (`app/core/spotify_client.py`): Kapselt die Spotify Web API (Suche, Audio Features, Playlists, Empfehlungen).
- **PlexClient** (`app/core/plex_client.py`): Async-Client für Bibliotheken, Sessions, Timeline und Live-TV.
- **SoulseekClient** (`app/core/soulseek_client.py`): Bindet den slskd-Daemon an und stellt Download-/Upload-Operationen bereit.
- **BeetsClient** (`app/core/beets_client.py`): Führt Beets CLI-Kommandos innerhalb eines Threadpools aus.
- **MusicMatchingEngine** (`app/core/matching_engine.py`): Berechnet Ähnlichkeitsscores und liefert Best-Match-Kandidaten.

### Routers

FastAPI-Router bilden die öffentliche REST-API. Jeder Router importiert die benötigten Clients als Dependencies (`app/dependencies.py`).
Beispiele:

- `app/routers/spotify_router.py` für `/spotify`-Endpunkte (Suche, Audio Features, Playlists, Benutzerprofil).
- `app/routers/plex_router.py` für `/plex`-Endpunkte (Bibliotheken, PlayQueues, Benachrichtigungen).
- `app/routers/soulseek_router.py` für `/soulseek`-Endpunkte (Downloads, Uploads, Benutzerinformationen).
- `app/routers/matching_router.py` für `/matching` (Spotify→Plex/Soulseek, Album-Matching).
- `app/routers/settings_router.py` für `/settings` (Key-Value Settings + Historie).
- `app/routers/beets_router.py` für `/beets` (Import, Query, Stats, Dateimanipulation).

### Datenbank

- `app/db.py` initialisiert SQLite und stellt `session_scope()` sowie `get_session()` bereit.
- `app/models.py` definiert SQLAlchemy-Modelle wie `Playlist`, `Download`, `Match`, `Setting`, `SettingHistory`.
- `app/schemas.py` enthält die Pydantic-Modelle für Anfragen und Antworten.

### Hintergrund-Worker

Während des Startup-Events (`app/main.py`) werden – sofern `HARMONY_DISABLE_WORKERS` nicht gesetzt ist – folgende Worker gestartet:

- **SyncWorker** (`app/workers/sync_worker.py`): Verarbeitet Soulseek-Downloadjobs und aktualisiert Fortschritte.
- **MatchingWorker** (`app/workers/matching_worker.py`): Persistiert berechnete Matches asynchron.
- **ScanWorker** (`app/workers/scan_worker.py`): Pollt Plex in Intervallen und aktualisiert Statistik-Settings.
- **PlaylistSyncWorker** (`app/workers/playlist_sync_worker.py`): Synchronisiert Spotify-Playlists in die Datenbank.

Alle Worker greifen über `session_scope()` auf die Datenbank zu und protokollieren Abläufe über `app/logging.py`.

## Synchronisations- & Matching-Prozesse

1. **Soulseek-Downloads**: REST-Aufrufe gegen `/soulseek/download` persistieren Downloads in der Datenbank und übergeben Jobs an den
   `SyncWorker`. Dieser startet Downloads über den `SoulseekClient` und pollt `get_download_status()`, um Fortschritt, Status und
   Zeitstempel (`Download.updated_at`) zu aktualisieren.
2. **Spotify-Playlist-Sync**: Der `PlaylistSyncWorker` ruft periodisch `SpotifyClient.get_user_playlists()` auf, normalisiert die
   Daten und speichert sie in der `Playlist`-Tabelle. Änderungen werden über `updated_at` erfasst.
3. **Plex-Scans**: Der `ScanWorker` pollt `PlexClient.get_library_statistics()` und schreibt aggregierte Werte in `Setting`-Einträge.
4. **Matching**: Der Matching-Router kann Ergebnisse direkt persistieren. Zusätzlich verarbeitet der `MatchingWorker` Jobs aus seiner
   Queue und speichert `Match`-Objekte. Die Matching-Engine vergleicht Spotify-Tracks mit Plex- oder Soulseek-Kandidaten und liefert
   Konfidenzwerte zurück.

## Interaktion der Komponenten

- Router lösen Aktionen aus und rufen über Dependencies die passenden Core-Clients auf.
- Core-Clients kommunizieren mit externen Diensten und liefern strukturierte Antworten.
- Worker laufen asynchron und nutzen dieselben Clients, um Automatisierungen im Hintergrund auszuführen.
- Alle Schreiboperationen gehen über SQLAlchemy-Sessions, sodass API-Aufrufe und Worker auf denselben Datenbestand zugreifen.

// FILE: docs/images/app-header-storybook.svg
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1200 320" role="img" aria-labelledby="title desc">
  <title id="title">Harmony AppHeader Storybook Snapshot</title>
  <desc id="desc">Schematische Darstellung des Harmony AppHeaders mit Logo, Suche, Filtern und Aktionen.</desc>
  <defs>
    <linearGradient id="bg" x1="0" y1="0" x2="0" y2="1">
      <stop offset="0%" stop-color="#0f172a"/>
      <stop offset="100%" stop-color="#1e293b"/>
    </linearGradient>
    <linearGradient id="card" x1="0" y1="0" x2="1" y2="1">
      <stop offset="0%" stop-color="#ffffff" stop-opacity="0.9"/>
      <stop offset="100%" stop-color="#e0e7ff" stop-opacity="0.95"/>
    </linearGradient>
  </defs>
  <rect width="1200" height="320" fill="url(#bg)" rx="24"/>
  <rect x="48" y="48" width="1104" height="224" rx="20" fill="url(#card)" opacity="0.92"/>
  <circle cx="120" cy="160" r="44" fill="#4338ca" opacity="0.2"/>
  <path d="M94 140c0-12 10-22 22-22h12c12 0 22 10 22 22v90c0 18 14 32 32 32h20c18 0 32-14 32-32s-14-32-32-32h-16" stroke="#4338ca" stroke-width="9" stroke-linecap="round" fill="none"/>
  <circle cx="122" cy="214" r="12" fill="#4338ca"/>
  <circle cx="178" cy="214" r="12" fill="#4338ca"/>
  <text x="210" y="172" fill="#1e293b" font-family="'Inter', sans-serif" font-size="40" font-weight="700">Harmony</text>
  <rect x="360" y="128" width="280" height="48" rx="12" fill="#e2e8f0" />
  <text x="380" y="159" fill="#475569" font-family="'Inter', sans-serif" font-size="20">Search tracks, artists...</text>
  <g font-family="'Inter', sans-serif" font-size="18" font-weight="600" fill="#334155">
    <rect x="660" y="132" width="96" height="40" rx="12" fill="#bbf7d0" />
    <text x="688" y="157">Spotify</text>
    <rect x="768" y="132" width="80" height="40" rx="12" fill="#fed7aa" />
    <text x="786" y="157">Plex</text>
    <rect x="856" y="132" width="104" height="40" rx="12" fill="#bfdbfe" />
    <text x="882" y="157">Soulseek</text>
  </g>
  <g stroke="#4338ca" stroke-width="4" stroke-linecap="round" fill="none" opacity="0.7">
    <circle cx="992" cy="152" r="20"/>
    <circle cx="1048" cy="152" r="20"/>
    <circle cx="1104" cy="152" r="20"/>
  </g>
</svg>

// FILE: docs/workers.md
# Hintergrund-Worker

Harmony startet beim FastAPI-Startup mehrere Hintergrundprozesse, um langlaufende Aufgaben außerhalb des Request-Kontexts zu
bearbeiten. Die Worker verwenden asynchrone Tasks (`asyncio`) und greifen über `session_scope()` auf die Datenbank zu.

## SyncWorker

- **Pfad:** `app/workers/sync_worker.py`
- **Aufgabe:** Verarbeitet Soulseek-Downloadjobs, startet Downloads über den `SoulseekClient` und aktualisiert den Fortschritt.
- **Arbeitsweise:**
  - Eingehende Jobs (Username + Datei-Metadaten) landen in einer `asyncio.Queue`.
  - Läuft der Worker, werden Jobs sequentiell aus der Queue geholt; andernfalls wird der Download sofort synchron abgewickelt.
  - Nach jedem Job wird `refresh_downloads()` aufgerufen, das `client.get_download_status()` pollt und DB-Einträge (`Download`)
    aktualisiert (Status, Fortschritt, `updated_at`).
- **Polling-Intervall:** 2 Sekunden Timeout beim Queue-Waiting; fällt kein Job an, wird in diesem Intervall der Status nachgezogen.
- **Fehlerhandling:**
  - Fehler beim Download markieren die betroffenen Einträge als `failed`.
  - Nicht erkannte Statuswerte werden verworfen, Fortschrittswerte werden auf `0…100` begrenzt.
  - Netzwerkfehler beim Status-Polling führen zu einem Warn-Log, ohne den Worker zu stoppen.

## MatchingWorker

- **Pfad:** `app/workers/matching_worker.py`
- **Aufgabe:** Nimmt Matching-Jobs (`spotify_track` + Kandidatenliste) entgegen und persistiert die besten Treffer.
- **Arbeitsweise:**
  - Verwendet eine `asyncio.Queue` und ein Flag, um Shutdowns kontrolliert zu verarbeiten.
  - Für `spotify-to-plex` ruft der Worker `MusicMatchingEngine.find_best_match()` auf.
  - Für alle anderen Jobs (z. B. `spotify-to-soulseek`) wird `calculate_slskd_match_confidence()` pro Kandidat berechnet und das
    höchste Scoring übernommen.
  - Die Ergebnisse werden als `Match`-Objekte gespeichert (`source`, `spotify_track_id`, `target_id`, `confidence`).
- **Fehlerhandling:**
  - Exceptions beim Abarbeiten werden geloggt; das Queue-Item wird dennoch als abgeschlossen markiert.
  - Ungültige Jobs (fehlende Kandidaten/Tracks) werden verworfen und mit Warnung protokolliert.

## ScanWorker

- **Pfad:** `app/workers/scan_worker.py`
- **Aufgabe:** Pollt regelmäßig Plex-Statistiken und hält aggregierte Werte in den Settings aktuell.
- **Arbeitsweise:**
  - Standardintervall: 600 Sekunden (`interval_seconds`-Parameter).
  - `get_library_statistics()` liefert Anzahl Artists/Albums/Tracks; zusätzlich wird ein Zeitstempel gesetzt.
  - Werte werden über `_upsert_setting` als `Setting`-Einträge geschrieben oder aktualisiert (`plex_artist_count`, `plex_album_count`,
    `plex_track_count`, `plex_last_scan`).
- **Fehlerhandling:**
  - Netzwerkfehler werden geloggt und führen zu keinem Update.
  - Der Worker toleriert `asyncio.CancelledError`, wenn er beim Shutdown gestoppt wird.

## Zusammenspiel der Worker

- Alle Worker werden in `app/main.py` initialisiert, sofern `HARMONY_DISABLE_WORKERS` nicht auf `1` gesetzt ist.
- Die Worker teilen sich keine gemeinsamen Datenstrukturen; Synchronisation erfolgt ausschließlich über die Datenbank.
- Beim Application-Shutdown stoppt FastAPI jeden Worker kontrolliert (`stop()`), um laufende Tasks zu beenden und Queues zu räumen.

// FILE: frontend/.eslintrc.cjs
module.exports = {
  root: true,
  env: {
    browser: true,
    es2021: true
  },
  extends: [
    "eslint:recommended",
    "plugin:react/recommended",
    "plugin:react-hooks/recommended",
    "plugin:react/jsx-runtime",
    "prettier"
  ],
  parser: "@typescript-eslint/parser",
  parserOptions: {
    ecmaVersion: "latest",
    sourceType: "module"
  },
  plugins: ["react", "@typescript-eslint"],
  settings: {
    react: {
      version: "detect"
    }
  },
  ignorePatterns: ["dist", "node_modules"],
  rules: {
    "react/prop-types": "off"
  }
};

// FILE: frontend/README.md
# Harmony Frontend

Die Harmony Web UI ist ein React/Vite-Projekt mit TailwindCSS, shadcn/ui und Radix UI. Die Oberfläche bindet Spotify, Plex und Soulseek an, stellt Matching-Funktionen bereit und erlaubt das Konfigurieren aller Zugangsdaten.

## Installation & Entwicklung

1. In das Frontend-Verzeichnis wechseln

   ```bash
   cd frontend
   ```

2. Abhängigkeiten installieren

   ```bash
   npm install
   ```

3. Entwicklungsserver starten

   ```bash
   npm run dev
   ```

   Der Server läuft auf [http://localhost:5173](http://localhost:5173). Über `VITE_API_BASE_URL` lässt sich bei Bedarf die Backend-URL anpassen (Standard: `http://localhost:8000`).

4. Storybook für UI-Dokumentation

   ```bash
   npm run storybook
   ```

5. Tests ausführen (React Testing Library + Jest)

   ```bash
   npm test
   ```

## Architekturüberblick

```
frontend/
├─ src/
│  ├─ App.tsx                # Router + AppShell
│  ├─ components/            # Layout, Header, Sidebar, UI-Elemente (shadcn/Radix)
│  ├─ hooks/                 # Theme-, Search-, Realtime-Hooks
│  ├─ pages/                 # Feature-Seiten (Dashboard, Spotify, Plex, Soulseek, Matching, Settings)
│  ├─ services/              # Axios-Client + API-Abstraktionen
│  ├─ stories/               # Storybook-Stories
│  └─ __tests__/             # Jest + RTL Tests
├─ index.html
├─ tailwind.config.ts
└─ vite.config.ts
```

Die UI nutzt ein globales `SearchProvider`, um die Header-Suche mit allen Seiten zu teilen. Service-Module kapseln REST- und SSE-Endpunkte (Axios + EventSource). Das Theme wird via `useTheme` Hook persistent in `localStorage` verwaltet.

## Hauptseiten & Funktionen

- **Dashboard** – Systeminformationen (Backend-Version, Datenbank- und Worker-Status, Uptime), Service-Statuskarten für Spotify/Plex/Soulseek/Beets sowie eine Jobs- und Download-Tabelle im Stil der Design-Referenz.
- **Spotify** – Tabs für *Status & Playlists* sowie *Einstellungen*. Globale Suche filtert Playlists und Track-Tabellen, Statuskarten zeigen Verbindungs- und Sync-Informationen.
- **Plex** – Tab-basierte Bibliotheksübersicht mit Artist-, Album- und Track-Tabellen sowie einer Settings-Ansicht für Base-URL, Token und Library.
- **Soulseek** – Download- und Such-Tabellen inklusive Fortschrittsbalken, Abbruch-Buttons und separater Einstellungs-Tab für SLSKD-URL/API-Key.
- **Beets** – Platzhalterseite für die kommende Beets-Integration (Navigation & Layout vorbereitet).
- **Matching** – Startet Spotify→Plex und Spotify→Soulseek Abgleiche, zeigt Ergebnisse tabellarisch und triggert Toast-Notifications.
- **Settings** – Globale Übersicht aller gespeicherten Zugangsdaten, eingebettet in das AppShell-Layout.

## Konfiguration

Die Seiten **Spotify**, **Plex** und **Soulseek** besitzen jeweils einen Einstellungen-Tab. Beim Öffnen werden die aktuellen Werte über `GET /settings` geladen, in den Formularfeldern angezeigt und lassen sich per `POST /settings` aktualisieren. Erfolgreiche Saves triggern einen ✅-Toast, Fehler blenden eine Warnung innerhalb des Formulars ein.

## UI-Komponenten

### AppHeader

- Zentraler Header mit Logo, globaler Suche, Filter-Toggles (Spotify/Plex/Soulseek), Refresh, Notifications, What's-New und Theme Toggle.
- Mobile Nutzer:innen öffnen die Navigation per Drawer-Trigger; Desktop zeigt die Sidebar permanent.
- Storybook-Szenarien: Default, Filter aktiv, Loading, Dark Mode, What's New.

![Harmony AppHeader Storybook](../docs/images/app-header-storybook.svg)

### Weitere Elemente

- **Layout & Sidebar** – Radix Drawer für Mobile, fixe Sidebar auf Desktop (inkl. zusätzlichem Beets-Menüpunkt entsprechend dem Referenzdesign).
- **Toasts** – Globale Benachrichtigungen über Radix Toasts (`useToast`).
- **Progress/Badges** – Tailwind-basierte Komponenten für Soulseek-Downloads und Spotify-Metadaten.

## Tests

- React Testing Library deckt AppHeader-Interaktionen, globale Theme-Umschaltung und den initialen Dashboard-Load ab.
- Services werden in Tests gemockt, um API-Aufrufe zu verifizieren.

Ausführung:

```bash
npm test
```

## Weitere Arbeiten

- Zusätzliche Tabellen- und Filterlogik für große Datenmengen optimieren.
- High-Contrast-Theme evaluieren.
- Backend-Endpoints für Notifications erweitern.

// FILE: frontend/index.html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Harmony</title>
  </head>
  <body class="bg-slate-950 text-slate-100">
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

// FILE: frontend/jest.config.ts
import type { Config } from "jest";

const config: Config = {
  preset: "ts-jest/presets/default-esm",
  testEnvironment: "jsdom",
  roots: ["<rootDir>/src"],
  moduleFileExtensions: ["ts", "tsx", "js", "jsx"],
  moduleNameMapper: {
    "\\.(css|less|sass|scss)$": "identity-obj-proxy"
  },
  extensionsToTreatAsEsm: [".ts", ".tsx"],
  globals: {
    "ts-jest": {
      useESM: true,
      tsconfig: "<rootDir>/tsconfig.jest.json"
    }
  },
  setupFilesAfterEnv: ["<rootDir>/jest.setup.ts"],
  collectCoverageFrom: ["src/**/*.{ts,tsx}", "!src/vite-env.d.ts"]
};

export default config;

// FILE: frontend/jest.setup.ts
import "@testing-library/jest-dom";

// FILE: frontend/package.json
{
  "name": "harmony-frontend",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "preview": "vite preview",
    "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "test": "jest"
  },
  "dependencies": {
    "@radix-ui/react-dialog": "^1.1.1",
    "@radix-ui/react-tabs": "^1.0.4",
    "@radix-ui/react-tooltip": "^1.0.7",
    "@radix-ui/react-slot": "^1.1.0",
    "@radix-ui/react-toast": "^1.1.5",
    "@radix-ui/react-switch": "^1.0.3",
    "@radix-ui/react-table": "^1.0.0",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.1.1",
    "lucide-react": "^0.473.0",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-router-dom": "^6.26.0",
    "tailwind-merge": "^2.3.0",
    "axios": "^1.7.7"
  },
  "devDependencies": {
    "@storybook/react": "^8.1.11",
    "@types/react": "^18.3.7",
    "@types/react-dom": "^18.3.2",
    "@vitejs/plugin-react": "^4.3.2",
    "@types/jest": "^29.5.12",
    "@typescript-eslint/eslint-plugin": "^8.3.0",
    "@typescript-eslint/parser": "^8.3.0",
    "@testing-library/jest-dom": "^6.5.0",
    "@testing-library/react": "^16.0.0",
    "@testing-library/user-event": "^14.6.1",
    "autoprefixer": "^10.4.19",
    "identity-obj-proxy": "^3.0.0",
    "jest": "^29.7.0",
    "jest-environment-jsdom": "^29.7.0",
    "eslint": "^9.9.0",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-react": "^7.35.0",
    "eslint-plugin-react-hooks": "^4.6.2",
    "postcss": "^8.4.39",
    "postcss-import": "^15.1.0",
    "tailwindcss": "^3.4.9",
    "tailwindcss-animate": "^1.0.7",
    "ts-jest": "^29.2.5",
    "typescript": "^5.5.4",
    "vite": "^5.4.1"
  }
}

// FILE: frontend/postcss.config.js
module.exports = {
  plugins: {
    "postcss-import": { path: ["src", "."] },
    tailwindcss: {},
    autoprefixer: {}
  }
};

// FILE: frontend/src/App.tsx
import { BrowserRouter, Navigate, Route, Routes, useNavigate } from "react-router-dom";
import { useEffect, useMemo, useRef, useState } from "react";

import Layout from "./components/Layout";
import DashboardPage from "./pages/DashboardPage";
import SpotifyPage from "./pages/SpotifyPage";
import PlexPage from "./pages/PlexPage";
import SoulseekPage from "./pages/SoulseekPage";
import BeetsPage from "./pages/BeetsPage";
import Matching from "./pages/Matching";
import Settings from "./pages/Settings";
import { Toaster } from "./components/ui/toaster";
import AppHeader, { ServiceFilters } from "./components/AppHeader";
import { useToast } from "./components/ui/use-toast";
import useTheme from "./hooks/useTheme";
import { SearchProvider } from "./hooks/useGlobalSearch";

const defaultFilters: ServiceFilters = {
  spotify: true,
  plex: true,
  soulseek: true
};

const AppRoutes = () => {
  const navigate = useNavigate();
  const { toast } = useToast();
  const [filters, setFilters] = useState<ServiceFilters>(defaultFilters);
  const [searchTerm, setSearchTerm] = useState("");
  const [isSidebarOpen, setIsSidebarOpen] = useState(false);
  const [hasNewFeatures, setHasNewFeatures] = useState(true);
  const { theme, toggleTheme } = useTheme();
  const [loading, setLoading] = useState(false);
  const refreshTimerRef = useRef<number | undefined>(undefined);

  useEffect(() => {
    return () => {
      if (refreshTimerRef.current !== undefined) {
        window.clearTimeout(refreshTimerRef.current);
      }
    };
  }, []);

  const header = useMemo(
    () => (
      <AppHeader
        loading={loading}
        onRefresh={() => {
          if (refreshTimerRef.current) {
            window.clearTimeout(refreshTimerRef.current);
          }
          setLoading(true);
          refreshTimerRef.current = window.setTimeout(() => {
            setLoading(false);
          }, 800);
        }}
        searchTerm={searchTerm}
        onSearchChange={setSearchTerm}
        filters={filters}
        onFilterChange={setFilters}
        isDarkMode={theme === "dark"}
        onThemeToggle={toggleTheme}
        onGoHome={() => navigate("/dashboard")}
        onToggleSidebar={() => setIsSidebarOpen((open) => !open)}
        onShowWhatsNew={() => {
          toast({
            title: "Harmony Update",
            description: "Die neuesten Änderungen wurden geladen."
          });
          setHasNewFeatures(false);
        }}
        onShowNotifications={() => {
          toast({
            title: "Benachrichtigungen",
            description: "Keine neuen Benachrichtigungen"
          });
        }}
        hasNewFeatures={hasNewFeatures}
      />
    ),
    [
      filters,
      hasNewFeatures,
      loading,
      navigate,
      searchTerm,
      setFilters,
      setHasNewFeatures,
      setIsSidebarOpen,
      setSearchTerm,
      theme,
      toggleTheme,
      toast
    ]
  );

  return (
    <>
      <Toaster />
      <SearchProvider value={{ term: searchTerm, setTerm: setSearchTerm }}>
        <Routes>
          <Route path="/" element={<Navigate to="/dashboard" replace />} />
          <Route
            element={
              <Layout
                header={header}
                isSidebarOpen={isSidebarOpen}
                onSidebarOpenChange={setIsSidebarOpen}
              />
            }
          >
            <Route path="/dashboard" element={<DashboardPage filters={filters} />} />
            <Route path="/spotify" element={<SpotifyPage filters={filters} />} />
            <Route path="/plex" element={<PlexPage filters={filters} />} />
            <Route path="/soulseek" element={<SoulseekPage filters={filters} />} />
            <Route path="/beets" element={<BeetsPage />} />
            <Route path="/matching" element={<Matching />} />
            <Route path="/settings" element={<Settings />} />
          </Route>
        </Routes>
      </SearchProvider>
    </>
  );
};

function App() {
  return (
    <BrowserRouter>
      <AppRoutes />
    </BrowserRouter>
  );
}

export default App;

// FILE: frontend/src/__tests__/App.test.tsx
import { render, screen, waitFor } from "@testing-library/react";
import App from "../App";
import spotifyService from "../services/spotify";
import plexService from "../services/plex";
import soulseekService from "../services/soulseek";
import dashboardService from "../services/dashboard";
import settingsService from "../services/settings";

jest.mock("../services/spotify", () => {
  const actual = jest.requireActual("../services/spotify");
  return {
    __esModule: true,
    ...actual,
    default: {
      ...actual.default,
      getStatus: jest.fn().mockResolvedValue({ connected: true, lastSync: "vor 1h" }),
      searchTracks: jest.fn().mockResolvedValue([]),
      getPlaylists: jest.fn().mockResolvedValue([])
    }
  };
});

jest.mock("../services/plex", () => {
  const actual = jest.requireActual("../services/plex");
  return {
    __esModule: true,
    ...actual,
    default: {
      ...actual.default,
      getStatus: jest.fn().mockResolvedValue({ status: "connected", sessions: [], library: {} }),
      getSections: jest.fn().mockResolvedValue([]),
      getSessions: jest.fn().mockResolvedValue([]),
      getSectionItems: jest.fn().mockResolvedValue([])
    }
  };
});

jest.mock("../services/soulseek", () => {
  const actual = jest.requireActual("../services/soulseek");
  return {
    __esModule: true,
    ...actual,
    default: {
      ...actual.default,
      getDownloads: jest.fn().mockResolvedValue([]),
      search: jest.fn().mockResolvedValue([]),
      cancelDownload: jest.fn().mockResolvedValue(undefined)
    }
  };
});

jest.mock("../services/dashboard", () => {
  return {
    __esModule: true,
    default: {
      getOverview: jest.fn().mockResolvedValue({
        system: {
          backendVersion: "1.0.0",
          status: "ok"
        },
        services: [],
        jobs: []
      })
    }
  };
});

jest.mock("../services/settings", () => {
  const actual = jest.requireActual("../services/settings");
  return {
    __esModule: true,
    default: {
      ...actual.default,
      getSettings: jest.fn().mockResolvedValue(actual.defaultSettings),
      saveSettings: jest.fn().mockResolvedValue(undefined)
    },
    defaultSettings: actual.defaultSettings
  };
});

describe("App", () => {
  beforeEach(() => {
    window.matchMedia = window.matchMedia ||
      (() => ({ matches: false, addEventListener: () => undefined, removeEventListener: () => undefined })) as unknown as typeof window.matchMedia;
  });

  it("renders the navbar and triggers service calls on load", async () => {
    window.history.pushState({}, "", "/dashboard");

    render(<App />);

    expect(await screen.findByText(/harmony/i)).toBeInTheDocument();

    await waitFor(() => {
      expect((spotifyService.getStatus as jest.Mock)).toHaveBeenCalled();
      expect((plexService.getStatus as jest.Mock)).toHaveBeenCalled();
      expect((dashboardService.getOverview as jest.Mock)).toHaveBeenCalled();
      expect((settingsService.getSettings as jest.Mock)).toHaveBeenCalled();
    });
  });
});
// FILE: frontend/src/__tests__/AppHeader.test.tsx
import { act, render, screen } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import type { ComponentProps } from "react";

import AppHeader, { ServiceFilters } from "../components/AppHeader";

const renderHeader = (props?: Partial<ComponentProps<typeof AppHeader>>) => {
  const defaultFilters: ServiceFilters = { spotify: true, plex: true, soulseek: true };
  const onRefresh = jest.fn();
  const onSearchChange = jest.fn();
  const onFilterChange = jest.fn();
  const onThemeToggle = jest.fn();
  const onGoHome = jest.fn();
  const onToggleSidebar = jest.fn();
  const onShowNotifications = jest.fn();

  render(
    <AppHeader
      loading={false}
      onRefresh={onRefresh}
      searchTerm=""
      onSearchChange={onSearchChange}
      filters={defaultFilters}
      onFilterChange={onFilterChange}
      isDarkMode={false}
      onThemeToggle={onThemeToggle}
      onGoHome={onGoHome}
      onToggleSidebar={onToggleSidebar}
      onShowNotifications={onShowNotifications}
      {...props}
    />
  );

  return {
    onRefresh,
    onSearchChange,
    onFilterChange,
    onThemeToggle,
    onGoHome,
    onToggleSidebar,
    onShowNotifications
  };
};

describe("AppHeader", () => {
  it("renders the Harmony logo", () => {
    renderHeader();

    expect(screen.getByLabelText(/harmony logo/i)).toBeInTheDocument();
    expect(screen.getByText(/harmony/i)).toBeInTheDocument();
  });

  it("debounces search input before triggering callback", async () => {
    jest.useFakeTimers();
    const { onSearchChange } = renderHeader();
    const input = screen.getByRole("textbox", {
      name: /search tracks, artists and albums/i
    });

    await userEvent.type(input, "Lo-fi beats");

    expect(onSearchChange).not.toHaveBeenCalled();

    await act(async () => {
      jest.advanceTimersByTime(350);
    });

    expect(onSearchChange).toHaveBeenCalledTimes(1);
    expect(onSearchChange).toHaveBeenCalledWith("Lo-fi beats");

    jest.useRealTimers();
  });

  it("toggles filters when clicking on filter buttons", async () => {
    const { onFilterChange } = renderHeader();

    const spotifyButton = screen.getByRole("button", { name: "Spotify" });
    await userEvent.click(spotifyButton);

    expect(onFilterChange).toHaveBeenCalledWith({
      spotify: false,
      plex: true,
      soulseek: true
    });
  });

  it("invokes refresh callback", async () => {
    const { onRefresh } = renderHeader();

    const refreshButton = screen.getByRole("button", { name: /refresh data/i });
    await userEvent.click(refreshButton);

    expect(onRefresh).toHaveBeenCalledTimes(1);
  });

  it("invokes theme toggle callback", async () => {
    const { onThemeToggle } = renderHeader();

    const themeButton = screen.getByRole("button", { name: /switch to dark mode/i });
    await userEvent.click(themeButton);

    expect(onThemeToggle).toHaveBeenCalledTimes(1);
  });

  it("opens notifications", async () => {
    const { onShowNotifications } = renderHeader();

    const notificationsButton = screen.getByRole("button", { name: /benachrichtigungen anzeigen/i });
    await userEvent.click(notificationsButton);

    expect(onShowNotifications).toHaveBeenCalledTimes(1);
  });
});

// FILE: frontend/src/__tests__/ServiceSettings.test.tsx
import { render, screen, waitFor } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import { ReactNode } from "react";

import { SearchProvider } from "../hooks/useGlobalSearch";
import SpotifyPage from "../pages/SpotifyPage";
import type { ServiceFilters } from "../components/AppHeader";
import settingsService from "../services/settings";

jest.mock("../services/settings", () => {
  const actual = jest.requireActual("../services/settings");
  return {
    __esModule: true,
    default: {
      ...actual.default,
      getSettings: jest.fn(),
      saveSettings: jest.fn()
    },
    defaultSettings: actual.defaultSettings
  };
});

jest.mock("../services/spotify", () => {
  const actual = jest.requireActual("../services/spotify");
  return {
    __esModule: true,
    default: {
      ...actual.default,
      getStatus: jest.fn().mockResolvedValue({ connected: true, lastSync: "vor 1h" }),
      getPlaylists: jest.fn().mockResolvedValue([]),
      searchTracks: jest.fn().mockResolvedValue([])
    }
  };
});

const filters: ServiceFilters = {
  spotify: true,
  plex: true,
  soulseek: true
};

const renderWithProviders = (ui: ReactNode) =>
  render(
    <SearchProvider value={{ term: "", setTerm: () => undefined }}>
      {ui}
    </SearchProvider>
  );

describe("Service settings", () => {
  beforeEach(() => {
    (settingsService.getSettings as jest.Mock).mockResolvedValue({
      spotifyClientId: "client",
      spotifyClientSecret: "secret",
      spotifyRedirectUri: "https://example.com",
      plexBaseUrl: "https://plex.example.com",
      plexToken: "token",
      plexLibrary: "Music",
      soulseekApiUrl: "https://sls.example.com",
      soulseekApiKey: "key"
    });
    (settingsService.saveSettings as jest.Mock).mockResolvedValue(undefined);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  it("switches between overview and settings tabs", async () => {
    renderWithProviders(<SpotifyPage filters={filters} />);

    await waitFor(() => expect(settingsService.getSettings).toHaveBeenCalled());

    expect(screen.getByRole("heading", { name: /spotify status/i })).toBeInTheDocument();

    const settingsTab = screen.getByRole("tab", { name: /einstellungen/i });
    await userEvent.click(settingsTab);

    expect(screen.getByRole("heading", { name: /spotify einstellungen/i })).toBeInTheDocument();
  });

  it("renders settings returned from the api", async () => {
    renderWithProviders(<SpotifyPage filters={filters} />);

    const clientIdInput = await screen.findByLabelText(/client id/i);
    expect(clientIdInput).toHaveValue("client");
    expect(screen.getByLabelText(/client secret/i)).toHaveValue("secret");
    expect(screen.getByLabelText(/redirect uri/i)).toHaveValue("https://example.com");
  });

  it("saves updated settings", async () => {
    renderWithProviders(<SpotifyPage filters={filters} />);

    const clientIdInput = await screen.findByLabelText(/client id/i);
    await userEvent.clear(clientIdInput);
    await userEvent.type(clientIdInput, "new-client");

    await userEvent.click(screen.getByRole("button", { name: /einstellungen speichern/i }));

    await waitFor(() => {
      expect(settingsService.saveSettings).toHaveBeenCalledWith(
        expect.objectContaining({ spotifyClientId: "new-client" })
      );
    });
  });

  it("shows an error when saving fails", async () => {
    (settingsService.saveSettings as jest.Mock).mockRejectedValueOnce(new Error("fail"));
    renderWithProviders(<SpotifyPage filters={filters} />);

    const button = await screen.findByRole("button", { name: /einstellungen speichern/i });
    await userEvent.click(button);

    await waitFor(() => {
      expect(screen.getByText(/fehler beim speichern der einstellungen/i)).toBeInTheDocument();
    });
  });
});
// FILE: frontend/src/components/AppHeader.tsx
import { useEffect, useMemo, useState } from "react";
import { RefreshCw, Loader2, Search, X, Sun, Moon, Menu, Sparkles, Bell } from "lucide-react";

import { Button } from "./ui/button";
import { Input } from "./ui/input";
import Logo from "./Logo";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger
} from "./ui/tooltip";

type ServiceFilters = {
  spotify: boolean;
  plex: boolean;
  soulseek: boolean;
};

interface AppHeaderProps {
  loading: boolean;
  onRefresh: () => void;
  searchTerm: string;
  onSearchChange: (value: string) => void;
  filters: ServiceFilters;
  onFilterChange: (filters: ServiceFilters) => void;
  isDarkMode: boolean;
  onThemeToggle: () => void;
  onGoHome: () => void;
  onToggleSidebar: () => void;
  onShowWhatsNew?: () => void;
  onShowNotifications?: () => void;
  hasNewFeatures?: boolean;
}

const SEARCH_DEBOUNCE = 300;

const AppHeader = ({
  loading,
  onRefresh,
  searchTerm,
  onSearchChange,
  filters,
  onFilterChange,
  isDarkMode,
  onThemeToggle,
  onGoHome,
  onToggleSidebar,
  onShowWhatsNew,
  onShowNotifications,
  hasNewFeatures = false
}: AppHeaderProps) => {
  const [localSearchTerm, setLocalSearchTerm] = useState(searchTerm);
  const [searching, setSearching] = useState(false);

  const filterButtons = useMemo(
    () => [
      {
        key: "spotify" as const,
        label: "Spotify",
        isActive: filters.spotify,
        activeClass:
          "bg-green-100 text-green-800 dark:bg-green-900/30 dark:text-green-300",
        onClick: () =>
          onFilterChange({ ...filters, spotify: !filters.spotify }),
        title: filters.spotify
          ? "Disable Spotify filter"
          : "Enable Spotify filter"
      },
      {
        key: "plex" as const,
        label: "Plex",
        isActive: filters.plex,
        activeClass:
          "bg-orange-100 text-orange-800 dark:bg-orange-900/30 dark:text-orange-300",
        onClick: () => onFilterChange({ ...filters, plex: !filters.plex }),
        title: filters.plex ? "Disable Plex filter" : "Enable Plex filter"
      },
      {
        key: "soulseek" as const,
        label: "Soulseek",
        isActive: filters.soulseek,
        activeClass:
          "bg-blue-100 text-blue-800 dark:bg-blue-900/30 dark:text-blue-300",
        onClick: () =>
          onFilterChange({ ...filters, soulseek: !filters.soulseek }),
        title: filters.soulseek
          ? "Disable Soulseek filter"
          : "Enable Soulseek filter"
      }
    ],
    [filters, onFilterChange]
  );

  const searchIcon = useMemo(
    () =>
      searching ? (
        <Loader2 className="h-4 w-4 text-indigo-500 animate-spin" />
      ) : (
        <Search className="h-4 w-4 text-gray-400" />
      ),
    [searching]
  );

  const refreshIcon = useMemo(
    () =>
      loading ? (
        <Loader2 className="h-5 w-5 animate-spin" />
      ) : (
        <RefreshCw className="h-5 w-5" />
      ),
    [loading]
  );

  useEffect(() => {
    if (localSearchTerm !== searchTerm) {
      setSearching(true);
      const debounceTimer = window.setTimeout(() => {
        onSearchChange(localSearchTerm);
        setSearching(false);
      }, SEARCH_DEBOUNCE);

      return () => {
        window.clearTimeout(debounceTimer);
        setSearching(false);
      };
    }

    return undefined;
  }, [localSearchTerm, searchTerm, onSearchChange]);

  useEffect(() => {
    setLocalSearchTerm(searchTerm);
  }, [searchTerm]);

  const inputPadding = localSearchTerm ? "pr-12" : "pr-10";

  return (
    <TooltipProvider>
      <header className="sticky top-0 z-50 border-b border-slate-200 bg-white transition-colors dark:border-slate-800 dark:bg-slate-900">
        <div className="min-h-16 relative flex flex-col items-center justify-between gap-4 px-4 py-2 sm:px-6 md:flex-row">
          <div className="flex w-full items-center gap-4 md:w-auto">
            <button
              onClick={onToggleSidebar}
              className="-ml-2 rounded-md p-2 text-slate-600 transition hover:bg-slate-100 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-indigo-500 focus-visible:ring-offset-2 focus-visible:ring-offset-white dark:text-slate-300 dark:hover:bg-slate-800 dark:focus-visible:ring-offset-slate-900 md:hidden"
              aria-label="Open navigation sidebar"
              type="button"
            >
              <Menu className="h-6 w-6" />
            </button>
            <button
              onClick={onGoHome}
              className="group flex items-center gap-3 text-xl font-bold text-slate-800 transition focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-indigo-500 focus-visible:ring-offset-2 focus-visible:ring-offset-white dark:text-slate-200 dark:focus-visible:ring-offset-slate-900"
              type="button"
            >
              <Logo
                className={`h-10 w-10 text-slate-600 transition-all duration-300 ease-in-out group-hover:rotate-[30deg] dark:text-slate-300 ${
                  loading ? "animate-spin" : ""
                }`}
              />
              <span className="tracking-tighter">Harmony</span>
            </button>
          </div>

          <div className="flex w-full flex-wrap items-center justify-center gap-x-4 gap-y-2 md:w-auto md:justify-end">
            <div className="relative w-full md:w-auto">
              <div className="pointer-events-none absolute inset-y-0 left-0 flex items-center pl-3">
                {searchIcon}
              </div>
              <Input
                type="text"
                placeholder="Search tracks, artists, albums..."
                aria-label="Search tracks, artists and albums"
                className={`w-full max-w-[36rem] rounded-lg border-gray-300 pl-10 text-sm focus:ring-2 focus:ring-indigo-500 focus:ring-offset-0 dark:border-gray-700 dark:bg-slate-900 dark:text-slate-100 dark:focus:ring-offset-slate-900 ${inputPadding}`}
                value={localSearchTerm}
                onChange={(event) => setLocalSearchTerm(event.target.value)}
              />
              {localSearchTerm && (
                <div className="absolute inset-y-0 right-0 flex items-center space-x-2 pr-3">
                  <Tooltip>
                    <TooltipTrigger asChild>
                      <button
                        onClick={() => {
                          setLocalSearchTerm("");
                          onSearchChange("");
                        }}
                        className="text-gray-400 transition hover:text-gray-500 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-indigo-500 focus-visible:ring-offset-2 focus-visible:ring-offset-white dark:text-gray-500 dark:hover:text-gray-400 dark:focus-visible:ring-offset-slate-900"
                        aria-label="Clear search input"
                        type="button"
                      >
                        <X className="h-4 w-4" />
                      </button>
                    </TooltipTrigger>
                    <TooltipContent>Clear search</TooltipContent>
                  </Tooltip>
                </div>
              )}
            </div>

            <div className="flex items-center space-x-2">
              {filterButtons.map((filter) => (
                <Tooltip key={filter.key}>
                  <TooltipTrigger asChild>
                    <button
                      onClick={filter.onClick}
                      className={`rounded-lg px-3 py-1.5 text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-indigo-500 focus-visible:ring-offset-2 focus-visible:ring-offset-white dark:focus-visible:ring-offset-slate-900 ${
                        filter.isActive
                          ? filter.activeClass
                          : "bg-gray-100 text-gray-600 hover:bg-gray-200 dark:bg-gray-800 dark:text-gray-300 dark:hover:bg-gray-700"
                      }`}
                      aria-pressed={filter.isActive}
                      type="button"
                    >
                      {filter.label}
                    </button>
                  </TooltipTrigger>
                  <TooltipContent>{filter.title}</TooltipContent>
                </Tooltip>
              ))}
            </div>

            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  variant="ghost"
                  size="icon"
                  onClick={onRefresh}
                  disabled={loading}
                  className="hover:bg-gray-100 dark:hover:bg-gray-800"
                  aria-label="Refresh data"
                  type="button"
                >
                  {refreshIcon}
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                {loading ? "Refreshing..." : "Refresh all data"}
              </TooltipContent>
            </Tooltip>

            {onShowWhatsNew && (
              <Tooltip>
                <TooltipTrigger asChild>
                  <Button
                    variant="ghost"
                    size="icon"
                    onClick={onShowWhatsNew}
                    className={`relative hover:bg-gray-100 dark:hover:bg-gray-800 ${
                      hasNewFeatures
                        ? "text-indigo-600 dark:text-indigo-400 animate-pulse"
                        : ""
                    }`}
                    aria-label={
                      hasNewFeatures
                        ? "Open what's new panel"
                        : "Show latest updates"
                    }
                    type="button"
                  >
                    <Sparkles className="h-5 w-5" />
                  </Button>
                </TooltipTrigger>
                <TooltipContent>
                  {hasNewFeatures ? "See what's new!" : "What's new"}
                </TooltipContent>
              </Tooltip>
            )}

            {onShowNotifications && (
              <Tooltip>
                <TooltipTrigger asChild>
                  <Button
                    variant="ghost"
                    size="icon"
                    onClick={onShowNotifications}
                    className="hover:bg-gray-100 dark:hover:bg-gray-800"
                    aria-label="Benachrichtigungen anzeigen"
                    type="button"
                  >
                    <Bell className="h-5 w-5" />
                  </Button>
                </TooltipTrigger>
                <TooltipContent>Benachrichtigungen</TooltipContent>
              </Tooltip>
            )}

            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  variant="ghost"
                  size="icon"
                  onClick={onThemeToggle}
                  className="hover:bg-gray-100 dark:hover:bg-gray-800"
                  aria-label={
                    isDarkMode ? "Switch to light mode" : "Switch to dark mode"
                  }
                  type="button"
                >
                  {isDarkMode ? (
                    <Sun className="h-5 w-5" />
                  ) : (
                    <Moon className="h-5 w-5" />
                  )}
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                {isDarkMode ? "Switch to light mode" : "Switch to dark mode"}
              </TooltipContent>
            </Tooltip>
          </div>
        </div>
      </header>
    </TooltipProvider>
  );
};

export type { AppHeaderProps, ServiceFilters };
export default AppHeader;

// FILE: frontend/src/components/DarkModeToggle.tsx
import { useEffect, useState } from "react";
import { MoonStar, Sun } from "lucide-react";
import { Button } from "./ui/button";
import { cn } from "../lib/utils";

type Theme = "light" | "dark";

const THEME_STORAGE_KEY = "theme";

const getStoredTheme = (): Theme => {
  if (typeof window === "undefined") {
    return "light";
  }
  const stored = window.localStorage.getItem(THEME_STORAGE_KEY);
  return stored === "dark" || stored === "light" ? stored : "light";
};

const applyTheme = (theme: Theme) => {
  if (typeof document === "undefined") {
    return;
  }
  const root = document.documentElement;
  root.classList.toggle("dark", theme === "dark");
  root.style.setProperty("color-scheme", theme);
};

const DarkModeToggle = () => {
  const [theme, setTheme] = useState<Theme>(() => getStoredTheme());

  useEffect(() => {
    applyTheme(theme);
    if (typeof window !== "undefined") {
      window.localStorage.setItem(THEME_STORAGE_KEY, theme);
    }
  }, [theme]);

  const toggleTheme = () => {
    setTheme((current) => (current === "light" ? "dark" : "light"));
  };

  const isDark = theme === "dark";

  return (
    <Button
      type="button"
      variant="ghost"
      size="icon"
      onClick={toggleTheme}
      aria-pressed={isDark}
      aria-label={isDark ? "Dark Mode aktiv" : "Light Mode aktiv"}
      className="relative text-navbar-foreground"
    >
      <Sun
        className={cn(
          "h-5 w-5 transition-all",
          isDark ? "rotate-90 scale-0" : "rotate-0 scale-100"
        )}
      />
      <MoonStar
        className={cn(
          "absolute h-5 w-5 transition-all",
          isDark ? "rotate-0 scale-100" : "rotate-90 scale-0"
        )}
      />
      <span className="sr-only">Farbschema wechseln</span>
    </Button>
  );
};

export default DarkModeToggle;

// FILE: frontend/src/components/Layout.tsx
import { ReactNode } from "react";
import { Outlet } from "react-router-dom";
import * as Dialog from "@radix-ui/react-dialog";
import { X } from "lucide-react";

import Sidebar from "./Sidebar";
import { Button } from "./ui/button";

interface LayoutProps {
  header: ReactNode;
  isSidebarOpen: boolean;
  onSidebarOpenChange: (open: boolean) => void;
}

const Layout = ({ header, isSidebarOpen, onSidebarOpenChange }: LayoutProps) => {
  return (
    <div className="min-h-screen bg-background text-foreground">
      <div className="sticky top-0 z-50">{header}</div>

      <Dialog.Root open={isSidebarOpen} onOpenChange={onSidebarOpenChange}>
        <Dialog.Portal>
          <Dialog.Overlay className="fixed inset-0 bg-background/80 backdrop-blur-sm data-[state=open]:animate-fade-in data-[state=closed]:animate-fade-out" />
          <Dialog.Content className="radix-side-drawer fixed inset-y-0 left-0 z-50 w-72 border-r border-border/60 bg-sidebar p-4 text-sidebar-foreground shadow-xl data-[state=open]:animate-drawer-in data-[state=closed]:animate-drawer-out">
            <div className="mb-4 flex items-center justify-between">
              <h2 className="text-lg font-semibold">Navigation</h2>
              <Dialog.Close asChild>
                <Button variant="ghost" size="icon">
                  <X className="h-5 w-5" />
                  <span className="sr-only">Close navigation</span>
                </Button>
              </Dialog.Close>
            </div>
            <Sidebar onNavigate={() => onSidebarOpenChange(false)} />
          </Dialog.Content>
        </Dialog.Portal>
      </Dialog.Root>

      <div className="flex">
        <aside className="fixed inset-y-0 left-0 hidden w-64 flex-shrink-0 border-r border-border/60 bg-sidebar/90 backdrop-blur md:block">
          <Sidebar />
        </aside>
        <main className="flex-1 px-4 pb-8 pt-6 md:ml-64 md:px-10">
          <Outlet />
        </main>
      </div>
    </div>
  );
};

export default Layout;

// FILE: frontend/src/components/Logo.tsx
import { memo } from "react";

import { cn } from "../lib/utils";

interface LogoProps {
  className?: string;
}

const Logo = memo(({ className }: LogoProps) => (
  <svg
    role="img"
    aria-label="Harmony logo"
    viewBox="0 0 64 64"
    className={cn("text-indigo-600", className)}
  >
    <defs>
      <linearGradient id="harmonyGradient" x1="0%" y1="0%" x2="100%" y2="100%">
        <stop offset="0%" stopColor="currentColor" stopOpacity="0.9" />
        <stop offset="100%" stopColor="currentColor" stopOpacity="0.6" />
      </linearGradient>
    </defs>
    <circle cx="32" cy="32" r="30" fill="url(#harmonyGradient)" opacity="0.2" />
    <path
      d="M18 20c0-2.21 1.79-4 4-4h4c2.21 0 4 1.79 4 4v16.3c0 3.52 2.85 6.37 6.37 6.37h5.26c3.52 0 6.37-2.85 6.37-6.37 0-3.51-2.85-6.36-6.37-6.36h-3.26"
      fill="none"
      stroke="currentColor"
      strokeWidth="4"
      strokeLinecap="round"
      strokeLinejoin="round"
    />
    <circle cx="26" cy="44" r="4" fill="currentColor" />
    <circle cx="44" cy="44" r="4" fill="currentColor" />
  </svg>
));
Logo.displayName = "Logo";

export default Logo;

// FILE: frontend/src/components/Navbar.tsx
import { useState } from "react";
import { Link } from "react-router-dom";
import * as Dialog from "@radix-ui/react-dialog";
import { Menu, X } from "lucide-react";
import Sidebar from "./Sidebar";
import { Button } from "./ui/button";
import DarkModeToggle from "./DarkModeToggle";

const Navbar = () => {
  const [mobileOpen, setMobileOpen] = useState(false);

  return (
    <header className="fixed inset-x-0 top-0 z-50 border-b border-border/60 bg-navbar/90 backdrop-blur">
      <div className="mx-auto flex h-16 w-full max-w-6xl items-center justify-between px-4 text-navbar-foreground md:px-8">
        <div className="flex items-center gap-3">
          <Dialog.Root open={mobileOpen} onOpenChange={setMobileOpen}>
            <Dialog.Trigger asChild>
              <Button variant="ghost" size="icon" className="md:hidden">
                <Menu className="h-5 w-5" />
                <span className="sr-only">Open navigation</span>
              </Button>
            </Dialog.Trigger>
            <Dialog.Portal>
              <Dialog.Overlay className="fixed inset-0 bg-background/80 backdrop-blur-sm data-[state=open]:animate-fade-in data-[state=closed]:animate-fade-out" />
              <Dialog.Content className="radix-side-drawer fixed inset-y-0 left-0 z-50 w-72 border-r border-border/60 bg-sidebar p-4 text-sidebar-foreground shadow-xl data-[state=open]:animate-drawer-in data-[state=closed]:animate-drawer-out">
                <div className="mb-4 flex items-center justify-between">
                  <h2 className="text-lg font-semibold">Navigation</h2>
                  <Dialog.Close asChild>
                    <Button variant="ghost" size="icon">
                      <X className="h-5 w-5" />
                      <span className="sr-only">Close navigation</span>
                    </Button>
                  </Dialog.Close>
                </div>
                <Sidebar onNavigate={() => setMobileOpen(false)} />
              </Dialog.Content>
            </Dialog.Portal>
          </Dialog.Root>
          <Link to="/dashboard" className="text-xl font-semibold tracking-tight">
            Harmony
          </Link>
        </div>
        <div className="flex items-center gap-3">
          <DarkModeToggle />
          <div className="hidden text-sm font-medium text-muted-foreground md:block">
            Willkommen zurück, User
          </div>
          <Button variant="outline" className="border-border/80 text-navbar-foreground">
            User Menü
          </Button>
        </div>
      </div>
    </header>
  );
};

export default Navbar;

// FILE: frontend/src/components/Sidebar.tsx
import { NavLink } from "react-router-dom";
import { LayoutDashboard, Music, Radio, Share2, Shuffle, Settings, Disc } from "lucide-react";
import { cn } from "../lib/utils";

const navItems = [
  { to: "/dashboard", label: "Dashboard", icon: LayoutDashboard },
  { to: "/spotify", label: "Spotify", icon: Music },
  { to: "/plex", label: "Plex", icon: Share2 },
  { to: "/soulseek", label: "Soulseek", icon: Radio },
  { to: "/beets", label: "Beets", icon: Disc },
  { to: "/matching", label: "Matching", icon: Shuffle },
  { to: "/settings", label: "Settings", icon: Settings }
];

interface SidebarProps {
  onNavigate?: () => void;
}

const Sidebar = ({ onNavigate }: SidebarProps) => {
  return (
    <nav className="flex h-full flex-col gap-1 bg-sidebar/50 p-4 text-sidebar-muted">
      {navItems.map((item) => {
        const Icon = item.icon;
        return (
          <NavLink
            key={item.to}
            to={item.to}
            className={({ isActive }) =>
              cn(
                "flex items-center gap-3 rounded-md px-3 py-2 text-sm font-medium transition focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-primary/70 focus-visible:ring-offset-2 focus-visible:ring-offset-background",
                isActive
                  ? "bg-sidebar-accent/15 text-sidebar-accent-foreground"
                  : "text-sidebar-muted hover:bg-sidebar-accent/10 hover:text-sidebar-foreground"
              )
            }
            onClick={onNavigate}
          >
            <Icon className="h-4 w-4" />
            {item.label}
          </NavLink>
        );
      })}
    </nav>
  );
};

export default Sidebar;
export { navItems };

// FILE: frontend/src/components/__tests__/DarkModeToggle.test.tsx
import { render, screen } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import DarkModeToggle from "../DarkModeToggle";

describe("DarkModeToggle", () => {
  beforeEach(() => {
    document.documentElement.classList.remove("dark");
    document.documentElement.style.removeProperty("color-scheme");
    window.localStorage.clear();
  });

  it("renders the toggle button with light mode active by default", () => {
    render(<DarkModeToggle />);

    const button = screen.getByRole("button", { name: /light mode aktiv/i });
    expect(button).toBeInTheDocument();
    expect(button).toHaveAttribute("aria-pressed", "false");
    expect(document.documentElement.classList.contains("dark")).toBe(false);
    expect(document.documentElement.style.getPropertyValue("color-scheme")).toBe("light");
  });

  it("toggles the theme and persists the choice", async () => {
    const user = userEvent.setup();
    render(<DarkModeToggle />);

    const button = screen.getByRole("button", { name: /light mode aktiv/i });
    await user.click(button);

    expect(document.documentElement.classList.contains("dark")).toBe(true);
    expect(document.documentElement.style.getPropertyValue("color-scheme")).toBe("dark");
    expect(window.localStorage.getItem("theme")).toBe("dark");
    expect(button).toHaveAttribute("aria-pressed", "true");
    expect(button).toHaveAttribute("aria-label", "Dark Mode aktiv");
  });

  it("initialises with a stored dark theme", () => {
    window.localStorage.setItem("theme", "dark");
    render(<DarkModeToggle />);

    const button = screen.getByRole("button", { name: /dark mode aktiv/i });
    expect(document.documentElement.classList.contains("dark")).toBe(true);
    expect(document.documentElement.style.getPropertyValue("color-scheme")).toBe("dark");
    expect(button).toHaveAttribute("aria-pressed", "true");
  });
});

// FILE: frontend/src/components/ui/badge.tsx
import * as React from "react";
import { cva, type VariantProps } from "class-variance-authority";
import { cn } from "../../lib/utils";

const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default: "border-transparent bg-indigo-600 text-white hover:bg-indigo-700",
        secondary: "border-transparent bg-muted text-muted-foreground",
        outline: "text-foreground"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
);

export interface BadgeProps extends React.HTMLAttributes<HTMLDivElement>, VariantProps<typeof badgeVariants> {}

const Badge = ({ className, variant, ...props }: BadgeProps) => {
  return <div className={cn(badgeVariants({ variant }), className)} {...props} />;
};

Badge.displayName = "Badge";

export { Badge, badgeVariants };

// FILE: frontend/src/components/ui/button.tsx
import * as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";
import { cn } from "../../lib/utils";

const buttonVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-primary focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline: "border border-border bg-transparent text-foreground hover:bg-muted/60",
        secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "text-foreground hover:bg-muted/60",
        link: "text-primary underline-offset-4 hover:underline"
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-5",
        icon: "h-10 w-10"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
);

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button";
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    );
  }
);
Button.displayName = "Button";

export { Button, buttonVariants };

// FILE: frontend/src/components/ui/card.tsx
import * as React from "react";
import { cn } from "../../lib/utils";

const Card = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => (
    <div
      ref={ref}
      className={cn("rounded-lg border border-border/60 bg-card p-6 text-card-foreground shadow-sm", className)}
      {...props}
    />
  )
);
Card.displayName = "Card";

const CardHeader = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => (
    <div ref={ref} className={cn("mb-4 flex flex-col gap-1", className)} {...props} />
  )
);
CardHeader.displayName = "CardHeader";

const CardTitle = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLHeadingElement>>(
  ({ className, ...props }, ref) => (
    <h3 ref={ref} className={cn("text-lg font-semibold", className)} {...props} />
  )
);
CardTitle.displayName = "CardTitle";

const CardDescription = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLParagraphElement>>(
  ({ className, ...props }, ref) => (
    <p ref={ref} className={cn("text-sm text-muted-foreground", className)} {...props} />
  )
);
CardDescription.displayName = "CardDescription";

const CardContent = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => (
    <div ref={ref} className={cn("text-sm text-muted-foreground", className)} {...props} />
  )
);
CardContent.displayName = "CardContent";

export { Card, CardHeader, CardTitle, CardDescription, CardContent };

// FILE: frontend/src/components/ui/input.tsx
import * as React from "react";
import { cn } from "../../lib/utils";

const Input = React.forwardRef<HTMLInputElement, React.InputHTMLAttributes<HTMLInputElement>>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-primary focus-visible:ring-offset-2 focus-visible:ring-offset-background",
          className
        )}
        ref={ref}
        {...props}
      />
    );
  }
);
Input.displayName = "Input";

export { Input };

// FILE: frontend/src/components/ui/label.tsx
import * as React from "react";
import { cn } from "../../lib/utils";

const Label = React.forwardRef<HTMLLabelElement, React.LabelHTMLAttributes<HTMLLabelElement>>(
  ({ className, ...props }, ref) => (
    <label
      ref={ref}
      className={cn("text-sm font-medium text-foreground", className)}
      {...props}
    />
  )
);
Label.displayName = "Label";

export { Label };

// FILE: frontend/src/components/ui/switch.tsx
import * as React from "react";
import * as SwitchPrimitives from "@radix-ui/react-switch";
import { cn } from "../../lib/utils";

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent bg-muted transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-primary focus-visible:ring-offset-2 focus-visible:ring-offset-background data-[state=checked]:bg-primary",
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb className="pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0" />
  </SwitchPrimitives.Root>
));
Switch.displayName = SwitchPrimitives.Root.displayName;

export { Switch };

// FILE: frontend/src/components/ui/table.tsx
import * as React from "react";
import * as TablePrimitive from "@radix-ui/react-table";
import { cn } from "../../lib/utils";

const Table = React.forwardRef<
  React.ElementRef<typeof TablePrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof TablePrimitive.Root>
>(({ className, ...props }, ref) => (
  <TablePrimitive.Root
    ref={ref}
    className={cn("w-full caption-bottom overflow-hidden rounded-lg border border-border/60 bg-card text-sm text-card-foreground", className)}
    {...props}
  />
));
Table.displayName = "Table";

const TableHeader = React.forwardRef<
  React.ElementRef<typeof TablePrimitive.Header>,
  React.ComponentPropsWithoutRef<typeof TablePrimitive.Header>
>(({ className, ...props }, ref) => (
  <TablePrimitive.Header
    ref={ref}
    className={cn("bg-muted/40 text-left text-xs font-medium uppercase tracking-wide text-muted-foreground", className)}
    {...props}
  />
));
TableHeader.displayName = "TableHeader";

const TableRow = React.forwardRef<
  React.ElementRef<typeof TablePrimitive.Row>,
  React.ComponentPropsWithoutRef<typeof TablePrimitive.Row>
>(({ className, ...props }, ref) => (
  <TablePrimitive.Row
    ref={ref}
    className={cn(
      "border-b border-border/40 transition hover:bg-muted/40 data-[state=selected]:bg-muted/40 last:border-0",
      className
    )}
    {...props}
  />
));
TableRow.displayName = "TableRow";

const TableHead = React.forwardRef<
  React.ElementRef<typeof TablePrimitive.ColumnHeaderCell>,
  React.ComponentPropsWithoutRef<typeof TablePrimitive.ColumnHeaderCell>
>(({ className, ...props }, ref) => (
  <TablePrimitive.ColumnHeaderCell
    ref={ref}
    className={cn("px-4 py-3 font-medium", className)}
    {...props}
  />
));
TableHead.displayName = "TableHead";

const TableBody = React.forwardRef<
  React.ElementRef<typeof TablePrimitive.Body>,
  React.ComponentPropsWithoutRef<typeof TablePrimitive.Body>
>(({ className, ...props }, ref) => (
  <TablePrimitive.Body ref={ref} className={cn("divide-y divide-border/40", className)} {...props} />
));
TableBody.displayName = "TableBody";

const TableCell = React.forwardRef<
  React.ElementRef<typeof TablePrimitive.Cell>,
  React.ComponentPropsWithoutRef<typeof TablePrimitive.Cell>
>(({ className, ...props }, ref) => (
  <TablePrimitive.Cell ref={ref} className={cn("px-4 py-3", className)} {...props} />
));
TableCell.displayName = "TableCell";

export { Table, TableHeader, TableRow, TableHead, TableBody, TableCell };

// FILE: frontend/src/components/ui/tabs.tsx
import * as TabsPrimitive from "@radix-ui/react-tabs";
import { cn } from "../../lib/utils";

const Tabs = TabsPrimitive.Root;

const TabsList = ({ className, ...props }: TabsPrimitive.TabsListProps) => (
  <TabsPrimitive.List
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
);

TabsList.displayName = TabsPrimitive.List.displayName;

const TabsTrigger = ({ className, ...props }: TabsPrimitive.TabsTriggerProps) => (
  <TabsPrimitive.Trigger
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium transition-all",
      "focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      "disabled:pointer-events-none disabled:opacity-50",
      "data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow",
      className
    )}
    {...props}
  />
);

TabsTrigger.displayName = TabsPrimitive.Trigger.displayName;

const TabsContent = ({ className, ...props }: TabsPrimitive.TabsContentProps) => (
  <TabsPrimitive.Content
    className={cn(
      "mt-4 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
);

TabsContent.displayName = TabsPrimitive.Content.displayName;

export { Tabs, TabsList, TabsTrigger, TabsContent };

// FILE: frontend/src/components/ui/toast.tsx
import { cva, type VariantProps } from "class-variance-authority";
import { X } from "lucide-react";
import * as React from "react";
import * as ToastPrimitives from "@radix-ui/react-toast";
import { cn } from "../../lib/utils";

const ToastProvider = ToastPrimitives.Provider;
const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed top-20 right-4 z-[100] flex max-h-screen w-full max-w-sm flex-col gap-3 p-4 md:right-8",
      className
    )}
    {...props}
  />
));
ToastViewport.displayName = ToastPrimitives.Viewport.displayName;

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-lg border border-border/60 bg-card/95 p-4 text-sm text-card-foreground shadow-lg transition-all backdrop-blur",
  {
    variants: {
      variant: {
        default: "",
        destructive: "border-destructive/60 bg-destructive/15 text-destructive-foreground"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
);

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(
        toastVariants({ variant }),
        "data-[state=open]:animate-toast-show data-[state=closed]:animate-toast-hide",
        className
      )}
      {...props}
    />
  );
});
Toast.displayName = ToastPrimitives.Root.displayName;

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title ref={ref} className={cn("text-sm font-semibold", className)} {...props} />
));
ToastTitle.displayName = ToastPrimitives.Title.displayName;

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description ref={ref} className={cn("text-sm text-muted-foreground", className)} {...props} />
));
ToastDescription.displayName = ToastPrimitives.Description.displayName;

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute top-3 right-3 rounded-md p-1 text-muted-foreground transition hover:bg-muted/60 hover:text-foreground",
      className
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
));
ToastClose.displayName = ToastPrimitives.Close.displayName;

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action ref={ref} className={cn("ml-auto", className)} {...props} />
));
ToastAction.displayName = ToastPrimitives.Action.displayName;

export {
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction
};

// FILE: frontend/src/components/ui/toaster.tsx
import { Toast, ToastClose, ToastDescription, ToastProvider, ToastTitle, ToastViewport } from "./toast";
import { useToast } from "./use-toast";

export function Toaster() {
  const { toasts } = useToast();

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && <ToastDescription>{description}</ToastDescription>}
            </div>
            {action}
            <ToastClose />
          </Toast>
        );
      })}
      <ToastViewport />
    </ToastProvider>
  );
}

export { useToast };

// FILE: frontend/src/components/ui/tooltip.tsx
import * as React from "react";
import * as TooltipPrimitive from "@radix-ui/react-tooltip";

import { cn } from "../../lib/utils";

const TooltipProvider = TooltipPrimitive.Provider;
const Tooltip = TooltipPrimitive.Root;
const TooltipTrigger = TooltipPrimitive.Trigger;
const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95",
      className
    )}
    {...props}
  />
));
TooltipContent.displayName = TooltipPrimitive.Content.displayName;

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider };

// FILE: frontend/src/components/ui/use-toast.ts
import * as React from "react";

const TOAST_LIMIT = 1;
const TOAST_REMOVE_DELAY = 1000;

type ToasterToast = {
  id: string;
  title?: React.ReactNode;
  description?: React.ReactNode;
  action?: React.ReactNode;
  duration?: number;
  type?: "foreground" | "background";
  open?: boolean;
};

type Toast = Omit<ToasterToast, "id">;

type ToastAction =
  | { type: "ADD_TOAST"; toast: ToasterToast }
  | { type: "UPDATE_TOAST"; toast: Partial<ToasterToast> & { id: string } }
  | { type: "DISMISS_TOAST"; toastId?: string }
  | { type: "REMOVE_TOAST"; toastId?: string };

let count = 0;

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER;
  return count.toString();
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>();

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return;
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId);
    dispatch({ type: "REMOVE_TOAST", toastId });
  }, TOAST_REMOVE_DELAY);

  toastTimeouts.set(toastId, timeout);
};

const reducer = (state: ToasterToast[], action: ToastAction): ToasterToast[] => {
  switch (action.type) {
    case "ADD_TOAST":
      return [action.toast, ...state].slice(0, TOAST_LIMIT);

    case "UPDATE_TOAST":
      return state.map((t) => (t.id === action.toast.id ? { ...t, ...action.toast } : t));

    case "DISMISS_TOAST": {
      const { toastId } = action;

      if (toastId) {
        addToRemoveQueue(toastId);
      } else {
        state.forEach((toast) => {
          addToRemoveQueue(toast.id);
        });
      }

      return state.map((toast) =>
        toast.id === toastId || toastId === undefined
          ? {
              ...toast,
              open: false
            }
          : toast
      );
    }

    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return [];
      }
      return state.filter((toast) => toast.id !== action.toastId);
  }
};

const listeners: Array<(state: ToasterToast[]) => void> = [];

let memoryState: ToasterToast[] = [];

function dispatch(action: ToastAction) {
  memoryState = reducer(memoryState, action);
  listeners.forEach((listener) => listener(memoryState));
}

export function useToast() {
  const [state, setState] = React.useState<ToasterToast[]>(memoryState);

  React.useEffect(() => {
    listeners.push(setState);
    return () => {
      const index = listeners.indexOf(setState);
      if (index > -1) listeners.splice(index, 1);
    };
  }, []);

  return {
    toasts: state,
    toast: ({ ...props }: Toast) => {
      const id = genId();

      const update = (props: ToasterToast) =>
        dispatch({
          type: "UPDATE_TOAST",
          toast: { ...props, id }
        });

      const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id });

      dispatch({
        type: "ADD_TOAST",
        toast: {
          ...props,
          id
        }
      });

      return {
        id,
        dismiss,
        update
      };
    },
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId })
  };
}

export type { Toast };

// FILE: frontend/src/hooks/useDebouncedValue.ts
import { useEffect, useState } from "react";

const useDebouncedValue = <T,>(value: T, delay: number) => {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const timer = window.setTimeout(() => setDebouncedValue(value), delay);
    return () => window.clearTimeout(timer);
  }, [value, delay]);

  return debouncedValue;
};

export default useDebouncedValue;

// FILE: frontend/src/hooks/useEventSource.ts
import { useEffect, useRef } from "react";

type EventSourceHandler<T> = (data: T) => void;

type Options = {
  event?: string;
  enabled?: boolean;
};

const useEventSource = <T,>(url: string, handler: EventSourceHandler<T>, options: Options = {}) => {
  const handlerRef = useRef(handler);
  handlerRef.current = handler;

  useEffect(() => {
    if (typeof window === "undefined" || options.enabled === false) {
      return undefined;
    }

    const source = new EventSource(url, { withCredentials: false });
    const listener = (event: MessageEvent) => {
      try {
        const payload = JSON.parse(event.data) as T;
        handlerRef.current(payload);
      } catch (error) {
        console.error("Failed to parse event source payload", error);
      }
    };

    if (options.event) {
      source.addEventListener(options.event, listener);
    } else {
      source.onmessage = listener;
    }

    source.onerror = (error) => {
      console.error("EventSource error", error);
    };

    return () => {
      if (options.event) {
        source.removeEventListener(options.event, listener);
      }
      source.close();
    };
  }, [url, options.enabled, options.event]);
};

export default useEventSource;

// FILE: frontend/src/hooks/useGlobalSearch.tsx
import { createContext, useContext } from "react";

type SearchContextValue = {
  term: string;
  setTerm: (term: string) => void;
};

const SearchContext = createContext<SearchContextValue | undefined>(undefined);

const SearchProvider = SearchContext.Provider;

const useGlobalSearch = () => {
  const context = useContext(SearchContext);
  if (!context) {
    throw new Error("useGlobalSearch must be used within a SearchProvider");
  }
  return context;
};

export { SearchContext, SearchProvider, useGlobalSearch };

// FILE: frontend/src/hooks/useTheme.ts
import { useCallback, useEffect, useState } from "react";

type Theme = "light" | "dark";

const STORAGE_KEY = "theme";

const getPreferredTheme = (): Theme => {
  if (typeof window === "undefined") {
    return "light";
  }

  const stored = window.localStorage.getItem(STORAGE_KEY) as Theme | null;
  if (stored === "light" || stored === "dark") {
    return stored;
  }

  const prefersDark = window.matchMedia?.("(prefers-color-scheme: dark)").matches;
  return prefersDark ? "dark" : "light";
};

const applyTheme = (theme: Theme) => {
  if (typeof document === "undefined") {
    return;
  }

  const root = document.documentElement;
  root.classList.toggle("dark", theme === "dark");
  root.style.setProperty("color-scheme", theme);
};

const useTheme = () => {
  const [theme, setTheme] = useState<Theme>(() => getPreferredTheme());

  useEffect(() => {
    applyTheme(theme);
    if (typeof window !== "undefined") {
      window.localStorage.setItem(STORAGE_KEY, theme);
    }
  }, [theme]);

  useEffect(() => {
    if (typeof window === "undefined") {
      return;
    }

    const mediaQuery = window.matchMedia("(prefers-color-scheme: dark)");
    const listener = (event: MediaQueryListEvent) => {
      setTheme(event.matches ? "dark" : "light");
    };
    mediaQuery.addEventListener("change", listener);
    return () => mediaQuery.removeEventListener("change", listener);
  }, []);

  const toggleTheme = useCallback(() => {
    setTheme((current) => (current === "light" ? "dark" : "light"));
  }, []);

  return { theme, setTheme, toggleTheme };
};

export type { Theme };
export default useTheme;

// FILE: frontend/src/index.css
@import "tailwindcss/base";
@import "tailwindcss/components";
@import "tailwindcss/utilities";
@import "tw-animate-css";

/* Custom theme tokens */
:root {
  color-scheme: light;
  --background: 210 40% 98%;
  --foreground: 222 47% 11%;
  --muted: 217 16% 90%;
  --muted-foreground: 215 16% 40%;
  --card: 0 0% 100%;
  --card-foreground: 222 47% 11%;
  --popover: 0 0% 100%;
  --popover-foreground: 222 47% 11%;
  --border: 214 32% 91%;
  --input: 214 32% 91%;
  --primary: 199 89% 48%;
  --primary-foreground: 198 94% 94%;
  --secondary: 217 16% 90%;
  --secondary-foreground: 222 47% 11%;
  --accent: 199 89% 48%;
  --accent-foreground: 198 94% 94%;
  --destructive: 0 84% 60%;
  --destructive-foreground: 210 40% 98%;
  --sidebar-background: 222 47% 16%;
  --sidebar-foreground: 213 31% 91%;
  --sidebar-muted: 225 19% 70%;
  --sidebar-accent: 199 89% 48%;
  --sidebar-accent-foreground: 222 47% 12%;
  --navbar-background: 210 40% 98%;
  --navbar-foreground: 222 47% 11%;
  --radius-lg: 0.75rem;
  --radius-md: 0.5rem;
  --radius-sm: 0.375rem;
}

.dark {
  color-scheme: dark;
  --background: 222 47% 11%;
  --foreground: 210 40% 98%;
  --muted: 217 16% 24%;
  --muted-foreground: 215 16% 65%;
  --card: 223 47% 16%;
  --card-foreground: 210 40% 98%;
  --popover: 222 47% 14%;
  --popover-foreground: 210 40% 98%;
  --border: 215 27% 26%;
  --input: 215 27% 26%;
  --primary: 199 89% 70%;
  --primary-foreground: 222 47% 12%;
  --secondary: 217 16% 24%;
  --secondary-foreground: 210 40% 98%;
  --accent: 199 89% 70%;
  --accent-foreground: 222 47% 12%;
  --destructive: 0 72% 51%;
  --destructive-foreground: 210 40% 98%;
  --sidebar-background: 222 47% 8%;
  --sidebar-foreground: 210 40% 96%;
  --sidebar-muted: 222 14% 24%;
  --sidebar-accent: 199 89% 70%;
  --sidebar-accent-foreground: 222 47% 12%;
  --navbar-background: 222 47% 10%;
  --navbar-foreground: 210 40% 98%;
}

@layer base {
  * {
    @apply border-border;
  }

  body {
    @apply bg-background text-foreground antialiased;
    font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  }

  .radix-side-drawer[data-state="open"] {
    animation: drawer-in 0.3s ease-out forwards;
  }

  .radix-side-drawer[data-state="closed"] {
    animation: drawer-out 0.2s ease-in forwards;
  }
}

@layer utilities {
  @keyframes drawer-in {
    from {
      transform: translateX(-100%);
      opacity: 0;
    }
    to {
      transform: translateX(0);
      opacity: 1;
    }
  }

  @keyframes drawer-out {
    from {
      transform: translateX(0);
      opacity: 1;
    }
    to {
      transform: translateX(-10%);
      opacity: 0;
    }
  }
}

// FILE: frontend/src/lib/utils.ts
import { type ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

// FILE: frontend/src/main.tsx
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";
import "./index.css";

ReactDOM.createRoot(document.getElementById("root") as HTMLElement).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

// FILE: frontend/src/pages/BeetsPage.tsx
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "../components/ui/card";

const BeetsPage = () => {
  return (
    <div className="space-y-6">
      <header className="flex flex-col gap-1">
        <h1 className="text-2xl font-semibold tracking-tight">Beets</h1>
        <p className="text-sm text-muted-foreground">
          Integration für Beets-Sammlungen. Weitere Funktionen folgen in einem späteren Update.
        </p>
      </header>

      <Card>
        <CardHeader>
          <CardTitle>In Arbeit</CardTitle>
          <CardDescription>Die Beets-Verwaltung wird aktuell vorbereitet.</CardDescription>
        </CardHeader>
        <CardContent>
          <p className="text-sm text-muted-foreground">
            Sobald die API verfügbar ist, erscheinen hier Synchronisationsdetails und Import-Werkzeuge für Beets.
          </p>
        </CardContent>
      </Card>
    </div>
  );
};

export default BeetsPage;

// FILE: frontend/src/pages/DashboardPage.tsx
import { useEffect, useMemo, useState } from "react";
import { AlertTriangle, CheckCircle2, Loader2, Server } from "lucide-react";

import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "../components/ui/card";
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "../components/ui/table";
import { Badge } from "../components/ui/badge";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "../components/ui/tabs";
import dashboardService, {
  type DashboardOverview,
  type HarmonyServiceStatus,
  type JobEntry
} from "../services/dashboard";
import type { ServiceFilters } from "../components/AppHeader";

const statusClasses: Record<HarmonyServiceStatus["status"], string> = {
  connected: "bg-emerald-100 text-emerald-700 dark:bg-emerald-500/10 dark:text-emerald-300",
  disconnected: "bg-rose-100 text-rose-700 dark:bg-rose-500/10 dark:text-rose-300",
  unknown: "bg-amber-100 text-amber-700 dark:bg-amber-500/10 dark:text-amber-300"
};

const statusIcons: Record<HarmonyServiceStatus["status"], JSX.Element> = {
  connected: <CheckCircle2 className="h-4 w-4" />,
  disconnected: <AlertTriangle className="h-4 w-4" />,
  unknown: <AlertTriangle className="h-4 w-4" />
};

interface DashboardPageProps {
  filters: ServiceFilters;
}

const DashboardPage = ({ filters }: DashboardPageProps) => {
  const [overview, setOverview] = useState<DashboardOverview | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    let active = true;

    const load = async () => {
      try {
        setLoading(true);
        setError(null);
        const data = await dashboardService.getOverview();
        if (active) {
          setOverview(data);
        }
      } catch (err) {
        console.error(err);
        if (active) {
          setError("Dashboarddaten konnten nicht geladen werden.");
          setOverview(null);
        }
      } finally {
        if (active) {
          setLoading(false);
        }
      }
    };

    void load();
    return () => {
      active = false;
    };
  }, []);

  const visibleServices = useMemo(() => {
    if (!overview) return [];
    const enabled = Object.entries(filters)
      .filter(([, value]) => value)
      .map(([key]) => key.toLowerCase());
    if (!enabled.length) {
      return overview.services;
    }
    return overview.services.filter((service) => enabled.includes(service.name.toLowerCase()));
  }, [filters, overview]);

  const visibleJobs = useMemo(() => {
    if (!overview) return [];
    const enabled = Object.entries(filters)
      .filter(([, value]) => value)
      .map(([key]) => key.toLowerCase());
    if (!enabled.length) {
      return overview.jobs;
    }
    return overview.jobs.filter((job) => enabled.includes(job.service.toLowerCase()));
  }, [filters, overview]);

  return (
    <div className="space-y-6">
      <header className="flex flex-col gap-1">
        <h1 className="text-2xl font-semibold tracking-tight">Dashboard</h1>
        <p className="text-sm text-muted-foreground">
          Überblick über Systemzustand, verbundene Dienste und laufende Soulseek-Downloads deiner Harmony-Installation.
        </p>
      </header>

      {error && (
        <Card className="border-destructive/40 bg-destructive/5">
          <CardContent className="flex items-center gap-3 py-4 text-sm text-destructive">
            <AlertTriangle className="h-4 w-4" />
            {error}
          </CardContent>
        </Card>
      )}

      <Tabs defaultValue="overview">
        <TabsList>
          <TabsTrigger value="overview">Übersicht</TabsTrigger>
          <TabsTrigger value="jobs">Downloads</TabsTrigger>
        </TabsList>

        <TabsContent value="overview">
          {loading ? (
            <div className="flex items-center justify-center rounded-lg border border-dashed border-border py-16 text-sm text-muted-foreground">
              <Loader2 className="mr-2 h-4 w-4 animate-spin" /> Daten werden geladen …
            </div>
          ) : overview ? (
            <div className="grid gap-6 lg:grid-cols-2 xl:grid-cols-3">
              <Card className="xl:col-span-1">
                <CardHeader className="pb-3">
                  <CardTitle className="flex items-center gap-2 text-base">
                    <Server className="h-4 w-4" /> System Information
                  </CardTitle>
                  <CardDescription>Statusinformationen des Harmony Backends.</CardDescription>
                </CardHeader>
                <CardContent className="space-y-3 text-sm">
                  <div className="flex items-center justify-between">
                    <span className="text-muted-foreground">Backend Version</span>
                    <span className="font-medium">{overview.system.backendVersion}</span>
                  </div>
                  <div className="flex items-center justify-between">
                    <span className="text-muted-foreground">Status</span>
                    <Badge variant="secondary">{overview.system.status}</Badge>
                  </div>
                </CardContent>
              </Card>

              <Card className="xl:col-span-2">
                <CardHeader className="pb-3">
                  <CardTitle className="flex items-center gap-2 text-base">
                    <CheckCircle2 className="h-4 w-4" /> Services
                  </CardTitle>
                  <CardDescription>Verbindungsstatus aller integrierten Musikdienste.</CardDescription>
                </CardHeader>
                <CardContent>
                  <div className="grid gap-3 md:grid-cols-2 xl:grid-cols-3">
                    {visibleServices.length ? (
                      visibleServices.map((service) => (
                        <div
                          key={service.name}
                          className="flex items-center justify-between rounded-lg border border-border/60 bg-card px-4 py-3"
                        >
                          <div>
                            <p className="font-medium leading-none">{service.name}</p>
                            {service.meta?.detail ? (
                              <p className="mt-1 text-xs text-muted-foreground">
                                {String(service.meta.detail)}
                              </p>
                            ) : null}
                          </div>
                          <Badge className={`flex items-center gap-1 ${statusClasses[service.status]}`}>
                            {statusIcons[service.status]}
                            <span className="capitalize">{service.status}</span>
                          </Badge>
                        </div>
                      ))
                    ) : (
                      <p className="col-span-full rounded-md border border-dashed border-border py-6 text-center text-sm text-muted-foreground">
                        Keine Dienste für die aktuelle Filterauswahl sichtbar.
                      </p>
                    )}
                  </div>
                </CardContent>
              </Card>
            </div>
          ) : (
            <div className="rounded-lg border border-dashed border-border py-16 text-center text-sm text-muted-foreground">
              Keine Daten verfügbar.
            </div>
          )}
        </TabsContent>

        <TabsContent value="jobs">
          {loading ? (
            <div className="flex items-center justify-center rounded-lg border border-dashed border-border py-16 text-sm text-muted-foreground">
              <Loader2 className="mr-2 h-4 w-4 animate-spin" /> Daten werden geladen …
            </div>
          ) : visibleJobs.length ? (
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead>Download</TableHead>
                  <TableHead>Service</TableHead>
                  <TableHead>Status</TableHead>
                  <TableHead>Fortschritt</TableHead>
                  <TableHead>Aktualisiert</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {visibleJobs.map((job: JobEntry) => (
                  <TableRow key={job.id}>
                    <TableCell className="max-w-[16rem] truncate" title={job.name}>
                      {job.name}
                    </TableCell>
                    <TableCell>{job.service}</TableCell>
                    <TableCell>{job.status}</TableCell>
                    <TableCell>{Math.round(job.progress)}%</TableCell>
                    <TableCell>{new Date(job.updatedAt).toLocaleString()}</TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          ) : (
            <div className="rounded-lg border border-dashed border-border py-16 text-center text-sm text-muted-foreground">
              Keine aktiven Downloads vorhanden.
            </div>
          )}
        </TabsContent>
      </Tabs>
    </div>
  );
};

export default DashboardPage;
// FILE: frontend/src/pages/Matching.tsx
import { FormEvent, useState } from "react";
import { Loader2 } from "lucide-react";

import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "../components/ui/card";
import { Button } from "../components/ui/button";
import { Label } from "../components/ui/label";
import { Textarea } from "../components/ui/textarea";
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "../components/ui/table";
import { useToast } from "../components/ui/use-toast";
import matchingService, { MatchingResponse } from "../services/matching";

const emptyResponse: MatchingResponse = { bestMatch: null, confidence: 0 };

const parseJson = (value: string) => {
  try {
    return value ? JSON.parse(value) : null;
  } catch (error) {
    throw new Error("Ungültiges JSON");
  }
};

const defaultSpotifyTrack = JSON.stringify(
  {
    id: "spotify:track:example",
    name: "Example Track",
    artists: [{ name: "Example Artist" }],
    album: { name: "Example Album" }
  },
  null,
  2
);

const defaultCandidates = JSON.stringify(
  [
    { id: "candidate-1", title: "Example Candidate", artist: "Example Artist" }
  ],
  null,
  2
);

const Matching = () => {
  const { toast } = useToast();
  const [spotifyTrack, setSpotifyTrack] = useState(defaultSpotifyTrack);
  const [plexCandidates, setPlexCandidates] = useState(defaultCandidates);
  const [soulseekCandidates, setSoulseekCandidates] = useState(defaultCandidates);
  const [plexResult, setPlexResult] = useState<MatchingResponse>(emptyResponse);
  const [soulseekResult, setSoulseekResult] = useState<MatchingResponse>(emptyResponse);
  const [loading, setLoading] = useState<"plex" | "soulseek" | null>(null);

  const runMatching = async (type: "plex" | "soulseek") => {
    try {
      setLoading(type);
      const track = parseJson(spotifyTrack);
      const candidates = parseJson(type === "plex" ? plexCandidates : soulseekCandidates);
      if (!track || !Array.isArray(candidates)) {
        throw new Error("Track oder Kandidaten fehlen");
      }
      const payload = { spotify_track: track, candidates };
      if (type === "plex") {
        const result = await matchingService.matchSpotifyToPlex(payload);
        setPlexResult(result);
        toast({ title: "Matching abgeschlossen", description: "Spotify ↔ Plex Ergebnis aktualisiert." });
      } else {
        const result = await matchingService.matchSpotifyToSoulseek(payload);
        setSoulseekResult(result);
        toast({ title: "Matching abgeschlossen", description: "Spotify ↔ Soulseek Ergebnis aktualisiert." });
      }
    } catch (error) {
      console.error(error);
      toast({ title: "Matching fehlgeschlagen", description: String(error), variant: "destructive" });
    } finally {
      setLoading(null);
    }
  };

  const handleSubmit = (type: "plex" | "soulseek") => (event: FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    void runMatching(type);
  };

  return (
    <div className="space-y-6">
      <div className="flex flex-col gap-1">
        <h1 className="text-2xl font-semibold">Matching</h1>
        <p className="text-sm text-muted-foreground">
          Vergleiche Spotify-Tracks mit Plex- oder Soulseek-Kandidaten. Füge JSON-Payloads ein, um die API direkt zu testen.
        </p>
      </div>

      <div className="grid gap-6 lg:grid-cols-2">
        <Card>
          <CardHeader>
            <CardTitle>Spotify → Plex</CardTitle>
            <CardDescription>Berechne den besten Plex-Match für einen Spotify-Track.</CardDescription>
          </CardHeader>
          <CardContent>
            <form className="space-y-4" onSubmit={handleSubmit("plex")}>
              <div className="space-y-2">
                <Label htmlFor="spotifyTrackPlex">Spotify Track (JSON)</Label>
                <Textarea
                  id="spotifyTrackPlex"
                  value={spotifyTrack}
                  onChange={(event) => setSpotifyTrack(event.target.value)}
                  rows={6}
                />
              </div>
              <div className="space-y-2">
                <Label htmlFor="plexCandidates">Plex Kandidaten (JSON Array)</Label>
                <Textarea
                  id="plexCandidates"
                  value={plexCandidates}
                  onChange={(event) => setPlexCandidates(event.target.value)}
                  rows={6}
                />
              </div>
              <Button type="submit" disabled={loading !== null}>
                {loading === "plex" ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : null}
                Matching starten
              </Button>
            </form>
            <div className="mt-6 space-y-2">
              <h3 className="text-sm font-semibold">Ergebnis</h3>
              <pre className="max-h-48 overflow-auto rounded-md border border-border bg-muted/40 p-3 text-xs">
                {JSON.stringify(plexResult.bestMatch, null, 2) || "—"}
              </pre>
              <p className="text-sm text-muted-foreground">Confidence: {plexResult.confidence.toFixed(2)}</p>
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>Spotify → Soulseek</CardTitle>
            <CardDescription>Bewerte Soulseek-Kandidaten auf Basis der Harmony-Engine.</CardDescription>
          </CardHeader>
          <CardContent>
            <form className="space-y-4" onSubmit={handleSubmit("soulseek")}>
              <div className="space-y-2">
                <Label htmlFor="spotifyTrackSoulseek">Spotify Track (JSON)</Label>
                <Textarea
                  id="spotifyTrackSoulseek"
                  value={spotifyTrack}
                  onChange={(event) => setSpotifyTrack(event.target.value)}
                  rows={6}
                />
              </div>
              <div className="space-y-2">
                <Label htmlFor="soulseekCandidates">Soulseek Kandidaten (JSON Array)</Label>
                <Textarea
                  id="soulseekCandidates"
                  value={soulseekCandidates}
                  onChange={(event) => setSoulseekCandidates(event.target.value)}
                  rows={6}
                />
              </div>
              <Button type="submit" disabled={loading !== null}>
                {loading === "soulseek" ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : null}
                Matching starten
              </Button>
            </form>
            <div className="mt-6 space-y-2">
              <h3 className="text-sm font-semibold">Ergebnis</h3>
              <pre className="max-h-48 overflow-auto rounded-md border border-border bg-muted/40 p-3 text-xs">
                {JSON.stringify(soulseekResult.bestMatch, null, 2) || "—"}
              </pre>
              <p className="text-sm text-muted-foreground">Confidence: {soulseekResult.confidence.toFixed(2)}</p>
            </div>
          </CardContent>
        </Card>
      </div>

      <Card>
        <CardHeader>
          <CardTitle>Zusammenfassung</CardTitle>
          <CardDescription>Vergleiche die letzten Ergebnisse der Matching-Aufrufe.</CardDescription>
        </CardHeader>
        <CardContent>
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead>Job</TableHead>
                <TableHead>Confidence</TableHead>
                <TableHead>Treffer</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              <TableRow>
                <TableCell>Spotify → Plex</TableCell>
                <TableCell>{plexResult.confidence.toFixed(2)}</TableCell>
                <TableCell>{plexResult.bestMatch ? "✅" : "—"}</TableCell>
              </TableRow>
              <TableRow>
                <TableCell>Spotify → Soulseek</TableCell>
                <TableCell>{soulseekResult.confidence.toFixed(2)}</TableCell>
                <TableCell>{soulseekResult.bestMatch ? "✅" : "—"}</TableCell>
              </TableRow>
            </TableBody>
          </Table>
        </CardContent>
      </Card>
    </div>
  );
};

export default Matching;
// FILE: frontend/src/pages/PlexPage.tsx
import { useCallback, useEffect, useMemo, useState } from "react";
import { Library, ListMusic, Loader2, Server, Settings2 } from "lucide-react";

import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "../components/ui/card";
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "../components/ui/table";
import { Button } from "../components/ui/button";
import { Input } from "../components/ui/input";
import { Label } from "../components/ui/label";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "../components/ui/tabs";
import { useToast } from "../components/ui/use-toast";
import { useGlobalSearch } from "../hooks/useGlobalSearch";
import plexService, {
  PlexLibraryItem,
  PlexLibrarySection,
  PlexSession,
  PlexStatus
} from "../services/plex";
import settingsService, { defaultSettings, type SettingsPayload } from "../services/settings";
import type { ServiceFilters } from "../components/AppHeader";

interface PlexPageProps {
  filters: ServiceFilters;
}

const PlexPage = ({ filters }: PlexPageProps) => {
  const { toast } = useToast();
  const { term } = useGlobalSearch();
  const [status, setStatus] = useState<PlexStatus | null>(null);
  const [sections, setSections] = useState<PlexLibrarySection[]>([]);
  const [sessions, setSessions] = useState<PlexSession[]>([]);
  const [selectedSection, setSelectedSection] = useState<string | null>(null);
  const [sectionItems, setSectionItems] = useState<PlexLibraryItem[]>([]);
  const [loadingOverview, setLoadingOverview] = useState(true);
  const [loadingSection, setLoadingSection] = useState(false);
  const [settings, setSettings] = useState<SettingsPayload>(defaultSettings);
  const [settingsLoading, setSettingsLoading] = useState(true);
  const [settingsSaving, setSettingsSaving] = useState(false);
  const [settingsError, setSettingsError] = useState<string | null>(null);

  const loadOverview = useCallback(async () => {
    if (!filters.plex) return;
    try {
      setLoadingOverview(true);
      const [loadedStatus, loadedSections, loadedSessions] = await Promise.all([
        plexService.getStatus(),
        plexService.getSections(),
        plexService.getSessions()
      ]);
      setStatus(loadedStatus);
      setSections(loadedSections);
      setSessions(loadedSessions);
      if (!selectedSection && loadedSections.length) {
        setSelectedSection(loadedSections[0].id);
      }
    } catch (error) {
      console.error(error);
      toast({
        title: "Plex konnte nicht geladen werden",
        description: "Status und Bibliotheksübersicht stehen aktuell nicht zur Verfügung.",
        variant: "destructive"
      });
    } finally {
      setLoadingOverview(false);
    }
  }, [filters.plex, selectedSection, toast]);

  useEffect(() => {
    void loadOverview();
  }, [loadOverview]);

  useEffect(() => {
    let active = true;
    const fetchSettings = async () => {
      try {
        setSettingsLoading(true);
        const loaded = await settingsService.getSettings();
        if (active) {
          setSettings(loaded);
        }
      } catch (error) {
        console.error(error);
        if (active) {
          setSettingsError("Einstellungen konnten nicht geladen werden.");
        }
      } finally {
        if (active) {
          setSettingsLoading(false);
        }
      }
    };

    void fetchSettings();
    return () => {
      active = false;
    };
  }, []);

  useEffect(() => {
    if (!selectedSection) return;
    let active = true;

    const loadSection = async () => {
      try {
        setLoadingSection(true);
        const items = await plexService.getSectionItems(selectedSection);
        if (active) {
          setSectionItems(items);
        }
      } catch (error) {
        console.error(error);
        if (active) {
          toast({
            title: "Sektion konnte nicht geladen werden",
            description: "Bitte versuche es erneut.",
            variant: "destructive"
          });
        }
      } finally {
        if (active) {
          setLoadingSection(false);
        }
      }
    };

    void loadSection();
    return () => {
      active = false;
    };
  }, [selectedSection, toast]);

  const filteredItems = useMemo(() => {
    if (!term) return sectionItems;
    const lower = term.toLowerCase();
    return sectionItems.filter((item) =>
      [item.title, item.parent, item.type, item.year?.toString()].some((value) =>
        value?.toLowerCase().includes(lower)
      )
    );
  }, [sectionItems, term]);

  const filteredSessions = useMemo(() => {
    if (!term) return sessions;
    const lower = term.toLowerCase();
    return sessions.filter((session) =>
      [session.title, session.user, session.state].some((value) =>
        value?.toLowerCase().includes(lower)
      )
    );
  }, [sessions, term]);

  const handleSettingsChange = (key: keyof SettingsPayload, value: string) => {
    setSettings((prev) => ({ ...prev, [key]: value }));
  };

  const handleSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    try {
      setSettingsSaving(true);
      setSettingsError(null);
      await settingsService.saveSettings(settings);
      toast({ title: "Einstellungen gespeichert", description: "Plex-Konfiguration aktualisiert." });
    } catch (error) {
      console.error(error);
      setSettingsError("Fehler beim Speichern der Einstellungen.");
      toast({
        title: "Speichern fehlgeschlagen",
        description: "Bitte versuche es erneut.",
        variant: "destructive"
      });
    } finally {
      setSettingsSaving(false);
    }
  };

  if (!filters.plex) {
    return (
      <Card>
        <CardHeader>
          <CardTitle>Plex ausgeblendet</CardTitle>
          <CardDescription>Aktiviere den Plex-Filter im Header, um Inhalte zu sehen.</CardDescription>
        </CardHeader>
      </Card>
    );
  }

  return (
    <div className="space-y-6">
      <header className="flex flex-col gap-1">
        <h1 className="text-2xl font-semibold tracking-tight">Plex</h1>
        <p className="text-sm text-muted-foreground">
          Überblick über aktive Sitzungen und Bibliothekssektionen deines Plex-Servers.
        </p>
      </header>

      <Tabs defaultValue="overview">
        <TabsList>
          <TabsTrigger value="overview">Status & Bibliothek</TabsTrigger>
          <TabsTrigger value="settings">Einstellungen</TabsTrigger>
        </TabsList>

        <TabsContent value="overview" className="space-y-6">
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2 text-base">
                <Server className="h-4 w-4" /> Serverstatus
              </CardTitle>
              <CardDescription>
                {status?.status === "connected" ? "Verbunden" : "Nicht verbunden"}
              </CardDescription>
            </CardHeader>
            <CardContent className="grid gap-4 sm:grid-cols-3">
              <div className="rounded-lg border border-border/60 bg-card p-4">
                <p className="text-xs uppercase text-muted-foreground">Sitzungen</p>
                <p className="mt-1 text-sm font-medium">{sessions.length}</p>
              </div>
              <div className="rounded-lg border border-border/60 bg-card p-4">
                <p className="text-xs uppercase text-muted-foreground">Sektionen</p>
                <p className="mt-1 text-sm font-medium">{sections.length}</p>
              </div>
              <div className="rounded-lg border border-border/60 bg-card p-4">
                <p className="text-xs uppercase text-muted-foreground">Bibliothek</p>
                <p className="mt-1 text-sm font-medium">
                  {status?.library?.MediaContainer?.librarySections?.length ?? "–"}
                </p>
              </div>
            </CardContent>
          </Card>

          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2 text-base">
                <Library className="h-4 w-4" /> Bibliothekssektionen
              </CardTitle>
              <CardDescription>Wähle eine Sektion aus, um Einträge anzuzeigen.</CardDescription>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="flex flex-wrap gap-2">
                {sections.map((section) => (
                  <Button
                    key={section.id}
                    variant={selectedSection === section.id ? "default" : "outline"}
                    size="sm"
                    onClick={() => setSelectedSection(section.id)}
                  >
                    {section.title}
                  </Button>
                ))}
              </div>

              <div className="rounded-lg border border-border/60">
                {loadingSection ? (
                  <div className="flex items-center justify-center py-12 text-sm text-muted-foreground">
                    <Loader2 className="mr-2 h-4 w-4 animate-spin" /> Sektion wird geladen …
                  </div>
                ) : (
                  <Table>
                    <TableHeader>
                      <TableRow>
                        <TableHead>Titel</TableHead>
                        <TableHead>Übergeordnet</TableHead>
                        <TableHead>Typ</TableHead>
                        <TableHead>Jahr</TableHead>
                      </TableRow>
                    </TableHeader>
                    <TableBody>
                      {filteredItems.map((item) => (
                        <TableRow key={item.id}>
                          <TableCell>{item.title}</TableCell>
                          <TableCell>{item.parent ?? "—"}</TableCell>
                          <TableCell>{item.type ?? "—"}</TableCell>
                          <TableCell>{item.year ?? "—"}</TableCell>
                        </TableRow>
                      ))}
                      {!filteredItems.length && (
                        <TableRow>
                          <TableCell colSpan={4} className="text-center text-sm text-muted-foreground">
                            Keine Einträge gefunden.
                          </TableCell>
                        </TableRow>
                      )}
                    </TableBody>
                  </Table>
                )}
              </div>
            </CardContent>
          </Card>

          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2 text-base">
                <ListMusic className="h-4 w-4" /> Aktive Sitzungen
              </CardTitle>
              <CardDescription>Playback-Informationen für aktuelle Nutzer.</CardDescription>
            </CardHeader>
            <CardContent>
              <div className="rounded-lg border border-border/60">
                {loadingOverview ? (
                  <div className="flex items-center justify-center py-12 text-sm text-muted-foreground">
                    <Loader2 className="mr-2 h-4 w-4 animate-spin" /> Sitzungen werden geladen …
                  </div>
                ) : (
                  <Table>
                    <TableHeader>
                      <TableRow>
                        <TableHead>Benutzer</TableHead>
                        <TableHead>Titel</TableHead>
                        <TableHead>Status</TableHead>
                      </TableRow>
                    </TableHeader>
                    <TableBody>
                      {filteredSessions.map((session) => (
                        <TableRow key={session.id}>
                          <TableCell>{session.user ?? "—"}</TableCell>
                          <TableCell>{session.title}</TableCell>
                          <TableCell>{session.state ?? "–"}</TableCell>
                        </TableRow>
                      ))}
                      {!filteredSessions.length && (
                        <TableRow>
                          <TableCell colSpan={3} className="text-center text-sm text-muted-foreground">
                            Keine aktiven Sitzungen.
                          </TableCell>
                        </TableRow>
                      )}
                    </TableBody>
                  </Table>
                )}
              </div>
            </CardContent>
          </Card>
        </TabsContent>

        <TabsContent value="settings" className="space-y-6">
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2 text-base">
                <Settings2 className="h-4 w-4" /> Plex Einstellungen
              </CardTitle>
              <CardDescription>
                Verwalte URL, Token und Standardbibliothek für die Plex-Integration.
              </CardDescription>
            </CardHeader>
            <CardContent>
              <form className="space-y-6" onSubmit={handleSubmit}>
                <fieldset className="space-y-4" disabled={settingsLoading}>
                  <div className="grid gap-4 md:grid-cols-2">
                    <div className="space-y-2">
                      <Label htmlFor="plexBaseUrl">Plex Base URL</Label>
                      <Input
                        id="plexBaseUrl"
                        value={settings.plexBaseUrl}
                        onChange={(event) => handleSettingsChange("plexBaseUrl", event.target.value)}
                        placeholder="http://localhost:32400"
                        required
                      />
                    </div>
                    <div className="space-y-2">
                      <Label htmlFor="plexToken">Plex Token</Label>
                      <Input
                        id="plexToken"
                        value={settings.plexToken}
                        onChange={(event) => handleSettingsChange("plexToken", event.target.value)}
                        required
                      />
                    </div>
                    <div className="space-y-2">
                      <Label htmlFor="plexLibrary">Standardbibliothek</Label>
                      <Input
                        id="plexLibrary"
                        value={settings.plexLibrary}
                        onChange={(event) => handleSettingsChange("plexLibrary", event.target.value)}
                        placeholder="Music"
                        required
                      />
                    </div>
                  </div>
                </fieldset>

                {settingsError ? (
                  <p className="text-sm text-destructive">{settingsError}</p>
                ) : null}

                <div className="flex items-center justify-end">
                  <Button type="submit" disabled={settingsSaving || settingsLoading}>
                    {settingsSaving ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : null}
                    Speichern
                  </Button>
                </div>
              </form>
            </CardContent>
          </Card>
        </TabsContent>
      </Tabs>
    </div>
  );
};

export default PlexPage;
// FILE: frontend/src/pages/Settings.tsx
import { ChangeEvent, FormEvent, useEffect, useState } from "react";
import { Loader2 } from "lucide-react";

import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "../components/ui/card";
import { Button } from "../components/ui/button";
import { Input } from "../components/ui/input";
import { Label } from "../components/ui/label";
import { useToast } from "../components/ui/use-toast";
import settingsService, { SettingsPayload } from "../services/settings";

const initialState: SettingsPayload = {
  spotifyClientId: "",
  spotifyClientSecret: "",
  spotifyRedirectUri: "",
  plexBaseUrl: "",
  plexToken: "",
  plexLibrary: "",
  soulseekApiUrl: "",
  soulseekApiKey: ""
};

const Settings = () => {
  const { toast } = useToast();
  const [formState, setFormState] = useState<SettingsPayload>(initialState);
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);

  useEffect(() => {
    const fetchSettings = async () => {
      try {
        const data = await settingsService.getSettings();
        setFormState((current) => ({ ...current, ...data }));
      } catch (error) {
        console.error(error);
        toast({
          title: "Einstellungen konnten nicht geladen werden",
          variant: "destructive"
        });
      } finally {
        setLoading(false);
      }
    };

    void fetchSettings();
  }, [toast]);

  const handleChange = (field: keyof SettingsPayload) => (event: ChangeEvent<HTMLInputElement>) => {
    setFormState((current) => ({ ...current, [field]: event.target.value }));
  };

  const handleSubmit = async (event: FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    try {
      setSaving(true);
      await settingsService.saveSettings(formState);
      toast({ title: "Einstellungen gespeichert" });
    } catch (error) {
      console.error(error);
      toast({
        title: "Speichern fehlgeschlagen",
        variant: "destructive"
      });
    } finally {
      setSaving(false);
    }
  };

  return (
    <div className="space-y-6">
      <div className="flex flex-col gap-1">
        <h1 className="text-2xl font-semibold">Einstellungen</h1>
        <p className="text-sm text-muted-foreground">
          Verwalte API-Zugänge und Konfigurationswerte für alle Dienste.
        </p>
      </div>

      <Card>
        <CardHeader>
          <CardTitle>Verbindungen</CardTitle>
          <CardDescription>Trage die Zugangsdaten für Spotify, Plex und Soulseek ein.</CardDescription>
        </CardHeader>
        <CardContent>
          <form className="space-y-6" onSubmit={handleSubmit}>
            <fieldset className="space-y-4" disabled={loading}>
              <div className="grid gap-4 md:grid-cols-2">
                <div className="space-y-2">
                  <Label htmlFor="spotifyClientId">Spotify Client ID</Label>
                  <Input
                    id="spotifyClientId"
                    value={formState.spotifyClientId}
                    onChange={handleChange("spotifyClientId")}
                    required
                  />
                </div>
                <div className="space-y-2">
                  <Label htmlFor="spotifyClientSecret">Spotify Client Secret</Label>
                  <Input
                    id="spotifyClientSecret"
                    type="password"
                    value={formState.spotifyClientSecret}
                    onChange={handleChange("spotifyClientSecret")}
                    required
                  />
                </div>
                <div className="space-y-2">
                  <Label htmlFor="spotifyRedirectUri">Spotify Redirect URI</Label>
                  <Input
                    id="spotifyRedirectUri"
                    value={formState.spotifyRedirectUri}
                    onChange={handleChange("spotifyRedirectUri")}
                    placeholder="https://example.com/callback"
                    required
                  />
                </div>
                <div className="space-y-2">
                  <Label htmlFor="plexBaseUrl">Plex Base URL</Label>
                  <Input
                    id="plexBaseUrl"
                    value={formState.plexBaseUrl}
                    onChange={handleChange("plexBaseUrl")}
                    placeholder="http://localhost:32400"
                    required
                  />
                </div>
                <div className="space-y-2">
                  <Label htmlFor="plexToken">Plex Token</Label>
                  <Input
                    id="plexToken"
                    value={formState.plexToken}
                    onChange={handleChange("plexToken")}
                    required
                  />
                </div>
                <div className="space-y-2">
                  <Label htmlFor="plexLibrary">Plex Library</Label>
                  <Input
                    id="plexLibrary"
                    value={formState.plexLibrary}
                    onChange={handleChange("plexLibrary")}
                    placeholder="Music"
                    required
                  />
                </div>
                <div className="space-y-2">
                  <Label htmlFor="soulseekApiUrl">Soulseek API URL</Label>
                  <Input
                    id="soulseekApiUrl"
                    value={formState.soulseekApiUrl}
                    onChange={handleChange("soulseekApiUrl")}
                    placeholder="http://localhost:5030"
                    required
                  />
                </div>
                <div className="space-y-2">
                  <Label htmlFor="soulseekApiKey">Soulseek API Key</Label>
                  <Input
                    id="soulseekApiKey"
                    value={formState.soulseekApiKey}
                    onChange={handleChange("soulseekApiKey")}
                    required
                  />
                </div>
              </div>
            </fieldset>

            <div className="flex items-center justify-end">
              <Button type="submit" disabled={saving || loading}>
                {saving ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : null}
                Speichern
              </Button>
            </div>
          </form>
        </CardContent>
      </Card>
    </div>
  );
};

export default Settings;

// FILE: frontend/src/pages/SoulseekPage.tsx
import { useCallback, useEffect, useMemo, useState } from "react";
import { Download, Loader2, Search as SearchIcon, Settings2 } from "lucide-react";

import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "../components/ui/card";
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "../components/ui/table";
import { Badge } from "../components/ui/badge";
import { Button } from "../components/ui/button";
import { Input } from "../components/ui/input";
import { Label } from "../components/ui/label";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "../components/ui/tabs";
import { useToast } from "../components/ui/use-toast";
import useDebouncedValue from "../hooks/useDebouncedValue";
import { useGlobalSearch } from "../hooks/useGlobalSearch";
import soulseekService, { SoulseekDownload, SoulseekSearchResult } from "../services/soulseek";
import settingsService, { defaultSettings, type SettingsPayload } from "../services/settings";
import type { ServiceFilters } from "../components/AppHeader";

interface SoulseekPageProps {
  filters: ServiceFilters;
}

const SoulseekPage = ({ filters }: SoulseekPageProps) => {
  const { toast } = useToast();
  const { term } = useGlobalSearch();
  const debouncedSearch = useDebouncedValue(term, 400);
  const [downloads, setDownloads] = useState<SoulseekDownload[]>([]);
  const [searchResults, setSearchResults] = useState<SoulseekSearchResult[]>([]);
  const [loadingDownloads, setLoadingDownloads] = useState(true);
  const [searchLoading, setSearchLoading] = useState(false);
  const [settings, setSettings] = useState<SettingsPayload>(defaultSettings);
  const [settingsLoading, setSettingsLoading] = useState(true);
  const [settingsSaving, setSettingsSaving] = useState(false);
  const [settingsError, setSettingsError] = useState<string | null>(null);

  const loadDownloads = useCallback(async () => {
    if (!filters.soulseek) return;
    try {
      setLoadingDownloads(true);
      const data = await soulseekService.getDownloads();
      setDownloads(data);
    } catch (error) {
      console.error(error);
      toast({
        title: "Downloads konnten nicht geladen werden",
        description: "Soulseek-Status steht aktuell nicht zur Verfügung.",
        variant: "destructive"
      });
    } finally {
      setLoadingDownloads(false);
    }
  }, [filters.soulseek, toast]);

  useEffect(() => {
    void loadDownloads();
  }, [loadDownloads]);

  useEffect(() => {
    let active = true;

    const runSearch = async () => {
      if (!filters.soulseek || !debouncedSearch) {
        setSearchResults([]);
        return;
      }
      try {
        setSearchLoading(true);
        const results = await soulseekService.search(debouncedSearch);
        if (active) {
          setSearchResults(results);
          if (results.length) {
            toast({
              title: "Soulseek-Suche",
              description: `${results.length} Ergebnisse gefunden.`,
              duration: 2500
            });
          }
        }
      } catch (error) {
        console.error(error);
        if (active) {
          toast({
            title: "Suche fehlgeschlagen",
            description: "Bitte versuche es erneut.",
            variant: "destructive"
          });
        }
      } finally {
        if (active) {
          setSearchLoading(false);
        }
      }
    };

    void runSearch();
    return () => {
      active = false;
    };
  }, [debouncedSearch, filters.soulseek, toast]);

  useEffect(() => {
    let mounted = true;
    const loadSettings = async () => {
      try {
        setSettingsLoading(true);
        const loaded = await settingsService.getSettings();
        if (mounted) {
          setSettings(loaded);
        }
      } catch (error) {
        console.error(error);
        if (mounted) {
          setSettingsError("Einstellungen konnten nicht geladen werden.");
        }
      } finally {
        if (mounted) {
          setSettingsLoading(false);
        }
      }
    };

    void loadSettings();
    return () => {
      mounted = false;
    };
  }, []);

  const filteredDownloads = useMemo(() => {
    if (!term) return downloads;
    return downloads.filter((download) => download.filename.toLowerCase().includes(term.toLowerCase()));
  }, [downloads, term]);

  const handleSettingsChange = (key: keyof SettingsPayload, value: string) => {
    setSettings((prev) => ({ ...prev, [key]: value }));
  };

  const handleSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    try {
      setSettingsSaving(true);
      setSettingsError(null);
      await settingsService.saveSettings(settings);
      toast({ title: "Einstellungen gespeichert", description: "Soulseek-Konfiguration aktualisiert." });
    } catch (error) {
      console.error(error);
      setSettingsError("Fehler beim Speichern der Einstellungen.");
      toast({
        title: "Speichern fehlgeschlagen",
        description: "Bitte versuche es erneut.",
        variant: "destructive"
      });
    } finally {
      setSettingsSaving(false);
    }
  };

  const handleCancelDownload = async (downloadId: string) => {
    try {
      await soulseekService.cancelDownload(downloadId);
      toast({ title: "Download abgebrochen", description: "Der Download wurde gestoppt." });
      void loadDownloads();
    } catch (error) {
      console.error(error);
      toast({
        title: "Abbruch fehlgeschlagen",
        description: "Der Download konnte nicht gestoppt werden.",
        variant: "destructive"
      });
    }
  };

  if (!filters.soulseek) {
    return (
      <Card>
        <CardHeader>
          <CardTitle>Soulseek ausgeblendet</CardTitle>
          <CardDescription>Aktiviere den Soulseek-Filter im Header, um Inhalte zu sehen.</CardDescription>
        </CardHeader>
      </Card>
    );
  }

  return (
    <div className="space-y-6">
      <header className="flex flex-col gap-1">
        <h1 className="text-2xl font-semibold tracking-tight">Soulseek</h1>
        <p className="text-sm text-muted-foreground">
          Überwache aktive Downloads, starte neue Suchen und verwalte deine Soulseek-Integration.
        </p>
      </header>

      <Tabs defaultValue="overview">
        <TabsList>
          <TabsTrigger value="overview">Downloads & Suche</TabsTrigger>
          <TabsTrigger value="settings">Einstellungen</TabsTrigger>
        </TabsList>

        <TabsContent value="overview" className="space-y-6">
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2 text-base">
                <Download className="h-4 w-4" /> Aktuelle Downloads
              </CardTitle>
              <CardDescription>Gefiltert nach „{term || "—"}“.</CardDescription>
            </CardHeader>
            <CardContent>
              {loadingDownloads ? (
                <div className="flex items-center justify-center py-12 text-sm text-muted-foreground">
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" /> Downloads werden geladen …
                </div>
              ) : filteredDownloads.length ? (
                <div className="overflow-x-auto">
                  <Table>
                    <TableHeader>
                      <TableRow>
                        <TableHead>Datei</TableHead>
                        <TableHead>Status</TableHead>
                        <TableHead className="w-[160px]">Fortschritt</TableHead>
                        <TableHead>Geschwindigkeit</TableHead>
                        <TableHead className="text-right">Aktion</TableHead>
                      </TableRow>
                    </TableHeader>
                    <TableBody>
                      {filteredDownloads.map((download) => (
                        <TableRow key={download.id}>
                          <TableCell className="font-medium">{download.filename}</TableCell>
                          <TableCell>
                            <Badge variant="outline" className="capitalize">
                              {download.status}
                            </Badge>
                          </TableCell>
                          <TableCell>
                            <div className="flex items-center gap-2">
                              <div className="h-2 flex-1 overflow-hidden rounded-full bg-muted">
                                <div
                                  className="h-full rounded-full bg-primary transition-all"
                                  style={{ width: `${Math.min(100, Math.max(0, download.progress))}%` }}
                                />
                              </div>
                              <span className="w-10 text-xs text-muted-foreground">{Math.round(download.progress)}%</span>
                            </div>
                          </TableCell>
                          <TableCell className="text-sm text-muted-foreground">
                            {download.speed ? `${download.speed} kb/s` : "–"}
                          </TableCell>
                          <TableCell className="text-right">
                            {download.status === "downloading" || download.status === "queued" ? (
                              <Button
                                variant="ghost"
                                size="sm"
                                onClick={() => void handleCancelDownload(download.id)}
                              >
                                Abbrechen
                              </Button>
                            ) : (
                              <span className="text-xs text-muted-foreground">–</span>
                            )}
                          </TableCell>
                        </TableRow>
                      ))}
                    </TableBody>
                  </Table>
                </div>
              ) : (
                <p className="rounded-md border border-dashed border-border py-6 text-center text-sm text-muted-foreground">
                  Keine Downloads gefunden.
                </p>
              )}
            </CardContent>
          </Card>

          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2 text-base">
                <SearchIcon className="h-4 w-4" /> Suchergebnisse
              </CardTitle>
              <CardDescription>Ergebnisse der globalen Suche in Soulseek.</CardDescription>
            </CardHeader>
            <CardContent>
              {searchLoading ? (
                <div className="flex items-center justify-center py-12 text-sm text-muted-foreground">
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" /> Suche läuft …
                </div>
              ) : searchResults.length ? (
                <div className="overflow-x-auto">
                  <Table>
                    <TableHeader>
                      <TableRow>
                        <TableHead>Datei</TableHead>
                        <TableHead>Benutzer</TableHead>
                        <TableHead className="text-right">Größe</TableHead>
                      </TableRow>
                    </TableHeader>
                    <TableBody>
                      {searchResults.slice(0, 25).map((result) => (
                        <TableRow key={result.id}>
                          <TableCell className="font-medium">{result.filename}</TableCell>
                          <TableCell>{result.user}</TableCell>
                          <TableCell className="text-right text-sm text-muted-foreground">
                            {Math.round(result.size / (1024 * 1024))} MB
                          </TableCell>
                        </TableRow>
                      ))}
                    </TableBody>
                  </Table>
                </div>
              ) : (
                <p className="rounded-md border border-dashed border-border py-6 text-center text-sm text-muted-foreground">
                  Keine Suchergebnisse vorhanden.
                </p>
              )}
            </CardContent>
          </Card>
        </TabsContent>

        <TabsContent value="settings">
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2 text-base">
                <Settings2 className="h-4 w-4" /> Soulseek Einstellungen
              </CardTitle>
              <CardDescription>API-Endpunkt und Schlüssel für deinen Soulseek-Dienst.</CardDescription>
            </CardHeader>
            <CardContent>
              {settingsLoading ? (
                <div className="flex items-center justify-center py-12 text-sm text-muted-foreground">
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" /> Einstellungen werden geladen …
                </div>
              ) : (
                <form onSubmit={handleSubmit} className="space-y-6">
                  <div className="space-y-2">
                    <Label htmlFor="soulseek-url">SLSKD URL</Label>
                    <Input
                      id="soulseek-url"
                      value={settings.soulseekApiUrl}
                      onChange={(event) => handleSettingsChange("soulseekApiUrl", event.target.value)}
                      placeholder="https://slsd.example.com"
                      required
                    />
                  </div>
                  <div className="space-y-2">
                    <Label htmlFor="soulseek-api-key">API Key</Label>
                    <Input
                      id="soulseek-api-key"
                      value={settings.soulseekApiKey}
                      onChange={(event) => handleSettingsChange("soulseekApiKey", event.target.value)}
                      placeholder="SLSKD_API_KEY"
                      required
                    />
                  </div>
                  {settingsError && <p className="text-sm text-destructive">{settingsError}</p>}
                  <div className="flex justify-end gap-2">
                    <Button type="submit" disabled={settingsSaving}>
                      {settingsSaving && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}Einstellungen speichern
                    </Button>
                  </div>
                </form>
              )}
            </CardContent>
          </Card>
        </TabsContent>
      </Tabs>
    </div>
  );
};

export default SoulseekPage;

// FILE: frontend/src/pages/SpotifyPage.tsx
import { useCallback, useEffect, useMemo, useState } from "react";
import { Loader2, ListMusic, Music, Settings2 } from "lucide-react";

import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "../components/ui/card";
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "../components/ui/table";
import { Badge } from "../components/ui/badge";
import { Button } from "../components/ui/button";
import { Input } from "../components/ui/input";
import { Label } from "../components/ui/label";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "../components/ui/tabs";
import { useToast } from "../components/ui/use-toast";
import useDebouncedValue from "../hooks/useDebouncedValue";
import { useGlobalSearch } from "../hooks/useGlobalSearch";
import spotifyService, { SpotifyPlaylist, SpotifyStatus, SpotifyTrack } from "../services/spotify";
import settingsService, { defaultSettings, type SettingsPayload } from "../services/settings";
import type { ServiceFilters } from "../components/AppHeader";

type SearchResults = {
  tracks: SpotifyTrack[];
};

interface SpotifyPageProps {
  filters: ServiceFilters;
}

const SpotifyPage = ({ filters }: SpotifyPageProps) => {
  const { toast } = useToast();
  const { term } = useGlobalSearch();
  const debouncedSearch = useDebouncedValue(term, 400);
  const [overviewLoading, setOverviewLoading] = useState(true);
  const [searchLoading, setSearchLoading] = useState(false);
  const [status, setStatus] = useState<SpotifyStatus | null>(null);
  const [playlists, setPlaylists] = useState<SpotifyPlaylist[]>([]);
  const [searchResults, setSearchResults] = useState<SearchResults>({ tracks: [] });
  const [settings, setSettings] = useState<SettingsPayload>(defaultSettings);
  const [settingsLoading, setSettingsLoading] = useState(true);
  const [settingsSaving, setSettingsSaving] = useState(false);
  const [settingsError, setSettingsError] = useState<string | null>(null);

  const loadOverview = useCallback(async () => {
    if (!filters.spotify) return;
    try {
      setOverviewLoading(true);
      const [loadedStatus, loadedPlaylists] = await Promise.all([
        spotifyService.getStatus(),
        spotifyService.getPlaylists()
      ]);
      setStatus(loadedStatus);
      setPlaylists(loadedPlaylists);
    } catch (error) {
      console.error(error);
      toast({
        title: "Spotify konnte nicht geladen werden",
        description: "Status und Playlists stehen aktuell nicht zur Verfügung.",
        variant: "destructive"
      });
    } finally {
      setOverviewLoading(false);
    }
  }, [filters.spotify, toast]);

  useEffect(() => {
    void loadOverview();
  }, [loadOverview]);

  useEffect(() => {
    let active = true;

    const runSearch = async () => {
      if (!filters.spotify || !debouncedSearch) {
        setSearchResults({ tracks: [] });
        return;
      }
      try {
        setSearchLoading(true);
        const tracks = await spotifyService.searchTracks(debouncedSearch);
        if (active) {
          setSearchResults({ tracks });
          if (tracks.length) {
            toast({
              title: "Spotify-Suche",
              description: `${tracks.length} Tracks gefunden.`,
              duration: 2500
            });
          }
        }
      } catch (error) {
        console.error(error);
        if (active) {
          toast({
            title: "Suche fehlgeschlagen",
            description: "Die Spotify-Suche konnte nicht durchgeführt werden.",
            variant: "destructive"
          });
        }
      } finally {
        if (active) {
          setSearchLoading(false);
        }
      }
    };

    void runSearch();
    return () => {
      active = false;
    };
  }, [debouncedSearch, filters.spotify, toast]);

  useEffect(() => {
    let mounted = true;
    const loadSettings = async () => {
      try {
        setSettingsLoading(true);
        const loaded = await settingsService.getSettings();
        if (mounted) {
          setSettings(loaded);
        }
      } catch (error) {
        console.error(error);
        if (mounted) {
          setSettingsError("Einstellungen konnten nicht geladen werden.");
        }
      } finally {
        if (mounted) {
          setSettingsLoading(false);
        }
      }
    };

    void loadSettings();
    return () => {
      mounted = false;
    };
  }, []);

  const filteredPlaylists = useMemo(() => {
    if (!term) return playlists;
    return playlists.filter((playlist) => playlist.name.toLowerCase().includes(term.toLowerCase()));
  }, [playlists, term]);

  const handleSettingsChange = (key: keyof SettingsPayload, value: string) => {
    setSettings((prev) => ({ ...prev, [key]: value }));
  };

  const handleSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    try {
      setSettingsSaving(true);
      setSettingsError(null);
      await settingsService.saveSettings(settings);
      toast({ title: "Einstellungen gespeichert", description: "Spotify-Konfiguration aktualisiert." });
    } catch (error) {
      console.error(error);
      setSettingsError("Fehler beim Speichern der Einstellungen.");
      toast({
        title: "Speichern fehlgeschlagen",
        description: "Bitte versuche es erneut.",
        variant: "destructive"
      });
    } finally {
      setSettingsSaving(false);
    }
  };

  if (!filters.spotify) {
    return (
      <Card>
        <CardHeader>
          <CardTitle>Spotify ausgeblendet</CardTitle>
          <CardDescription>Aktiviere den Spotify-Filter im Header, um Inhalte zu sehen.</CardDescription>
        </CardHeader>
      </Card>
    );
  }

  return (
    <div className="space-y-6">
      <header className="flex flex-col gap-1">
        <h1 className="text-2xl font-semibold tracking-tight">Spotify</h1>
        <p className="text-sm text-muted-foreground">
          Suche nach Tracks und verwalte Playlists. Spotify-Credentials können direkt in Harmony gepflegt werden.
        </p>
      </header>

      <Tabs defaultValue="overview">
        <TabsList>
          <TabsTrigger value="overview">Status & Playlists</TabsTrigger>
          <TabsTrigger value="settings">Einstellungen</TabsTrigger>
        </TabsList>

        <TabsContent value="overview" className="space-y-6">
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2 text-base">
                <Music className="h-4 w-4" /> Spotify Status
              </CardTitle>
              <CardDescription>Verbunden seit: {status?.lastSync ?? "–"}</CardDescription>
            </CardHeader>
            <CardContent className="grid gap-4 sm:grid-cols-2">
              <div className="rounded-lg border border-border/60 bg-card p-4">
                <p className="text-xs uppercase text-muted-foreground">Verbindung</p>
                <p className="mt-1 flex items-center gap-2 text-sm font-medium">
                  <Badge variant={status?.connected ? "secondary" : "destructive"}>
                    {status?.connected ? "Connected" : "Disconnected"}
                  </Badge>
                </p>
              </div>
              <div className="rounded-lg border border-border/60 bg-card p-4">
                <p className="text-xs uppercase text-muted-foreground">Playlists</p>
                <p className="mt-1 text-sm font-medium">{playlists.length}</p>
              </div>
            </CardContent>
          </Card>

          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2 text-base">
                <ListMusic className="h-4 w-4" /> Playlists & Suche
              </CardTitle>
              <CardDescription>
                Ergebnisse für „{debouncedSearch || term || "—"}". Die globale Suche filtert Playlists und Tracks.
              </CardDescription>
            </CardHeader>
            <CardContent className="space-y-6">
              {overviewLoading ? (
                <div className="flex items-center justify-center py-8 text-sm text-muted-foreground">
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" /> Playlists werden geladen …
                </div>
              ) : (
                <div className="grid gap-6 lg:grid-cols-2">
                  <div>
                    <h3 className="mb-2 text-sm font-semibold uppercase tracking-wide text-muted-foreground">Playlists</h3>
                    <div className="space-y-3">
                      {filteredPlaylists.map((playlist) => (
                        <div key={playlist.id} className="rounded-lg border border-border/60 bg-card p-4">
                          <p className="font-medium leading-tight">{playlist.name}</p>
                          <p className="text-xs text-muted-foreground">{playlist.trackCount} Tracks</p>
                          {playlist.description && (
                            <p className="mt-2 text-xs text-muted-foreground">{playlist.description}</p>
                          )}
                        </div>
                      ))}
                      {!filteredPlaylists.length && (
                        <p className="text-xs text-muted-foreground">Keine Playlists mit diesem Filter.</p>
                      )}
                    </div>
                  </div>
                  <div>
                    <h3 className="mb-2 text-sm font-semibold uppercase tracking-wide text-muted-foreground">Tracks</h3>
                    {searchLoading ? (
                      <div className="flex items-center justify-center rounded-md border border-dashed border-border py-10 text-sm text-muted-foreground">
                        <Loader2 className="mr-2 h-4 w-4 animate-spin" /> Suche läuft …
                      </div>
                    ) : searchResults.tracks.length ? (
                      <div className="overflow-hidden rounded-lg border border-border/60">
                        <Table>
                          <TableHeader>
                            <TableRow>
                              <TableHead>Track</TableHead>
                              <TableHead>Artist</TableHead>
                              <TableHead>Album</TableHead>
                              <TableHead className="text-right">Dauer</TableHead>
                            </TableRow>
                          </TableHeader>
                          <TableBody>
                            {searchResults.tracks.map((track) => (
                              <TableRow key={track.id}>
                                <TableCell className="font-medium">{track.name}</TableCell>
                                <TableCell>{track.artist}</TableCell>
                                <TableCell>{track.album}</TableCell>
                                <TableCell className="text-right text-sm text-muted-foreground">
                                  {Math.round(track.durationMs / 1000)}s
                                </TableCell>
                              </TableRow>
                            ))}
                          </TableBody>
                        </Table>
                      </div>
                    ) : (
                      <p className="rounded-md border border-dashed border-border py-10 text-center text-sm text-muted-foreground">
                        Keine Tracks gefunden.
                      </p>
                    )}
                  </div>
                </div>
              )}
            </CardContent>
          </Card>
        </TabsContent>

        <TabsContent value="settings">
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2 text-base">
                <Settings2 className="h-4 w-4" /> Spotify Einstellungen
              </CardTitle>
              <CardDescription>API-Zugänge für Spotify. Daten werden nach dem Speichern direkt übernommen.</CardDescription>
            </CardHeader>
            <CardContent>
              {settingsLoading ? (
                <div className="flex items-center justify-center py-12 text-sm text-muted-foreground">
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" /> Einstellungen werden geladen …
                </div>
              ) : (
                <form onSubmit={handleSubmit} className="space-y-6">
                  <div className="grid gap-4 md:grid-cols-2">
                    <div className="space-y-2">
                      <Label htmlFor="spotify-client-id">Client ID</Label>
                      <Input
                        id="spotify-client-id"
                        value={settings.spotifyClientId}
                        onChange={(event) => handleSettingsChange("spotifyClientId", event.target.value)}
                        placeholder="SPOTIFY_CLIENT_ID"
                        required
                      />
                    </div>
                    <div className="space-y-2">
                      <Label htmlFor="spotify-client-secret">Client Secret</Label>
                      <Input
                        id="spotify-client-secret"
                        value={settings.spotifyClientSecret}
                        onChange={(event) => handleSettingsChange("spotifyClientSecret", event.target.value)}
                        placeholder="SPOTIFY_CLIENT_SECRET"
                        required
                      />
                    </div>
                  </div>
                  <div className="space-y-2">
                    <Label htmlFor="spotify-redirect-uri">Redirect URI</Label>
                    <Input
                      id="spotify-redirect-uri"
                      value={settings.spotifyRedirectUri}
                      onChange={(event) => handleSettingsChange("spotifyRedirectUri", event.target.value)}
                      placeholder="https://example.com/callback"
                      required
                    />
                  </div>
                  {settingsError && <p className="text-sm text-destructive">{settingsError}</p>}
                  <div className="flex justify-end gap-2">
                    <Button type="submit" disabled={settingsSaving}>
                      {settingsSaving && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}Einstellungen speichern
                    </Button>
                  </div>
                </form>
              )}
            </CardContent>
          </Card>
        </TabsContent>
      </Tabs>
    </div>
  );
};

export default SpotifyPage;

// FILE: frontend/src/services/activity.ts
import api from "./api";

type ActivityItem = {
  id: string;
  event: string;
  service: string;
  timestamp: string;
};

const activityService = {
  getRecentActivity: async (): Promise<ActivityItem[]> => {
    const { data } = await api.get("/activity/recent");
    return data.activities ?? data;
  }
};

export type { ActivityItem };
export default activityService;

// FILE: frontend/src/services/api.ts
import axios from "axios";

const DEFAULT_BASE_URL = "http://localhost:8000";

const api = axios.create({
  baseURL: import.meta.env.VITE_API_BASE_URL ?? DEFAULT_BASE_URL,
  timeout: 15000
});

api.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response) {
      error.message = error.response.data?.detail ?? error.message;
    }
    return Promise.reject(error);
  }
);

export default api;

// FILE: frontend/src/services/dashboard.ts
import api from "./api";

export type SystemInformation = {
  backendVersion: string;
  status: string;
};

export type HarmonyServiceStatus = {
  name: string;
  status: "connected" | "disconnected" | "unknown";
  meta?: Record<string, unknown>;
};

export type JobEntry = {
  id: string;
  name: string;
  service: string;
  status: string;
  progress: number;
  updatedAt: string;
};

type DashboardOverview = {
  system: SystemInformation;
  services: HarmonyServiceStatus[];
  jobs: JobEntry[];
};

const mapStatus = (name: string, statusValue: any): HarmonyServiceStatus => {
  const status = typeof statusValue?.status === "string" ? statusValue.status : undefined;
  return {
    name,
    status:
      status === "connected" || status === "disconnected"
        ? status
        : status === "error"
          ? "disconnected"
          : "unknown",
    meta: statusValue ?? undefined
  };
};

const mapDownloadsToJobs = (downloads: any[]): JobEntry[] =>
  downloads.map((download) => ({
    id: String(download.id ?? download.download_id ?? ""),
    name: String(download.filename ?? download.name ?? "Download"),
    service: "Soulseek",
    status: String(download.state ?? "unknown"),
    progress: Number(download.progress ?? 0),
    updatedAt: String(download.updated_at ?? download.updatedAt ?? new Date().toISOString())
  }));

const dashboardService = {
  getOverview: async (): Promise<DashboardOverview> => {
    const [systemRes, spotifyRes, plexRes, soulseekRes, downloadsRes] = await Promise.allSettled([
      api.get("/"),
      api.get("/spotify/status"),
      api.get("/plex/status"),
      api.get("/soulseek/status"),
      api.get("/soulseek/downloads")
    ]);

    const system: SystemInformation = {
      backendVersion:
        systemRes.status === "fulfilled" ? systemRes.value.data?.version ?? "unknown" : "unknown",
      status: systemRes.status === "fulfilled" ? systemRes.value.data?.status ?? "unknown" : "unknown"
    };

    const services: HarmonyServiceStatus[] = [
      mapStatus("Spotify", spotifyRes.status === "fulfilled" ? spotifyRes.value.data : null),
      mapStatus("Plex", plexRes.status === "fulfilled" ? plexRes.value.data : null),
      mapStatus("Soulseek", soulseekRes.status === "fulfilled" ? soulseekRes.value.data : null)
    ];

    const downloads =
      downloadsRes.status === "fulfilled"
        ? Array.isArray(downloadsRes.value.data?.downloads)
          ? downloadsRes.value.data.downloads
          : []
        : [];

    const jobs = mapDownloadsToJobs(downloads);

    return {
      system,
      services,
      jobs
    };
  }
};

export type { DashboardOverview };
export { mapDownloadsToJobs };
export default dashboardService;
// FILE: frontend/src/services/matching.ts
import api from "./api";

type MatchingResponse = {
  bestMatch: Record<string, unknown> | null;
  confidence: number;
};

const matchingService = {
  matchSpotifyToPlex: async (payload: Record<string, unknown>): Promise<MatchingResponse> => {
    const { data } = await api.post("/matching/spotify-to-plex", payload);
    return {
      bestMatch: data?.best_match ?? data?.bestMatch ?? null,
      confidence: Number(data?.confidence ?? 0)
    };
  },
  matchSpotifyToSoulseek: async (payload: Record<string, unknown>): Promise<MatchingResponse> => {
    const { data } = await api.post("/matching/spotify-to-soulseek", payload);
    return {
      bestMatch: data?.best_match ?? data?.bestMatch ?? null,
      confidence: Number(data?.confidence ?? 0)
    };
  }
};

export type { MatchingResponse };
export default matchingService;
// FILE: frontend/src/services/plex.ts
import api from "./api";

type PlexStatus = {
  status: "connected" | "disconnected";
  sessions?: any;
  library?: any;
};

type PlexLibrarySection = {
  id: string;
  title: string;
  type?: string;
};

type PlexSession = {
  id: string;
  title: string;
  user?: string;
  state?: string;
};

type PlexLibraryItem = {
  id: string;
  title: string;
  parent?: string;
  type?: string;
  year?: number;
};

const plexService = {
  getStatus: async (): Promise<PlexStatus> => {
    const { data } = await api.get("/plex/status");
    return {
      status: (data?.status as PlexStatus["status"]) ?? "disconnected",
      sessions: data?.sessions,
      library: data?.library
    };
  },
  getSections: async (): Promise<PlexLibrarySection[]> => {
    const { data } = await api.get("/plex/library/sections");
    const container = data?.MediaContainer;
    const sections = Array.isArray(container?.Directory) ? container.Directory : [];
    return sections.map((section: any) => ({
      id: String(section.key ?? section.uuid ?? ""),
      title: String(section.title ?? "Unbenannte Sektion"),
      type: section.type ?? undefined
    }));
  },
  getSessions: async (): Promise<PlexSession[]> => {
    const { data } = await api.get("/plex/status/sessions");
    const sessions = Array.isArray(data?.MediaContainer?.Metadata)
      ? data.MediaContainer.Metadata
      : Array.isArray(data) ? data : [];
    return sessions.map((session: any, index: number) => ({
      id: String(session.sessionKey ?? session.id ?? index),
      title: String(session.title ?? session.grandparentTitle ?? session.parentTitle ?? "Unbekannt"),
      user: session.user?.title ?? session.User?.title ?? session.username ?? undefined,
      state: session.viewOffset ? "playing" : session.state ?? undefined
    }));
  },
  getSectionItems: async (sectionId: string): Promise<PlexLibraryItem[]> => {
    const { data } = await api.get(`/plex/library/sections/${sectionId}/all`);
    const container = data?.MediaContainer;
    const items = Array.isArray(container?.Metadata) ? container.Metadata : [];
    return items.map((item: any, index: number) => ({
      id: String(item.ratingKey ?? item.key ?? index),
      title: String(item.title ?? "Unbenannter Eintrag"),
      parent: item.parentTitle ?? item.grandparentTitle ?? undefined,
      type: item.type ?? undefined,
      year: typeof item.year === "number" ? item.year : undefined
    }));
  }
};

export type { PlexLibraryItem, PlexLibrarySection, PlexSession, PlexStatus };
export default plexService;
// FILE: frontend/src/services/settings.ts
import api from "./api";

type SettingsPayload = {
  spotifyClientId: string;
  spotifyClientSecret: string;
  spotifyRedirectUri: string;
  plexBaseUrl: string;
  plexToken: string;
  plexLibrary: string;
  soulseekApiUrl: string;
  soulseekApiKey: string;
};

type RawSettingsResponse = {
  settings?: Record<string, string | null>;
  updated_at?: string;
};

const defaultSettings: SettingsPayload = {
  spotifyClientId: "",
  spotifyClientSecret: "",
  spotifyRedirectUri: "",
  plexBaseUrl: "",
  plexToken: "",
  plexLibrary: "",
  soulseekApiUrl: "",
  soulseekApiKey: ""
};

const keyMap: Record<keyof SettingsPayload, string> = {
  spotifyClientId: "SPOTIFY_CLIENT_ID",
  spotifyClientSecret: "SPOTIFY_CLIENT_SECRET",
  spotifyRedirectUri: "SPOTIFY_REDIRECT_URI",
  plexBaseUrl: "PLEX_BASE_URL",
  plexToken: "PLEX_TOKEN",
  plexLibrary: "PLEX_LIBRARY",
  soulseekApiUrl: "SLSKD_URL",
  soulseekApiKey: "SLSKD_API_KEY"
};

const mapResponseToSettings = (data: RawSettingsResponse | undefined): SettingsPayload => {
  const entries = data?.settings ?? {};
  return {
    spotifyClientId: (entries[keyMap.spotifyClientId] ?? "") as string,
    spotifyClientSecret: (entries[keyMap.spotifyClientSecret] ?? "") as string,
    spotifyRedirectUri: (entries[keyMap.spotifyRedirectUri] ?? "") as string,
    plexBaseUrl: (entries[keyMap.plexBaseUrl] ?? "") as string,
    plexToken: (entries[keyMap.plexToken] ?? "") as string,
    plexLibrary: (entries[keyMap.plexLibrary] ?? "") as string,
    soulseekApiUrl: (entries[keyMap.soulseekApiUrl] ?? "") as string,
    soulseekApiKey: (entries[keyMap.soulseekApiKey] ?? "") as string
  };
};

const settingsService = {
  getSettings: async (): Promise<SettingsPayload> => {
    const { data } = await api.get<RawSettingsResponse>("/settings");
    return mapResponseToSettings(data);
  },
  saveSettings: async (payload: SettingsPayload): Promise<void> => {
    const entries = Object.entries(payload) as [keyof SettingsPayload, string][];
    for (const [key, value] of entries) {
      const apiKey = keyMap[key];
      await api.post("/settings", { key: apiKey, value });
    }
  }
};

export type { SettingsPayload };
export { defaultSettings };
export default settingsService;
// FILE: frontend/src/services/soulseek.ts
import api from "./api";

type SoulseekDownload = {
  id: string;
  filename: string;
  progress: number;
  status: "queued" | "downloading" | "completed" | "failed" | "cancelled";
  updatedAt?: string;
};

type SoulseekSearchResult = {
  id: string;
  filename: string;
  size: number;
  user: string;
};

const soulseekService = {
  getStatus: async () => {
    const { data } = await api.get("/soulseek/status");
    return data;
  },
  search: async (query: string): Promise<SoulseekSearchResult[]> => {
    if (!query) return [];
    const { data } = await api.post("/soulseek/search", { query });
    const results = Array.isArray(data?.results) ? data.results : [];
    return results.map((item: any, index: number) => ({
      id: String(item.id ?? item.transferId ?? index),
      filename: String(item.filename ?? item.name ?? ""),
      size: Number(item.size ?? item.filesize ?? 0),
      user: String(item.user ?? item.username ?? "")
    }));
  },
  getDownloads: async (): Promise<SoulseekDownload[]> => {
    const { data } = await api.get("/soulseek/downloads");
    const downloads = Array.isArray(data?.downloads) ? data.downloads : [];
    return downloads.map((download: any) => ({
      id: String(download.id ?? download.download_id ?? ""),
      filename: String(download.filename ?? download.name ?? ""),
      progress: Number(download.progress ?? 0),
      status: (download.state as SoulseekDownload["status"]) ?? "queued",
      updatedAt: download.updated_at ?? download.updatedAt ?? undefined
    }));
  },
  cancelDownload: async (downloadId: string) => {
    await api.delete(`/soulseek/download/${downloadId}`);
  }
};

export type { SoulseekDownload, SoulseekSearchResult };
export default soulseekService;
// FILE: frontend/src/services/spotify.ts
import api from "./api";

type SpotifyTrack = {
  id: string;
  name: string;
  album: string;
  artist: string;
  durationMs: number;
};

type SpotifyPlaylist = {
  id: string;
  name: string;
  description?: string;
  trackCount: number;
  updatedAt?: string;
};

type SpotifyStatus = {
  connected: boolean;
  lastSync?: string;
};

const mapTrack = (item: Record<string, any>): SpotifyTrack => ({
  id: String(item.id ?? item.uri ?? ""),
  name: String(item.name ?? "Unbekannter Titel"),
  album: String(item.album?.name ?? ""),
  artist: Array.isArray(item.artists)
    ? item.artists.map((artist: any) => artist.name).filter(Boolean).join(", ")
    : String(item.artist ?? item.artists ?? ""),
  durationMs: Number(item.duration_ms ?? item.durationMs ?? 0)
});

const spotifyService = {
  getStatus: async (): Promise<SpotifyStatus> => {
    const { data } = await api.get("/spotify/status");
    return {
      connected: data?.status === "connected",
      lastSync: data?.last_scan ?? data?.lastScan ?? undefined
    };
  },
  searchTracks: async (query: string): Promise<SpotifyTrack[]> => {
    if (!query) return [];
    const { data } = await api.get("/spotify/search/tracks", { params: { query } });
    const items = Array.isArray(data?.items)
      ? data.items
      : Array.isArray(data?.tracks?.items)
        ? data.tracks.items
        : [];
    return items.map(mapTrack);
  },
  searchArtists: async (query: string) => {
    if (!query) return [];
    const { data } = await api.get("/spotify/search/artists", { params: { query } });
    return Array.isArray(data?.items) ? data.items : [];
  },
  searchAlbums: async (query: string) => {
    if (!query) return [];
    const { data } = await api.get("/spotify/search/albums", { params: { query } });
    return Array.isArray(data?.items) ? data.items : [];
  },
  getPlaylists: async (): Promise<SpotifyPlaylist[]> => {
    const { data } = await api.get("/spotify/playlists");
    const playlists = Array.isArray(data?.playlists) ? data.playlists : [];
    return playlists.map((playlist: any) => ({
      id: String(playlist.id ?? playlist.uri ?? ""),
      name: String(playlist.name ?? "Unbenannte Playlist"),
      description: playlist.description ?? undefined,
      trackCount: Number(playlist.track_count ?? playlist.tracks ?? 0),
      updatedAt: playlist.updated_at ?? playlist.updatedAt ?? undefined
    }));
  }
};

export type { SpotifyPlaylist, SpotifyStatus, SpotifyTrack };
export default spotifyService;
// FILE: frontend/src/stories/AppHeader.stories.tsx
import type { Meta, StoryObj } from "@storybook/react";
import { useEffect, useState } from "react";

import AppHeader, { ServiceFilters } from "../components/AppHeader";

const meta: Meta<typeof AppHeader> = {
  title: "Components/AppHeader",
  component: AppHeader,
  parameters: {
    layout: "fullscreen"
  },
  args: {
    loading: false,
    searchTerm: "",
    filters: {
      spotify: true,
      plex: true,
      soulseek: true
    } satisfies ServiceFilters,
    isDarkMode: false,
    hasNewFeatures: false
  }
};

export default meta;

type Story = StoryObj<typeof AppHeader>;

const StoryWrapper = (props: Story["args"]) => {
  const [filters, setFilters] = useState<ServiceFilters>(
    props?.filters ?? { spotify: true, plex: true, soulseek: true }
  );
  const [searchTerm, setSearchTerm] = useState(props?.searchTerm ?? "");

  useEffect(() => {
    if (props?.isDarkMode) {
      document.documentElement.classList.add("dark");
    } else {
      document.documentElement.classList.remove("dark");
    }

    return () => {
      document.documentElement.classList.remove("dark");
    };
  }, [props?.isDarkMode]);

  return (
    <div className="min-h-screen bg-background p-6">
      <AppHeader
        loading={props?.loading ?? false}
        onRefresh={() => console.log("refresh")}
        searchTerm={searchTerm}
        onSearchChange={setSearchTerm}
        filters={filters}
        onFilterChange={setFilters}
        isDarkMode={props?.isDarkMode ?? false}
        onThemeToggle={() => console.log("theme toggle")}
        onGoHome={() => console.log("go home")}
        onToggleSidebar={() => console.log("toggle sidebar")}
        onShowWhatsNew={props?.onShowWhatsNew}
        onShowNotifications={() => console.log("notifications")}
        hasNewFeatures={props?.hasNewFeatures}
      />
    </div>
  );
};

export const Default: Story = {
  render: (args) => <StoryWrapper {...args} />
};

export const SpotifyFilterActive: Story = {
  render: (args) => (
    <StoryWrapper
      {...args}
      filters={{ spotify: true, plex: false, soulseek: false }}
    />
  )
};

export const Loading: Story = {
  render: (args) => <StoryWrapper {...args} loading />
};

export const DarkMode: Story = {
  render: (args) => <StoryWrapper {...args} isDarkMode />
};

export const WhatsNew: Story = {
  render: (args) => (
    <StoryWrapper
      {...args}
      hasNewFeatures
      onShowWhatsNew={() => console.log("show what's new")}
    />
  )
};

// FILE: frontend/src/vite-env.d.ts
/// <reference types="vite/client" />

// FILE: frontend/tailwind.config.ts
import type { Config } from "tailwindcss";
import animate from "tailwindcss-animate";

const config: Config = {
  darkMode: ["class"],
  content: ["./index.html", "./src/**/*.{ts,tsx}"],
  theme: {
    extend: {
      colors: {
        border: "hsl(var(--border) / <alpha-value>)",
        input: "hsl(var(--input) / <alpha-value>)",
        ring: "hsl(var(--primary) / <alpha-value>)",
        background: "hsl(var(--background) / <alpha-value>)",
        foreground: "hsl(var(--foreground) / <alpha-value>)",
        muted: {
          DEFAULT: "hsl(var(--muted) / <alpha-value>)",
          foreground: "hsl(var(--muted-foreground) / <alpha-value>)"
        },
        card: {
          DEFAULT: "hsl(var(--card) / <alpha-value>)",
          foreground: "hsl(var(--card-foreground) / <alpha-value>)"
        },
        popover: {
          DEFAULT: "hsl(var(--popover) / <alpha-value>)",
          foreground: "hsl(var(--popover-foreground) / <alpha-value>)"
        },
        primary: {
          DEFAULT: "hsl(var(--primary) / <alpha-value>)",
          foreground: "hsl(var(--primary-foreground) / <alpha-value>)"
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary) / <alpha-value>)",
          foreground: "hsl(var(--secondary-foreground) / <alpha-value>)"
        },
        accent: {
          DEFAULT: "hsl(var(--accent) / <alpha-value>)",
          foreground: "hsl(var(--accent-foreground) / <alpha-value>)"
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive) / <alpha-value>)",
          foreground: "hsl(var(--destructive-foreground) / <alpha-value>)"
        },
        sidebar: {
          DEFAULT: "hsl(var(--sidebar-background) / <alpha-value>)",
          foreground: "hsl(var(--sidebar-foreground) / <alpha-value>)",
          muted: "hsl(var(--sidebar-muted) / <alpha-value>)",
          accent: "hsl(var(--sidebar-accent) / <alpha-value>)",
          "accent-foreground": "hsl(var(--sidebar-accent-foreground) / <alpha-value>)"
        },
        navbar: {
          DEFAULT: "hsl(var(--navbar-background) / <alpha-value>)",
          foreground: "hsl(var(--navbar-foreground) / <alpha-value>)"
        }
      },
      borderRadius: {
        lg: "var(--radius-lg)",
        md: "var(--radius-md)",
        sm: "var(--radius-sm)"
      },
      keyframes: {
        "accordion-down": {
          from: { height: "0" },
          to: { height: "var(--radix-accordion-content-height)" }
        },
        "accordion-up": {
          from: { height: "var(--radix-accordion-content-height)" },
          to: { height: "0" }
        },
        "toast-show": {
          from: { opacity: "0", transform: "translateY(10px)" },
          to: { opacity: "1", transform: "translateY(0px)" }
        },
        "toast-hide": {
          from: { opacity: "1", transform: "translateY(0px)" },
          to: { opacity: "0", transform: "translateY(10px)" }
        },
        "drawer-in": {
          from: { transform: "translateX(-100%)", opacity: "0" },
          to: { transform: "translateX(0)", opacity: "1" }
        },
        "drawer-out": {
          from: { transform: "translateX(0)", opacity: "1" },
          to: { transform: "translateX(-10%)", opacity: "0" }
        }
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
        "toast-show": "toast-show 0.2s ease-out",
        "toast-hide": "toast-hide 0.2s ease-in",
        "drawer-in": "drawer-in 0.3s ease-out forwards",
        "drawer-out": "drawer-out 0.2s ease-in forwards"
      }
    }
  },
  plugins: [animate]
};

export default config;

// FILE: frontend/tsconfig.jest.json
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "types": ["vite/client", "jest", "node"],
    "isolatedModules": false
  },
  "include": ["jest.setup.ts", "src"]
}

// FILE: frontend/tsconfig.json
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["DOM", "DOM.Iterable", "ESNext"],
    "allowJs": false,
    "skipLibCheck": true,
    "esModuleInterop": false,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "module": "ESNext",
    "moduleResolution": "Node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "types": ["vite/client"]
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}

// FILE: frontend/tsconfig.node.json
{
  "compilerOptions": {
    "composite": true,
    "module": "ESNext",
    "moduleResolution": "Node",
    "target": "ESNext",
    "lib": ["ESNext", "DOM"],
    "allowSyntheticDefaultImports": true,
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "types": ["node"],
    "jsx": "react-jsx",
    "baseUrl": "./src"
  },
  "include": ["vite.config.ts"]
}

// FILE: frontend/tw-animate-css.css
@layer utilities {
  .animate-drawer-in {
    animation: drawer-in 0.3s ease-out forwards;
  }

  .animate-drawer-out {
    animation: drawer-out 0.2s ease-in forwards;
  }

  .animate-fade-in {
    animation: fade-in 0.25s ease-out both;
  }

  .animate-fade-out {
    animation: fade-out 0.2s ease-in both;
  }

  @keyframes fade-in {
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  }

  @keyframes fade-out {
    from {
      opacity: 1;
    }
    to {
      opacity: 0;
    }
  }
}

// FILE: frontend/vite.config.ts
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  server: {
    port: 5173,
    host: true
  }
});

// FILE: requirements.txt
fastapi
uvicorn
sqlalchemy
aiohttp
spotipy
plexapi
pydantic
pytest
pytest-asyncio
httpx

// FILE: tests/conftest.py
from __future__ import annotations

import os
from contextlib import asynccontextmanager
from pathlib import Path
from typing import Any, Dict

import sys

ROOT = Path(__file__).resolve().parents[1]
if str(ROOT) not in sys.path:
    sys.path.insert(0, str(ROOT))

import pytest
from app.db import init_db, reset_engine_for_tests
from app.dependencies import (
    get_matching_engine as dependency_matching_engine,
    get_plex_client as dependency_plex_client,
    get_soulseek_client as dependency_soulseek_client,
    get_spotify_client as dependency_spotify_client,
)
from app.main import app
from app.workers import MatchingWorker, PlaylistSyncWorker, ScanWorker, SyncWorker
from tests.simple_client import SimpleTestClient


class StubSpotifyClient:
    def __init__(self) -> None:
        self.tracks: Dict[str, Dict[str, Any]] = {
            "track-1": {"id": "track-1", "name": "Test Song", "artists": [{"name": "Tester"}], "duration_ms": 200000},
        }
        self.playlists = [
            {"id": "playlist-1", "name": "My Playlist", "tracks": {"total": 1}},
        ]
        self.audio_features: Dict[str, Dict[str, Any]] = {
            "track-1": {"id": "track-1", "danceability": 0.5},
        }
        self.playlist_items: Dict[str, Dict[str, Any]] = {
            "playlist-1": {"items": [{"track": self.tracks["track-1"]}], "total": 1}
        }
        self.saved_track_ids: set[str] = set()
        self.recommendation_payload: Dict[str, Any] = {"tracks": [], "seeds": []}

    def is_authenticated(self) -> bool:
        return True

    def search_tracks(self, query: str, limit: int = 20) -> Dict[str, Any]:
        return {"tracks": {"items": list(self.tracks.values())}}

    def search_artists(self, query: str, limit: int = 20) -> Dict[str, Any]:
        return {"artists": {"items": [{"id": "artist-1", "name": "Tester"}]}}

    def search_albums(self, query: str, limit: int = 20) -> Dict[str, Any]:
        return {"albums": {"items": [{"id": "album-1", "name": "Album", "artists": [{"name": "Tester"}]}]}}

    def get_user_playlists(self, limit: int = 50) -> Dict[str, Any]:
        return {"items": [dict(item) for item in self.playlists]}

    def get_track_details(self, track_id: str) -> Dict[str, Any]:
        return self.tracks.get(track_id, {"id": track_id, "name": "Unknown"})

    def get_audio_features(self, track_id: str) -> Dict[str, Any]:
        return self.audio_features.get(track_id, {})

    def get_multiple_audio_features(self, track_ids: list[str]) -> Dict[str, Any]:
        return {
            "audio_features": [self.audio_features.get(track_id, {"id": track_id}) for track_id in track_ids]
        }

    def get_playlist_items(self, playlist_id: str, limit: int = 100) -> Dict[str, Any]:
        return self.playlist_items.get(playlist_id, {"items": [], "total": 0})

    def add_tracks_to_playlist(self, playlist_id: str, track_uris: list[str]) -> Dict[str, Any]:
        playlist = self.playlist_items.setdefault(playlist_id, {"items": [], "total": 0})
        for uri in track_uris:
            playlist["items"].append({"track": {"uri": uri}})
        playlist["total"] = len(playlist["items"])
        return {"snapshot_id": "mock"}

    def remove_tracks_from_playlist(self, playlist_id: str, track_uris: list[str]) -> Dict[str, Any]:
        playlist = self.playlist_items.setdefault(playlist_id, {"items": [], "total": 0})
        playlist["items"] = [
            item for item in playlist["items"] if item.get("track", {}).get("uri") not in set(track_uris)
        ]
        playlist["total"] = len(playlist["items"])
        return {"snapshot_id": "mock"}

    def reorder_playlist_items(
        self, playlist_id: str, range_start: int, insert_before: int
    ) -> Dict[str, Any]:
        playlist = self.playlist_items.setdefault(playlist_id, {"items": [], "total": 0})
        items = playlist["items"]
        if 0 <= range_start < len(items):
            track = items.pop(range_start)
            insert_index = max(0, min(insert_before, len(items)))
            items.insert(insert_index, track)
        playlist["items"] = items
        return {"snapshot_id": "reordered"}

    def get_saved_tracks(self, limit: int = 20) -> Dict[str, Any]:
        saved_items = [
            {"track": self.tracks.get(track_id, {"id": track_id})}
            for track_id in list(self.saved_track_ids)[:limit]
        ]
        return {"items": saved_items, "total": len(self.saved_track_ids)}

    def save_tracks(self, track_ids: list[str]) -> Dict[str, Any]:
        self.saved_track_ids.update(track_ids)
        return {"saved": sorted(self.saved_track_ids)}

    def remove_saved_tracks(self, track_ids: list[str]) -> Dict[str, Any]:
        for track_id in track_ids:
            self.saved_track_ids.discard(track_id)
        return {"saved": sorted(self.saved_track_ids)}

    def get_current_user(self) -> Dict[str, Any]:
        return {"id": "user-1", "display_name": "Harmony Tester"}

    def get_top_tracks(self, limit: int = 20) -> Dict[str, Any]:
        return {"items": list(self.tracks.values())[:limit]}

    def get_top_artists(self, limit: int = 20) -> Dict[str, Any]:
        return {"items": [{"id": "artist-1", "name": "Tester"}]}

    def get_recommendations(
        self,
        seed_tracks: list[str] | None = None,
        seed_artists: list[str] | None = None,
        seed_genres: list[str] | None = None,
        limit: int = 20,
    ) -> Dict[str, Any]:
        payload = dict(self.recommendation_payload)
        payload.setdefault("tracks", [])
        payload.setdefault("seeds", [])
        return payload


class StubPlexClient:
    def __init__(self) -> None:
        self.libraries = {
            "MediaContainer": {
                "Directory": [
                    {"key": "1", "type": "artist", "title": "Music"},
                ]
            }
        }
        self.library_items = {
            ("1", "10"): {
                "MediaContainer": {"totalSize": 2, "Metadata": [{"ratingKey": "a"}, {"ratingKey": "b"}]}
            },
            ("1", "9"): {
                "MediaContainer": {"totalSize": 3, "Metadata": [{"ratingKey": "a"}]}
            },
            ("1", "8"): {
                "MediaContainer": {"totalSize": 5, "Metadata": [{"ratingKey": "t"}]}
            },
        }
        self.metadata = {"100": {"title": "Test Item", "year": 2020}}
        self.sessions = {"MediaContainer": {"size": 1, "Metadata": [{"title": "Session"}]}}
        self.session_history = {"MediaContainer": {"size": 1, "Metadata": [{"title": "History"}]}}
        self.playlists = {"MediaContainer": {"size": 1, "Metadata": [{"title": "Playlist"}]}}
        self.created_playlists: list[dict[str, Any]] = []
        self.playqueues: Dict[str, Any] = {}
        self.timeline_updates: list[dict[str, Any]] = []
        self.scrobbles: list[dict[str, Any]] = []
        self.unscrobbles: list[dict[str, Any]] = []
        self.ratings: list[dict[str, Any]] = []
        self.tags: Dict[str, Dict[str, list[str]]] = {}
        self.devices = {"MediaContainer": {"Device": [{"name": "Player"}]}}
        self.dvr = {"MediaContainer": {"Directory": [{"name": "DVR"}]}}
        self.livetv = {"MediaContainer": {"Directory": [{"name": "Channel"}]}}

    async def get_sessions(self) -> Dict[str, Any]:
        return self.sessions

    async def get_library_statistics(self) -> Dict[str, int]:
        return {"artists": 2, "albums": 3, "tracks": 5}

    async def get_libraries(self, params: Dict[str, Any] | None = None) -> Dict[str, Any]:
        return self.libraries

    async def get_library_items(self, section_id: str, params: Dict[str, Any] | None = None) -> Dict[str, Any]:
        type_value = (params or {}).get("type", "")
        return self.library_items.get((section_id, type_value), {"MediaContainer": {"Metadata": []}})

    async def get_metadata(self, item_id: str) -> Dict[str, Any]:
        return self.metadata[item_id]

    async def get_session_history(self, params: Dict[str, Any] | None = None) -> Dict[str, Any]:
        return self.session_history

    async def get_timeline(self, params: Dict[str, Any] | None = None) -> Dict[str, Any]:
        return {"timeline": params or {}}

    async def update_timeline(self, data: Dict[str, Any]) -> str:
        self.timeline_updates.append(data)
        return "ok"

    async def scrobble(self, data: Dict[str, Any]) -> str:
        self.scrobbles.append(data)
        return "ok"

    async def unscrobble(self, data: Dict[str, Any]) -> str:
        self.unscrobbles.append(data)
        return "ok"

    async def get_playlists(self) -> Dict[str, Any]:
        return self.playlists

    async def create_playlist(self, payload: Dict[str, Any]) -> Dict[str, Any]:
        self.created_playlists.append(payload)
        return {"status": "created", "payload": payload}

    async def update_playlist(self, playlist_id: str, payload: Dict[str, Any]) -> Dict[str, Any]:
        return {"status": "updated", "id": playlist_id, "payload": payload}

    async def delete_playlist(self, playlist_id: str) -> Dict[str, Any]:
        return {"status": "deleted", "id": playlist_id}

    async def create_playqueue(self, payload: Dict[str, Any]) -> Dict[str, Any]:
        identifier = str(len(self.playqueues) + 1)
        self.playqueues[identifier] = payload
        return {"playQueueID": identifier, "payload": payload}

    async def get_playqueue(self, playqueue_id: str) -> Dict[str, Any]:
        return self.playqueues.get(playqueue_id, {})

    async def rate_item(self, item_id: str, rating: int) -> str:
        self.ratings.append({"key": item_id, "rating": rating})
        return "ok"

    async def sync_tags(self, item_id: str, tags: Dict[str, list[str]]) -> Dict[str, Any]:
        self.tags[item_id] = tags
        return {"status": "tags-updated", "id": item_id, "tags": tags}

    async def get_devices(self) -> Dict[str, Any]:
        return self.devices

    async def get_dvr(self) -> Dict[str, Any]:
        return self.dvr

    async def get_live_tv(self, params: Dict[str, Any] | None = None) -> Dict[str, Any]:
        return self.livetv

    @asynccontextmanager
    async def listen_notifications(self):  # pragma: no cover - exercised via tests
        class _Message:
            def __init__(self) -> None:
                self.type = type("Type", (), {"name": "TEXT"})
                self.data = "event"

        class _Websocket:
            def __init__(self) -> None:
                self._sent = False

            def exception(self):
                return None

            def __aiter__(self):
                return self

            async def __anext__(self):
                if self._sent:
                    raise StopAsyncIteration
                self._sent = True
                return _Message()

        yield _Websocket()


class StubSoulseekClient:
    def __init__(self) -> None:
        self.downloads: Dict[int, Dict[str, Any]] = {}
        self.queue_positions: Dict[int, Dict[str, Any]] = {}
        self.uploads: Dict[str, Dict[str, Any]] = {
            "up-1": {"id": "up-1", "filename": "upload.flac", "state": "uploading", "progress": 40.0},
            "up-2": {"id": "up-2", "filename": "done.flac", "state": "completed", "progress": 100.0},
        }
        self.enqueued: list[Dict[str, Any]] = []
        self.user_records: Dict[str, Dict[str, Any]] = {
            "tester": {
                "address": {"host": "127.0.0.1", "port": 2234},
                "browse": {"files": ["song.mp3"]},
                "browsing-status": {"state": "idle"},
                "directory": {"path": "", "files": []},
                "info": {"username": "tester", "slots": 3},
                "status": {"online": True},
            }
        }

    async def get_download_status(self) -> Dict[str, Any]:
        return {"downloads": list(self.downloads.values())}

    async def search(self, query: str) -> Dict[str, Any]:
        return {"results": [query]}

    async def download(self, payload: Dict[str, Any]) -> Dict[str, Any]:
        for file_info in payload.get("files", []):
            identifier = int(file_info.get("download_id", 0))
            if identifier <= 0:
                continue
            entry = {
                "id": identifier,
                "filename": file_info.get("filename", "unknown"),
                "progress": 0.0,
                "state": "queued",
            }
            self.downloads[identifier] = entry
        return {"status": "queued"}

    async def cancel_download(self, download_id: str) -> Dict[str, Any]:
        identifier = int(download_id)
        if identifier in self.downloads:
            self.downloads[identifier]["state"] = "failed"
        return {"cancelled": download_id}

    async def get_download(self, download_id: str) -> Dict[str, Any]:
        identifier = int(download_id)
        return self.downloads.get(identifier, {"id": identifier, "state": "unknown"})

    async def get_all_downloads(self) -> list[Dict[str, Any]]:
        return list(self.downloads.values())

    async def remove_completed_downloads(self) -> Dict[str, Any]:
        before = len(self.downloads)
        self.downloads = {k: v for k, v in self.downloads.items() if v.get("state") != "completed"}
        removed = before - len(self.downloads)
        return {"removed": removed}

    async def get_queue_position(self, download_id: str) -> Dict[str, Any]:
        identifier = int(download_id)
        return self.queue_positions.get(identifier, {"position": None})

    async def enqueue(self, username: str, files: list[Dict[str, Any]]) -> Dict[str, Any]:
        job = {"username": username, "files": files}
        self.enqueued.append(job)
        return {"status": "enqueued", "job": job}

    async def cancel_upload(self, upload_id: str) -> Dict[str, Any]:
        upload = self.uploads.get(upload_id)
        if upload:
            upload["state"] = "cancelled"
        return {"cancelled": upload_id}

    async def get_upload(self, upload_id: str) -> Dict[str, Any]:
        return self.uploads.get(upload_id, {"id": upload_id, "state": "unknown"})

    async def get_uploads(self) -> list[Dict[str, Any]]:
        return [upload for upload in self.uploads.values() if upload.get("state") != "completed"]

    async def get_all_uploads(self) -> list[Dict[str, Any]]:
        return list(self.uploads.values())

    async def remove_completed_uploads(self) -> Dict[str, Any]:
        before = len(self.uploads)
        self.uploads = {k: v for k, v in self.uploads.items() if v.get("state") != "completed"}
        removed = before - len(self.uploads)
        return {"removed": removed}

    async def user_address(self, username: str) -> Dict[str, Any]:
        record = self.user_records.get(username, {})
        return record.get("address", {"host": None, "port": None})

    async def user_browse(self, username: str) -> Dict[str, Any]:
        record = self.user_records.get(username, {})
        return record.get("browse", {"files": []})

    async def user_browsing_status(self, username: str) -> Dict[str, Any]:
        record = self.user_records.get(username, {})
        return record.get("browsing-status", {"state": "unknown"})

    async def user_directory(self, username: str, path: str) -> Dict[str, Any]:
        record = self.user_records.setdefault(username, {})
        directory = record.get("directory", {"path": path, "files": []})
        directory = dict(directory)
        directory["path"] = path
        return directory

    async def user_info(self, username: str) -> Dict[str, Any]:
        record = self.user_records.get(username, {})
        return record.get("info", {"username": username})

    async def user_status(self, username: str) -> Dict[str, Any]:
        record = self.user_records.get(username, {})
        return record.get("status", {"online": False})

    def set_status(
        self,
        download_id: int,
        *,
        progress: float | None = None,
        state: str | None = None,
    ) -> None:
        entry = self.downloads.setdefault(
            download_id,
            {
                "id": download_id,
                "filename": f"download-{download_id}",
                "progress": 0.0,
                "state": "queued",
            },
        )
        if progress is not None:
            entry["progress"] = progress
        if state is not None:
            entry["state"] = state


@pytest.fixture(autouse=True)
def configure_environment(monkeypatch: pytest.MonkeyPatch) -> None:
    monkeypatch.setenv("HARMONY_DISABLE_WORKERS", "1")
    monkeypatch.setenv("DATABASE_URL", "sqlite:///./test.db")
    reset_engine_for_tests()
    db_path = Path("test.db")
    if db_path.exists():
        db_path.unlink()
    init_db()
    yield


@pytest.fixture
def client(monkeypatch: pytest.MonkeyPatch) -> SimpleTestClient:
    stub_spotify = StubSpotifyClient()
    stub_plex = StubPlexClient()
    stub_soulseek = StubSoulseekClient()
    engine = dependency_matching_engine()

    async def noop_start(self) -> None:  # type: ignore[override]
        return None

    async def noop_stop(self) -> None:  # type: ignore[override]
        return None

    # Prevent worker tasks during tests
    monkeypatch.setattr(SyncWorker, "start", noop_start)
    monkeypatch.setattr(MatchingWorker, "start", noop_start)
    monkeypatch.setattr(ScanWorker, "start", noop_start)
    monkeypatch.setattr(PlaylistSyncWorker, "start", noop_start)
    monkeypatch.setattr(SyncWorker, "stop", noop_stop)
    monkeypatch.setattr(MatchingWorker, "stop", noop_stop)
    monkeypatch.setattr(ScanWorker, "stop", noop_stop)
    monkeypatch.setattr(PlaylistSyncWorker, "stop", noop_stop)

    from app import dependencies as deps

    monkeypatch.setattr(deps, "get_spotify_client", lambda: stub_spotify)
    monkeypatch.setattr(deps, "get_plex_client", lambda: stub_plex)
    monkeypatch.setattr(deps, "get_soulseek_client", lambda: stub_soulseek)
    monkeypatch.setattr(deps, "get_matching_engine", lambda: engine)

    app.dependency_overrides[dependency_spotify_client] = lambda: stub_spotify
    app.dependency_overrides[dependency_plex_client] = lambda: stub_plex
    app.dependency_overrides[dependency_soulseek_client] = lambda: stub_soulseek
    app.dependency_overrides[dependency_matching_engine] = lambda: engine

    app.state.soulseek_stub = stub_soulseek
    app.state.plex_stub = stub_plex
    app.state.spotify_stub = stub_spotify
    app.state.sync_worker = SyncWorker(stub_soulseek)
    app.state.playlist_worker = PlaylistSyncWorker(stub_spotify, interval_seconds=0.1)

    with SimpleTestClient(app) as test_client:
        yield test_client

    app.dependency_overrides.clear()

// FILE: tests/simple_client.py
from __future__ import annotations

import asyncio
import json
from types import TracebackType
from typing import Any, Dict, Optional, Type
from urllib.parse import urlencode

from fastapi import FastAPI


class SimpleResponse:
    def __init__(self, status_code: int, body: bytes, headers: Dict[str, str]) -> None:
        self.status_code = status_code
        self._body = body
        self.headers = headers

    def json(self) -> Any:
        if not self._body:
            return None
        return json.loads(self._body.decode("utf-8"))


class SimpleTestClient:
    def __init__(self, app: FastAPI) -> None:
        self.app = app
        self._loop = asyncio.new_event_loop()
        self._previous_loop: Optional[asyncio.AbstractEventLoop] = None

    def __enter__(self) -> "SimpleTestClient":
        try:
            self._previous_loop = asyncio.get_event_loop()
        except RuntimeError:
            self._previous_loop = None
        asyncio.get_event_loop_policy().set_event_loop(self._loop)
        self._loop.run_until_complete(self.app.router.startup())
        return self

    def __exit__(
        self,
        exc_type: Optional[Type[BaseException]],
        exc: Optional[BaseException],
        tb: Optional[TracebackType],
    ) -> None:
        self._loop.run_until_complete(self.app.router.shutdown())
        self._loop.close()
        if self._previous_loop is not None:
            asyncio.get_event_loop_policy().set_event_loop(self._previous_loop)

    def get(self, path: str, params: Optional[Dict[str, Any]] = None) -> SimpleResponse:
        return self._loop.run_until_complete(self._request("GET", path, params=params))

    def post(
        self,
        path: str,
        json_body: Optional[Dict[str, Any]] = None,
        json: Optional[Dict[str, Any]] = None,
    ) -> SimpleResponse:
        payload = json_body if json_body is not None else json
        return self._loop.run_until_complete(self._request("POST", path, json_body=payload))

    def put(self, path: str, json: Optional[Dict[str, Any]] = None) -> SimpleResponse:
        return self._loop.run_until_complete(self._request("PUT", path, json_body=json))

    def delete(self, path: str, json: Optional[Dict[str, Any]] = None) -> SimpleResponse:
        return self._loop.run_until_complete(self._request("DELETE", path, json_body=json))

    async def _request(
        self,
        method: str,
        path: str,
        params: Optional[Dict[str, Any]] = None,
        json_body: Optional[Dict[str, Any]] = None,
    ) -> SimpleResponse:
        query_string = urlencode(params or {})
        scope = {
            "type": "http",
            "http_version": "1.1",
            "method": method,
            "path": path,
            "raw_path": path.encode("utf-8"),
            "query_string": query_string.encode("utf-8"),
            "headers": [],
        }

        body = b""
        if json_body is not None:
            body = json.dumps(json_body).encode("utf-8")
            scope["headers"].append((b"content-type", b"application/json"))

        response_body = bytearray()
        response_headers: Dict[str, str] = {}
        status_code = 500
        request_complete = False

        async def receive() -> Dict[str, Any]:
            nonlocal request_complete
            if request_complete:
                return {"type": "http.disconnect"}
            request_complete = True
            return {"type": "http.request", "body": body, "more_body": False}

        async def send(message: Dict[str, Any]) -> None:
            nonlocal status_code, response_headers
            if message["type"] == "http.response.start":
                status_code = message["status"]
                response_headers = {key.decode(): value.decode() for key, value in message.get("headers", [])}
            elif message["type"] == "http.response.body":
                response_body.extend(message.get("body", b""))

        await self.app(scope, receive, send)
        return SimpleResponse(status_code, bytes(response_body), response_headers)

// FILE: tests/test_beets.py
from __future__ import annotations

import subprocess
from pathlib import Path
from typing import Sequence
from unittest.mock import AsyncMock, MagicMock, patch

import pytest

from fastapi import FastAPI
from fastapi.testclient import TestClient

from app.core.beets_client import BeetsClient, BeetsClientError
from app.routers import beets_router


@pytest.fixture()
def api_client() -> TestClient:
    app = FastAPI()
    app.include_router(beets_router.router, prefix="/beets")
    return TestClient(app)


def _completed(args: Sequence[str], stdout: str = "") -> subprocess.CompletedProcess[str]:
    return subprocess.CompletedProcess(args=list(args), returncode=0, stdout=stdout, stderr="")


DEFAULT_RUN_KWARGS = {
    "capture_output": True,
    "text": True,
    "check": True,
    "timeout": 60.0,
}


def _assert_run_called(
    mock_run: MagicMock,
    expected_args: Sequence[str],
    *,
    env: dict | None = None,
) -> None:
    mock_run.assert_called_once()
    args, kwargs = mock_run.call_args
    assert list(args[0]) == list(expected_args)
    expected_kwargs = dict(DEFAULT_RUN_KWARGS)
    if env is not None:
        expected_kwargs["env"] = env
    assert kwargs == expected_kwargs


class TestImportFile:
    @patch("app.core.beets_client.subprocess.run")
    def test_success(self, mock_run: MagicMock) -> None:
        mock_run.return_value = _completed(["beet", "import", "-q", "track.mp3"], "imported\n")

        client = BeetsClient()

        result = client.import_file("track.mp3")

        assert result == "imported"
        _assert_run_called(mock_run, ["beet", "import", "-q", "track.mp3"])

    @patch("app.core.beets_client.subprocess.run")
    def test_options(self, mock_run: MagicMock) -> None:
        mock_run.return_value = _completed(["beet", "import", "-A", "file.mp3"])

        client = BeetsClient()

        client.import_file(Path("file.mp3"), quiet=False, autotag=False)

        _assert_run_called(mock_run, ["beet", "import", "-A", "file.mp3"])

    @patch("app.core.beets_client.subprocess.run")
    def test_called_process_error(self, mock_run: MagicMock) -> None:
        mock_run.side_effect = subprocess.CalledProcessError(
            1, ["beet", "import"], stderr="boom"
        )

        client = BeetsClient()

        with pytest.raises(BeetsClientError):
            client.import_file("track.mp3")

    @patch("app.core.beets_client.subprocess.run")
    def test_unexpected_error(self, mock_run: MagicMock) -> None:
        mock_run.side_effect = OSError("missing beet")

        client = BeetsClient()

        with pytest.raises(BeetsClientError):
            client.import_file("track.mp3")


class TestUpdate:
    @patch("app.core.beets_client.subprocess.run")
    def test_success(self, mock_run: MagicMock) -> None:
        mock_run.return_value = _completed(["beet", "update"], "done\n")

        client = BeetsClient()

        result = client.update()

        assert result == "done"
        _assert_run_called(mock_run, ["beet", "update"])

    @patch("app.core.beets_client.subprocess.run")
    def test_with_path(self, mock_run: MagicMock) -> None:
        mock_run.return_value = _completed(["beet", "update", "/library"])

        client = BeetsClient()

        client.update("/library")

        _assert_run_called(mock_run, ["beet", "update", "/library"])

    @patch("app.core.beets_client.subprocess.run")
    def test_failure(self, mock_run: MagicMock) -> None:
        mock_run.side_effect = subprocess.CalledProcessError(1, ["beet", "update"])

        client = BeetsClient()

        with pytest.raises(BeetsClientError):
            client.update()


class TestListAlbums:
    @patch("app.core.beets_client.subprocess.run")
    def test_success(self, mock_run: MagicMock) -> None:
        mock_run.return_value = _completed(["beet", "ls", "-a"], "One\nTwo\n")

        client = BeetsClient()

        result = client.list_albums()

        assert result == ["One", "Two"]
        _assert_run_called(mock_run, ["beet", "ls", "-a"])

    @patch("app.core.beets_client.subprocess.run")
    def test_failure(self, mock_run: MagicMock) -> None:
        mock_run.side_effect = subprocess.CalledProcessError(1, ["beet", "ls", "-a"])

        client = BeetsClient()

        with pytest.raises(BeetsClientError):
            client.list_albums()


class TestListTracks:
    @patch("app.core.beets_client.subprocess.run")
    def test_success(self, mock_run: MagicMock) -> None:
        mock_run.return_value = _completed([
            "beet",
            "ls",
            "-f",
            "$title",
        ], "Foo\nBar\n")

        client = BeetsClient()

        result = client.list_tracks()

        assert result == ["Foo", "Bar"]
        _assert_run_called(mock_run, ["beet", "ls", "-f", "$title"])

    @patch("app.core.beets_client.subprocess.run")
    def test_failure(self, mock_run: MagicMock) -> None:
        mock_run.side_effect = subprocess.CalledProcessError(
            1, ["beet", "ls", "-f", "$title"]
        )

        client = BeetsClient()

        with pytest.raises(BeetsClientError):
            client.list_tracks()


class TestStats:
    @patch("app.core.beets_client.subprocess.run")
    def test_success(self, mock_run: MagicMock) -> None:
        mock_run.return_value = _completed(["beet", "stats"], "tracks: 42\n")

        client = BeetsClient()

        result = client.stats()

        assert result == {"tracks": "42"}
        _assert_run_called(mock_run, ["beet", "stats"])

    @patch("app.core.beets_client.subprocess.run")
    def test_failure(self, mock_run: MagicMock) -> None:
        mock_run.side_effect = subprocess.CalledProcessError(1, ["beet", "stats"])

        client = BeetsClient()

        with pytest.raises(BeetsClientError):
            client.stats()

    @patch("app.core.beets_client.subprocess.run")
    def test_timeout(self, mock_run: MagicMock) -> None:
        mock_run.side_effect = subprocess.TimeoutExpired(
            cmd=["beet", "stats"], timeout=60.0
        )

        client = BeetsClient()

        with pytest.raises(BeetsClientError) as exc:
            client.stats()

        assert str(exc.value) == "Command timed out"


class TestAvailability:
    @patch("app.core.beets_client.subprocess.run")
    def test_available(self, mock_run: MagicMock) -> None:
        mock_run.return_value = _completed(["beet", "version"], "beets 1.6\n")

        client = BeetsClient()

        assert client.is_available() is True
        _assert_run_called(mock_run, ["beet", "version"])

    @patch("app.core.beets_client.subprocess.run")
    def test_not_available(self, mock_run: MagicMock) -> None:
        mock_run.side_effect = subprocess.CalledProcessError(1, ["beet", "version"])

        client = BeetsClient()

        assert client.is_available() is False


class TestRemove:
    @patch("app.core.beets_client.subprocess.run")
    def test_success(self, mock_run: MagicMock) -> None:
        mock_run.return_value = _completed(
            ["beet", "remove", "genre:rock"], "Removed 2 items\n"
        )

        client = BeetsClient()

        result = client.remove("genre:rock")

        assert result == {"success": True, "removed": 2}
        _assert_run_called(mock_run, ["beet", "remove", "genre:rock"])

    @patch("app.core.beets_client.subprocess.run")
    def test_force(self, mock_run: MagicMock) -> None:
        mock_run.return_value = _completed([
            "beet",
            "remove",
            "-f",
            "genre:rock",
            "year:2020",
        ], "Removed 10 items\n")

        client = BeetsClient()

        result = client.remove("genre:rock year:2020", force=True)

        assert result == {"success": True, "removed": 10}
        _assert_run_called(
            mock_run,
            ["beet", "remove", "-f", "genre:rock", "year:2020"],
        )

    @patch("app.core.beets_client.subprocess.run")
    def test_failure(self, mock_run: MagicMock) -> None:
        mock_run.side_effect = subprocess.CalledProcessError(
            1, ["beet", "remove", "genre:rock"], stderr="error"
        )

        client = BeetsClient()

        with pytest.raises(BeetsClientError):
            client.remove("genre:rock")

    @patch("app.core.beets_client.subprocess.run")
    def test_timeout(self, mock_run: MagicMock) -> None:
        mock_run.side_effect = subprocess.TimeoutExpired(
            cmd=["beet", "remove"], timeout=60.0
        )

        client = BeetsClient()

        with pytest.raises(BeetsClientError) as exc:
            client.remove("genre:rock")

        assert str(exc.value) == "Command timed out"

    def test_empty_query(self) -> None:
        client = BeetsClient()

        with pytest.raises(BeetsClientError):
            client.remove(" ")


class TestMove:
    @patch("app.core.beets_client.subprocess.run")
    def test_without_query(self, mock_run: MagicMock) -> None:
        mock_run.return_value = _completed(["beet", "move"], "Moved 5 items\n")

        client = BeetsClient()

        result = client.move()

        assert result == {"success": True, "moved": 5}
        _assert_run_called(mock_run, ["beet", "move"])

    @patch("app.core.beets_client.subprocess.run")
    def test_with_query(self, mock_run: MagicMock) -> None:
        mock_run.return_value = _completed(
            ["beet", "move", "artist:Radiohead"], "Moved 1 items\n"
        )

        client = BeetsClient()

        result = client.move("artist:Radiohead")

        assert result == {"success": True, "moved": 1}
        _assert_run_called(mock_run, ["beet", "move", "artist:Radiohead"])

    @patch("app.core.beets_client.subprocess.run")
    def test_failure(self, mock_run: MagicMock) -> None:
        mock_run.side_effect = subprocess.CalledProcessError(
            1, ["beet", "move"], stderr="fail"
        )

        client = BeetsClient()

        with pytest.raises(BeetsClientError):
            client.move()

    @patch("app.core.beets_client.subprocess.run")
    def test_timeout(self, mock_run: MagicMock) -> None:
        mock_run.side_effect = subprocess.TimeoutExpired(
            cmd=["beet", "move"], timeout=60.0
        )

        client = BeetsClient()

        with pytest.raises(BeetsClientError) as exc:
            client.move()

        assert str(exc.value) == "Command timed out"


class TestWrite:
    @patch("app.core.beets_client.subprocess.run")
    def test_without_query(self, mock_run: MagicMock) -> None:
        mock_run.return_value = _completed(["beet", "write"], "Wrote 4 items\n")

        client = BeetsClient()

        result = client.write()

        assert result == {"success": True, "written": 4}
        _assert_run_called(mock_run, ["beet", "write"])

    @patch("app.core.beets_client.subprocess.run")
    def test_with_query(self, mock_run: MagicMock) -> None:
        mock_run.return_value = _completed(
            ["beet", "write", "year:2020"], "No changes"
        )

        client = BeetsClient()

        result = client.write("year:2020")

        assert result == {"success": True, "output": "No changes"}
        _assert_run_called(mock_run, ["beet", "write", "year:2020"])

    @patch("app.core.beets_client.subprocess.run")
    def test_failure(self, mock_run: MagicMock) -> None:
        mock_run.side_effect = subprocess.CalledProcessError(
            1, ["beet", "write"], stderr="fail"
        )

        client = BeetsClient()

        with pytest.raises(BeetsClientError):
            client.write()

    @patch("app.core.beets_client.subprocess.run")
    def test_timeout(self, mock_run: MagicMock) -> None:
        mock_run.side_effect = subprocess.TimeoutExpired(
            cmd=["beet", "write"], timeout=60.0
        )

        client = BeetsClient()

        with pytest.raises(BeetsClientError) as exc:
            client.write()

        assert str(exc.value) == "Command timed out"


class TestFields:
    @patch("app.core.beets_client.subprocess.run")
    def test_fields(self, mock_run: MagicMock) -> None:
        mock_run.return_value = _completed([
            "beet",
            "fields",
        ], "artist\nalbum\n")

        client = BeetsClient()

        result = client.fields()

        assert result == ["artist", "album"]
        _assert_run_called(mock_run, ["beet", "fields"])

    @patch("app.core.beets_client.subprocess.run")
    def test_failure(self, mock_run: MagicMock) -> None:
        mock_run.side_effect = subprocess.CalledProcessError(
            1, ["beet", "fields"], stderr="oops"
        )

        client = BeetsClient()

        with pytest.raises(BeetsClientError):
            client.fields()

    @patch("app.core.beets_client.subprocess.run")
    def test_timeout(self, mock_run: MagicMock) -> None:
        mock_run.side_effect = subprocess.TimeoutExpired(
            cmd=["beet", "fields"], timeout=60.0
        )

        client = BeetsClient()

        with pytest.raises(BeetsClientError) as exc:
            client.fields()

        assert str(exc.value) == "Command timed out"


class TestQuery:
    @patch("app.core.beets_client.subprocess.run")
    def test_query(self, mock_run: MagicMock) -> None:
        mock_run.return_value = _completed([
            "beet",
            "ls",
            "-f",
            "$artist - $title",
            "genre:rock",
            "year:1990",
        ], "Artist - Song\n")

        client = BeetsClient()

        result = client.query("genre:rock year:1990", fmt="$artist - $title")

        assert result == ["Artist - Song"]
        _assert_run_called(
            mock_run,
            [
                "beet",
                "ls",
                "-f",
                "$artist - $title",
                "genre:rock",
                "year:1990",
            ],
        )

    def test_invalid_query(self) -> None:
        client = BeetsClient()

        with pytest.raises(BeetsClientError):
            client.query("\"")

    @patch("app.core.beets_client.subprocess.run")
    def test_failure(self, mock_run: MagicMock) -> None:
        mock_run.side_effect = subprocess.CalledProcessError(
            1, ["beet", "ls"], stderr="boom"
        )

        client = BeetsClient()

        with pytest.raises(BeetsClientError):
            client.query("genre:rock")

    @patch("app.core.beets_client.subprocess.run")
    def test_timeout(self, mock_run: MagicMock) -> None:
        mock_run.side_effect = subprocess.TimeoutExpired(
            cmd=["beet", "ls"], timeout=60.0
        )

        client = BeetsClient()

        with pytest.raises(BeetsClientError) as exc:
            client.query("genre:rock")

        assert str(exc.value) == "Command timed out"


class TestEnvironment:
    @patch("app.core.beets_client.subprocess.run")
    def test_env_passed(self, mock_run: MagicMock) -> None:
        mock_run.return_value = _completed(["beet", "stats"], "")

        client = BeetsClient(env={"BEETSDIR": "/tmp/beets"})

        client.stats()

        mock_run.assert_called_once()
        _, kwargs = mock_run.call_args
        assert kwargs["env"]["BEETSDIR"] == "/tmp/beets"
        assert kwargs["timeout"] == 60.0


class TestRouterImport:
    @patch("app.routers.beets_router.run_in_threadpool", new_callable=AsyncMock)
    def test_import_options(self, mock_pool: AsyncMock, api_client: TestClient) -> None:
        mock_pool.return_value = "Imported"

        response = api_client.post(
            "/beets/import",
            json={"path": "music", "quiet": False, "autotag": False},
        )

        assert response.status_code == 200
        assert response.json() == {"success": True, "message": "Imported"}
        mock_pool.assert_awaited_once()
        call_args = mock_pool.await_args
        method = call_args.args[0]
        assert method.__self__ is beets_router.beets_client
        assert method.__name__ == "import_file"
        assert call_args.args[1] == "music"
        assert call_args.kwargs == {"quiet": False, "autotag": False}


class TestRouterRemove:
    @patch("app.routers.beets_router.run_in_threadpool", new_callable=AsyncMock)
    def test_remove(self, mock_pool: AsyncMock, api_client: TestClient) -> None:
        mock_pool.return_value = {"success": True, "removed": 5}

        response = api_client.post(
            "/beets/remove",
            json={"query": "artist:Metallica year:1986", "force": True},
        )

        assert response.status_code == 200
        assert response.json() == {"success": True, "removed": 5}
        mock_pool.assert_awaited_once()
        call_args = mock_pool.await_args
        method = call_args.args[0]
        assert method.__self__ is beets_router.beets_client
        assert method.__name__ == "remove"
        assert call_args.args[1:] == ("artist:Metallica year:1986",)
        assert call_args.kwargs == {"force": True}

    @patch("app.routers.beets_router.run_in_threadpool", new_callable=AsyncMock)
    def test_remove_invalid_query(self, mock_pool: AsyncMock, api_client: TestClient) -> None:
        mock_pool.side_effect = BeetsClientError("Invalid query syntax: missing quote")

        response = api_client.post(
            "/beets/remove",
            json={"query": "artist:'Bad", "force": False},
        )

        assert response.status_code == 400
        assert response.json()["detail"] == "Invalid query syntax"

    def test_remove_empty_query(self, api_client: TestClient) -> None:
        response = api_client.post("/beets/remove", json={"query": ""})

        assert response.status_code == 400
        assert response.json()["detail"] == "Query must not be empty"


class TestRouterMove:
    @patch("app.routers.beets_router.run_in_threadpool", new_callable=AsyncMock)
    def test_move_with_query(self, mock_pool: AsyncMock, api_client: TestClient) -> None:
        mock_pool.return_value = {"success": True, "moved": 2}

        response = api_client.post(
            "/beets/move",
            json={"query": "artist:Radiohead"},
        )

        assert response.status_code == 200
        assert response.json() == {"success": True, "moved": 2}
        mock_pool.assert_awaited_once()
        call_args = mock_pool.await_args
        method = call_args.args[0]
        assert method.__self__ is beets_router.beets_client
        assert method.__name__ == "move"
        assert call_args.args[1:] == ("artist:Radiohead",)
        assert call_args.kwargs == {}

    @patch("app.routers.beets_router.run_in_threadpool", new_callable=AsyncMock)
    def test_move_without_query(self, mock_pool: AsyncMock, api_client: TestClient) -> None:
        mock_pool.return_value = {"success": True, "moved": 4}

        response = api_client.post("/beets/move", json={})

        assert response.status_code == 200
        assert response.json() == {"success": True, "moved": 4}
        mock_pool.assert_awaited_once()
        call_args = mock_pool.await_args
        method = call_args.args[0]
        assert method.__self__ is beets_router.beets_client
        assert method.__name__ == "move"
        assert call_args.args[1:] == (None,)
        assert call_args.kwargs == {}

    @patch("app.routers.beets_router.run_in_threadpool", new_callable=AsyncMock)
    def test_move_client_error(self, mock_pool: AsyncMock, api_client: TestClient) -> None:
        mock_pool.side_effect = BeetsClientError("Command failed")

        response = api_client.post("/beets/move", json={})

        assert response.status_code == 500
        assert response.json()["detail"] == "Command failed"


class TestRouterWrite:
    @patch("app.routers.beets_router.run_in_threadpool", new_callable=AsyncMock)
    def test_write_with_query(self, mock_pool: AsyncMock, api_client: TestClient) -> None:
        mock_pool.return_value = {"success": True, "written": 3}

        response = api_client.post(
            "/beets/write",
            json={"query": "year:2020"},
        )

        assert response.status_code == 200
        assert response.json() == {"success": True, "written": 3}
        mock_pool.assert_awaited_once()
        call_args = mock_pool.await_args
        method = call_args.args[0]
        assert method.__self__ is beets_router.beets_client
        assert method.__name__ == "write"
        assert call_args.args[1:] == ("year:2020",)
        assert call_args.kwargs == {}

    @patch("app.routers.beets_router.run_in_threadpool", new_callable=AsyncMock)
    def test_write_without_query(self, mock_pool: AsyncMock, api_client: TestClient) -> None:
        mock_pool.return_value = {"success": True, "output": "done"}

        response = api_client.post("/beets/write", json={})

        assert response.status_code == 200
        assert response.json() == {"success": True, "output": "done"}
        mock_pool.assert_awaited_once()
        call_args = mock_pool.await_args
        method = call_args.args[0]
        assert method.__self__ is beets_router.beets_client
        assert method.__name__ == "write"
        assert call_args.args[1:] == (None,)
        assert call_args.kwargs == {}


class TestRouterFields:
    @patch("app.routers.beets_router.run_in_threadpool", new_callable=AsyncMock)
    def test_fields(self, mock_pool: AsyncMock, api_client: TestClient) -> None:
        mock_pool.return_value = ["artist", "album"]

        response = api_client.get("/beets/fields")

        assert response.status_code == 200
        assert response.json() == {"fields": ["artist", "album"]}
        mock_pool.assert_awaited_once()
        call_args = mock_pool.await_args
        method = call_args.args[0]
        assert method.__self__ is beets_router.beets_client
        assert method.__name__ == "fields"
        assert call_args.args[1:] == ()
        assert call_args.kwargs == {}


class TestRouterQuery:
    @patch("app.routers.beets_router.run_in_threadpool", new_callable=AsyncMock)
    def test_query(self, mock_pool: AsyncMock, api_client: TestClient) -> None:
        mock_pool.return_value = ["Artist - Song"]

        response = api_client.post(
            "/beets/query",
            json={"query": "genre:rock", "format": "$artist - $title"},
        )

        assert response.status_code == 200
        assert response.json() == {"results": ["Artist - Song"]}
        mock_pool.assert_awaited_once()
        call_args = mock_pool.await_args
        method = call_args.args[0]
        assert method.__self__ is beets_router.beets_client
        assert method.__name__ == "query"
        assert call_args.args[1:] == ("genre:rock",)
        assert call_args.kwargs == {"fmt": "$artist - $title"}

    @patch("app.routers.beets_router.run_in_threadpool", new_callable=AsyncMock)
    def test_query_invalid(self, mock_pool: AsyncMock, api_client: TestClient) -> None:
        mock_pool.side_effect = BeetsClientError("Invalid query syntax: ")

        response = api_client.post(
            "/beets/query",
            json={"query": '"'},
        )

        assert response.status_code == 400
        assert response.json()["detail"] == "Invalid query syntax"


// FILE: tests/test_matching.py
from __future__ import annotations

from app.core.matching_engine import MusicMatchingEngine
from tests.simple_client import SimpleTestClient


def test_match_confidence() -> None:
    engine = MusicMatchingEngine()
    spotify_track = {
        "id": "track-1",
        "name": "Test Song",
        "artists": [{"name": "Tester"}],
        "album": {"name": "Album"},
        "duration_ms": 200000,
    }
    plex_track = {
        "id": "100",
        "title": "Test Song",
        "artist": "Tester",
        "album": "Album",
        "duration": 200000,
    }
    score = engine.calculate_match_confidence(spotify_track, plex_track)
    assert score > 0.8


def test_matching_api_plex(client: SimpleTestClient) -> None:
    payload = {
        "spotify_track": {
            "id": "track-1",
            "name": "Test Song",
            "artists": [{"name": "Tester"}],
            "album": {"name": "Album"},
            "duration_ms": 200000,
        },
        "candidates": [
            {"id": "100", "title": "Test Song", "artist": "Tester", "album": "Album", "duration": 200000}
        ],
    }
    response = client.post("/matching/spotify-to-plex", json=payload)
    assert response.status_code == 200
    data = response.json()
    assert data["best_match"]["id"] == "100"
    assert data["confidence"] > 0.5


def test_matching_api_soulseek(client: SimpleTestClient) -> None:
    payload = {
        "spotify_track": {
            "id": "track-1",
            "name": "Test Song",
            "artists": [{"name": "Tester"}],
            "album": {"name": "Album"},
        },
        "candidates": [
            {"filename": "Tester - Test Song.mp3", "username": "Tester", "bitrate": 320}
        ],
    }
    response = client.post("/matching/spotify-to-soulseek", json=payload)
    assert response.status_code == 200
    assert response.json()["confidence"] > 0.5


def test_album_matching_engine() -> None:
    engine = MusicMatchingEngine()
    spotify_album = {
        "id": "album-1",
        "name": "Test Album",
        "artists": [{"name": "Tester"}],
        "total_tracks": 10,
        "release_date": "2020-05-01",
    }
    plex_albums = [
        {
            "ratingKey": "201",
            "title": "Test Album",
            "grandparentTitle": "Tester",
            "leafCount": 10,
            "year": 2020,
        },
        {
            "ratingKey": "202",
            "title": "Other Album",
            "grandparentTitle": "Tester",
            "leafCount": 8,
            "year": 2018,
        },
    ]
    match, score = engine.find_best_album_match(spotify_album, plex_albums)
    assert match["ratingKey"] == "201"
    assert score > 0.8


def test_matching_api_album(client: SimpleTestClient) -> None:
    payload = {
        "spotify_album": {
            "id": "album-1",
            "name": "Test Album",
            "artists": [{"name": "Tester"}],
            "total_tracks": 10,
            "release_date": "2020-05-01",
        },
        "candidates": [
            {
                "ratingKey": "201",
                "title": "Test Album",
                "grandparentTitle": "Tester",
                "leafCount": 10,
                "year": 2020,
            },
            {
                "ratingKey": "202",
                "title": "Other Album",
                "grandparentTitle": "Tester",
                "leafCount": 8,
                "year": 2018,
            },
        ],
    }
    response = client.post("/matching/spotify-to-plex-album", json=payload)
    assert response.status_code == 200
    data = response.json()
    assert data["best_match"]["ratingKey"] == "201"
    assert data["confidence"] > 0.8

// FILE: tests/test_plex.py
from __future__ import annotations

import asyncio
from typing import Dict

from fastapi import status

from app.db import session_scope
from app.models import Setting
from app.workers.scan_worker import ScanWorker
from tests.simple_client import SimpleTestClient


def test_plex_status(client: SimpleTestClient) -> None:
    response = client.get("/plex/status")
    assert response.status_code == status.HTTP_200_OK
    payload = response.json()
    assert payload["status"] == "connected"
    assert payload["library"] == {"artists": 2, "albums": 3, "tracks": 5}


def test_library_endpoints(client: SimpleTestClient) -> None:
    response = client.get("/plex/library/sections")
    assert response.status_code == status.HTTP_200_OK
    assert response.json()["MediaContainer"]["Directory"][0]["title"] == "Music"

    response = client.get("/plex/library/sections/1/all", params={"type": "8"})
    assert response.status_code == status.HTTP_200_OK
    assert "MediaContainer" in response.json()

    response = client.get("/plex/library/metadata/100")
    assert response.status_code == status.HTTP_200_OK
    assert response.json()["title"] == "Test Item"


def test_session_endpoints(client: SimpleTestClient) -> None:
    response = client.get("/plex/status/sessions")
    assert response.status_code == status.HTTP_200_OK
    assert response.json()["MediaContainer"]["size"] == 1

    response = client.get("/plex/status/sessions/history/all")
    assert response.status_code == status.HTTP_200_OK
    assert response.json()["MediaContainer"]["size"] == 1


def test_timeline_and_scrobble(client: SimpleTestClient) -> None:
    response = client.get("/plex/timeline", params={"ratingKey": "1"})
    assert response.status_code == status.HTTP_200_OK
    assert response.json()["timeline"] == {"ratingKey": "1"}

    response = client.post("/plex/timeline", json={"time": 1000})
    assert response.status_code == status.HTTP_200_OK
    assert response.json() == "ok"

    response = client.post("/plex/scrobble", json={"key": "100"})
    assert response.status_code == status.HTTP_200_OK
    assert response.json() == "ok"

    response = client.post("/plex/unscrobble", json={"key": "100"})
    assert response.status_code == status.HTTP_200_OK
    assert response.json() == "ok"


def test_playlists_and_playqueue(client: SimpleTestClient) -> None:
    response = client.get("/plex/playlists")
    assert response.status_code == status.HTTP_200_OK

    response = client.post("/plex/playlists", json={"title": "New"})
    assert response.status_code == status.HTTP_200_OK
    assert response.json()["status"] == "created"

    response = client.put("/plex/playlists/42", json={"title": "Updated"})
    assert response.status_code == status.HTTP_200_OK
    assert response.json()["status"] == "updated"

    response = client.delete("/plex/playlists/42")
    assert response.status_code == status.HTTP_200_OK
    assert response.json()["status"] == "deleted"

    response = client.post("/plex/playQueues", json={"uri": "library://1"})
    assert response.status_code == status.HTTP_200_OK
    playqueue_id = response.json()["playQueueID"]

    response = client.get(f"/plex/playQueues/{playqueue_id}")
    assert response.status_code == status.HTTP_200_OK
    assert response.json()["uri"] == "library://1"


def test_rating_and_tags(client: SimpleTestClient) -> None:
    response = client.post("/plex/rate", json={"key": "100", "rating": 5})
    assert response.status_code == status.HTTP_200_OK
    assert response.json() == "ok"

    response = client.post("/plex/tags/100", json={"collection": ["Favorites"]})
    assert response.status_code == status.HTTP_200_OK
    assert response.json()["tags"] == {"collection": ["Favorites"]}


def test_devices_and_livetv(client: SimpleTestClient) -> None:
    response = client.get("/plex/devices")
    assert response.status_code == status.HTTP_200_OK
    assert response.json()["MediaContainer"]["Device"][0]["name"] == "Player"

    response = client.get("/plex/dvr")
    assert response.status_code == status.HTTP_200_OK
    assert response.json()["MediaContainer"]["Directory"][0]["name"] == "DVR"

    response = client.get("/plex/livetv")
    assert response.status_code == status.HTTP_200_OK
    assert response.json()["MediaContainer"]["Directory"][0]["name"] == "Channel"


def test_notifications(client: SimpleTestClient) -> None:
    response = client.get("/plex/notifications")
    assert response.status_code == status.HTTP_200_OK
    assert b"data: event" in response._body


def test_scan_worker_updates_status(client: SimpleTestClient) -> None:
    plex_stub = client.app.state.plex_stub
    worker = ScanWorker(plex_stub)

    asyncio.get_event_loop().run_until_complete(worker._perform_scan())

    with session_scope() as session:
        stored_settings: Dict[str, str] = {
            setting.key: setting.value
            for setting in session.query(Setting).all()
            if setting.key.startswith("plex_")
        }

    assert stored_settings["plex_artist_count"] == "2"
    assert stored_settings["plex_album_count"] == "3"
    assert stored_settings["plex_track_count"] == "5"
    assert "T" in stored_settings["plex_last_scan"]


// FILE: tests/test_settings.py
from __future__ import annotations

from typing import List


def _extract_history_for_key(history: List[dict], key: str) -> List[dict]:
    return [entry for entry in history if entry["key"] == key]


def test_settings_history_tracking(client) -> None:
    response = client.post("/settings", json={"key": "theme", "value": "light"})
    assert response.status_code == 200

    response = client.post("/settings", json={"key": "theme", "value": "dark"})
    assert response.status_code == 200

    response = client.post("/settings", json={"key": "notifications", "value": "enabled"})
    assert response.status_code == 200

    history_response = client.get("/settings/history")
    assert history_response.status_code == 200
    payload = history_response.json()

    assert "history" in payload
    history_entries = payload["history"]
    assert len(history_entries) >= 3

    theme_history = _extract_history_for_key(history_entries, "theme")
    assert len(theme_history) == 2

    first_entry, second_entry = theme_history[0], theme_history[1]
    assert first_entry["new_value"] == "dark"
    assert first_entry["old_value"] == "light"
    assert second_entry["new_value"] == "light"
    assert second_entry["old_value"] is None
    assert first_entry["changed_at"] >= second_entry["changed_at"]

// FILE: tests/test_soulseek.py
from __future__ import annotations

from tests.simple_client import SimpleTestClient


def test_soulseek_status(client: SimpleTestClient) -> None:
    response = client.get("/soulseek/status")
    assert response.status_code == 200
    assert response.json()["status"] == "connected"


def test_soulseek_search(client: SimpleTestClient) -> None:
    response = client.post("/soulseek/search", json={"query": "Test"})
    assert response.status_code == 200
    assert response.json()["results"] == ["Test"]


def test_soulseek_download_flow(client: SimpleTestClient) -> None:
    download_payload = {
        "username": "tester",
        "files": [{"filename": "song.mp3", "size": 123}],
    }
    response = client.post("/soulseek/download", json=download_payload)
    assert response.status_code == 200
    payload = response.json()
    assert payload["status"] == "queued"
    download_id = payload["detail"]["downloads"][0]["id"]

    response = client.get("/soulseek/downloads")
    assert response.status_code == 200
    downloads = response.json()["downloads"]
    download = next(item for item in downloads if item["id"] == download_id)
    assert download["state"] == "queued"
    assert download["progress"] == 0.0

    stub = client.app.state.soulseek_stub
    stub.set_status(download_id, progress=25.0, state="downloading")
    client._loop.run_until_complete(client.app.state.sync_worker.refresh_downloads())

    response = client.get("/soulseek/downloads")
    downloads = response.json()["downloads"]
    download = next(item for item in downloads if item["id"] == download_id)
    assert download["state"] == "downloading"
    assert download["progress"] > 0

    stub.set_status(download_id, progress=100.0, state="completed")
    client._loop.run_until_complete(client.app.state.sync_worker.refresh_downloads())

    response = client.get("/soulseek/downloads")
    downloads = response.json()["downloads"]
    download = next(item for item in downloads if item["id"] == download_id)
    assert download["state"] == "completed"
    assert download["progress"] == 100.0


def test_soulseek_download_cancellation(client: SimpleTestClient) -> None:
    download_payload = {
        "username": "tester",
        "files": [{"filename": "song.mp3", "size": 123}],
    }
    response = client.post("/soulseek/download", json=download_payload)
    assert response.status_code == 200
    download_id = response.json()["detail"]["downloads"][0]["id"]

    response = client.delete(f"/soulseek/download/{download_id}")
    assert response.status_code == 200
    assert response.json()["cancelled"] is True

    response = client.get("/soulseek/downloads")
    downloads = response.json()["downloads"]
    download = next(item for item in downloads if item["id"] == download_id)
    assert download["state"] == "failed"

    response = client.delete("/soulseek/download/1")
    assert response.status_code == 200
    assert response.json()["cancelled"] is True


def test_soulseek_download_management_endpoints(client: SimpleTestClient) -> None:
    payload = {
        "username": "tester",
        "files": [{"filename": "song.mp3", "size": 123}],
    }
    response = client.post("/soulseek/download", json=payload)
    assert response.status_code == 200
    download_id = response.json()["detail"]["downloads"][0]["id"]

    stub = client.app.state.soulseek_stub
    stub.queue_positions[download_id] = {"position": 3}
    stub.set_status(download_id, state="completed", progress=100.0)

    detail = client.get(f"/soulseek/download/{download_id}")
    assert detail.status_code == 200
    assert detail.json()["id"] == download_id

    queue = client.get(f"/soulseek/download/{download_id}/queue")
    assert queue.status_code == 200
    assert queue.json()["position"] == 3

    all_downloads = client.get("/soulseek/downloads/all")
    assert all_downloads.status_code == 200
    downloads = all_downloads.json()["downloads"]
    assert any(item["id"] == download_id for item in downloads)

    removed = client.delete("/soulseek/downloads/completed")
    assert removed.status_code == 200
    assert removed.json()["removed"] >= 1

    queue_after = client.get(f"/soulseek/download/{download_id}/queue")
    assert queue_after.status_code == 200


def test_soulseek_enqueue_endpoint(client: SimpleTestClient) -> None:
    payload = {
        "username": "tester",
        "files": [{"filename": "other.mp3", "size": 321}],
    }
    response = client.post("/soulseek/enqueue", json=payload)
    assert response.status_code == 200
    body = response.json()
    assert body["status"] == "enqueued"
    assert body["job"]["files"][0]["filename"] == "other.mp3"


def test_soulseek_upload_endpoints(client: SimpleTestClient) -> None:
    stub = client.app.state.soulseek_stub
    uploads = client.get("/soulseek/uploads")
    assert uploads.status_code == 200
    assert len(uploads.json()["uploads"]) == 1

    all_uploads = client.get("/soulseek/uploads/all")
    assert all_uploads.status_code == 200
    assert len(all_uploads.json()["uploads"]) == 2

    detail = client.get("/soulseek/upload/up-1")
    assert detail.status_code == 200
    assert detail.json()["id"] == "up-1"

    cancel = client.delete("/soulseek/upload/up-1")
    assert cancel.status_code == 200
    assert cancel.json()["cancelled"] == "up-1"

    removed = client.delete("/soulseek/uploads/completed")
    assert removed.status_code == 200
    assert removed.json()["removed"] >= 1

    assert stub.uploads["up-1"]["state"] == "cancelled"


def test_soulseek_user_endpoints(client: SimpleTestClient) -> None:
    address = client.get("/soulseek/user/tester/address")
    assert address.status_code == 200
    assert address.json()["host"] == "127.0.0.1"

    browse = client.get("/soulseek/user/tester/browse")
    assert browse.status_code == 200
    assert browse.json()["files"] == ["song.mp3"]

    status = client.get("/soulseek/user/tester/browsing_status")
    assert status.status_code == 200
    assert status.json()["state"] == "idle"

    directory = client.get("/soulseek/user/tester/directory", params={"path": "/music"})
    assert directory.status_code == 200
    assert directory.json()["path"] == "/music"

    info = client.get("/soulseek/user/tester/info")
    assert info.status_code == 200
    assert info.json()["username"] == "tester"

    user_status = client.get("/soulseek/user/tester/status")
    assert user_status.status_code == 200
    assert user_status.json()["online"] is True

// FILE: tests/test_spotify.py
from __future__ import annotations

from tests.simple_client import SimpleTestClient

from app.db import session_scope
from app.models import Playlist
from app.workers.playlist_sync_worker import PlaylistSyncWorker


def test_playlist_sync_worker_persists_playlists(client: SimpleTestClient) -> None:
    stub = client.app.state.spotify_stub
    stub.playlists = [
        {"id": "playlist-1", "name": "Focus", "tracks": {"total": 12}},
        {"id": "playlist-2", "name": "Relax", "track_count": 8},
    ]

    worker = PlaylistSyncWorker(stub, interval_seconds=0.1)
    client._loop.run_until_complete(worker.sync_once())

    with session_scope() as session:
        records = session.query(Playlist).all()
        assert len(records) == 2

    response = client.get("/spotify/playlists")
    assert response.status_code == 200
    playlists = response.json()["playlists"]
    assert {entry["id"] for entry in playlists} == {"playlist-1", "playlist-2"}
    first = next(item for item in playlists if item["id"] == "playlist-1")
    assert first["track_count"] == 12

    stub.playlists = [
        {"id": "playlist-1", "name": "Focus Updated", "tracks": {"total": 15}},
    ]
    client._loop.run_until_complete(worker.sync_once())

    response = client.get("/spotify/playlists")
    assert response.status_code == 200
    playlists = response.json()["playlists"]
    assert len(playlists) == 2
    updated = next(item for item in playlists if item["id"] == "playlist-1")
    assert updated["name"] == "Focus Updated"
    assert updated["track_count"] == 15
    assert playlists[0]["id"] == "playlist-1"


def test_audio_features_endpoints(client: SimpleTestClient) -> None:
    stub = client.app.state.spotify_stub
    stub.audio_features["track-2"] = {"id": "track-2", "danceability": 0.7}

    single = client.get("/spotify/audio-features/track-1")
    assert single.status_code == 200
    assert single.json()["audio_features"]["id"] == "track-1"

    multiple = client.get("/spotify/audio-features", params={"ids": "track-1,track-2"})
    assert multiple.status_code == 200
    features = multiple.json()["audio_features"]
    assert isinstance(features, list)
    assert {item["id"] for item in features} == {"track-1", "track-2"}


def test_playlist_items_endpoint(client: SimpleTestClient) -> None:
    stub = client.app.state.spotify_stub
    stub.playlist_items["playlist-42"] = {
        "items": [{"track": {"id": "track-1"}}, {"track": {"id": "track-2"}}],
        "total": 2,
    }

    response = client.get("/spotify/playlists/playlist-42/tracks")
    assert response.status_code == 200
    body = response.json()
    assert body["total"] == 2
    assert len(body["items"]) == 2


def test_save_and_remove_tracks(client: SimpleTestClient) -> None:
    stub = client.app.state.spotify_stub

    save_response = client.put("/spotify/me/tracks", json={"ids": ["track-1", "track-2"]})
    assert save_response.status_code == 200
    assert stub.saved_track_ids == {"track-1", "track-2"}

    saved = client.get("/spotify/me/tracks")
    assert saved.status_code == 200
    data = saved.json()
    assert data["total"] == 2

    remove_response = client.delete("/spotify/me/tracks", json={"ids": ["track-1"]})
    assert remove_response.status_code == 200
    assert stub.saved_track_ids == {"track-2"}


def test_recommendations_endpoint(client: SimpleTestClient) -> None:
    stub = client.app.state.spotify_stub
    stub.recommendation_payload = {
        "tracks": [{"id": "track-3"}],
        "seeds": [{"type": "track", "id": "track-1"}],
    }

    response = client.get(
        "/spotify/recommendations",
        params={"seed_tracks": "track-1", "limit": 1},
    )
    assert response.status_code == 200
    body = response.json()
    assert body["tracks"] == [{"id": "track-3"}]
    assert body["seeds"] == [{"type": "track", "id": "track-1"}]

// FILE: frontend/src/components/ui/textarea.tsx
import * as React from "react";

import { cn } from "../../lib/utils";

const Textarea = React.forwardRef<HTMLTextAreaElement, React.TextareaHTMLAttributes<HTMLTextAreaElement>>(
  ({ className, ...props }, ref) => (
    <textarea
      ref={ref}
      className={cn(
        "flex w-full rounded-md border border-input bg-background px-3 py-2 text-sm text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-primary focus-visible:ring-offset-2 focus-visible:ring-offset-background",
        "min-h-[120px]",
        className
      )}
      {...props}
    />
  )
);
Textarea.displayName = "Textarea";

export { Textarea };
