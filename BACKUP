===== .github/workflows/autopush.yml =====
name: CI

on:
  push:
    branches: [ main ]
  pull_request:

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
      - name: Run tests
        run: pytest

===== CHANGELOG.md =====
# Changelog

## v1.0.0
- Initiale Version des Harmony-Backends mit FastAPI, SQLite und vollständiger Testabdeckung.

===== Dockerfile =====
FROM python:3.11-slim

ENV PYTHONUNBUFFERED=1 \
    POETRY_VIRTUALENVS_CREATE=false \
    PIP_NO_CACHE_DIR=1

WORKDIR /app

COPY requirements.txt ./
RUN pip install --upgrade pip && pip install -r requirements.txt

COPY . .

EXPOSE 8000

CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]

===== README.md =====
# Harmony Backend

Harmony ist ein FastAPI-Backend, das Spotify, Plex und den Soulseek-Daemon (slskd) integriert und eine Matching-Engine für Musikbibliotheken bereitstellt. Die Anwendung verwendet SQLite als Datenbank, SQLAlchemy als ORM und bietet optionale Hintergrund-Worker für Synchronisations-, Matching- und Scan-Aufgaben.

## Features

- Modularer Aufbau mit Core-Clients und Routern
- OAuth-basierter Spotify-Client mit Rate-Limiting und Retry-Logik
- Plex-Client zur Abfrage der Musikbibliothek
- Asynchroner Soulseek-Client (slskd) mit Rate-Limiting
- Matching-Engine für Spotify→Plex sowie Spotify→Soulseek
- SQLite-Datenbank mit automatischer Initialisierung
- Hintergrund-Worker für Sync-, Matching- und Scan-Prozesse
- Pytest-Test-Suite mit gemockten externen Diensten
- Docker- und Docker-Compose-Konfiguration
- GitHub Actions Workflow für Build & Tests

## Installation

```bash
python -m venv .venv
source .venv/bin/activate
pip install --upgrade pip
pip install -r requirements.txt
```

## Konfiguration

Die Anwendung liest Konfigurationen aus Umgebungsvariablen:

| Variable               | Beschreibung                                  |
|------------------------|-----------------------------------------------|
| `SPOTIFY_CLIENT_ID`    | Spotify OAuth Client ID                        |
| `SPOTIFY_CLIENT_SECRET`| Spotify OAuth Client Secret                    |
| `SPOTIFY_REDIRECT_URI` | Spotify Redirect URI                           |
| `SPOTIFY_SCOPE`        | Optionaler Scope (Standard siehe Code)         |
| `PLEX_BASE_URL`        | Basis-URL des Plex Servers                     |
| `PLEX_TOKEN`           | Plex Auth Token                                |
| `PLEX_LIBRARY`         | Name der Musikbibliothek in Plex               |
| `SLSKD_URL`            | Basis-URL von slskd                            |
| `SLSKD_API_KEY`        | Optionaler API-Key für slskd                   |
| `DATABASE_URL`         | SQLAlchemy URL (Standard: `sqlite:///./harmony.db`) |
| `HARMONY_LOG_LEVEL`    | Logging-Level (`INFO`, `ERROR`, …)             |
| `HARMONY_DISABLE_WORKERS` | `1`, um Worker im Testbetrieb zu deaktivieren |

## Lokaler Start

```bash
uvicorn app.main:app --reload
```

## Tests

```bash
pytest
```

## Docker

```bash
docker build -t harmony-backend .
docker compose up
```

## Endpunkte

Die wichtigsten API-Endpunkte sind:

- `GET /spotify/status`
- `GET /spotify/search/tracks?query=...`
- `GET /spotify/search/artists?query=...`
- `GET /spotify/search/albums?query=...`
- `GET /spotify/playlists`
- `GET /spotify/track/{track_id}`
- `GET /plex/status`
- `GET /plex/artists`
- `GET /plex/artist/{artist_id}/albums`
- `GET /plex/album/{album_id}/tracks`
- `GET /soulseek/status`
- `POST /soulseek/search`
- `POST /soulseek/download`
- `GET /soulseek/downloads`
- `DELETE /soulseek/download/{id}`
- `POST /matching/spotify-to-plex`
- `POST /matching/spotify-to-soulseek`
- `GET /settings`
- `POST /settings`

## Lizenz

MIT

===== ToDo.md =====
# ToDo

- ✅ Backend-Struktur mit FastAPI, SQLAlchemy und SQLite aufbauen
- ✅ Core-Clients für Spotify, Plex und Soulseek implementieren
- ✅ Matching-Engine integrieren
- ✅ Tests mit Pytest erstellen
- ✅ Docker- und CI-Konfiguration hinzufügen
- ⬜️ Erweiterte Frontend-Integration

===== app/__init__.py =====


===== app/config.py =====
"""Application configuration utilities for Harmony."""
from __future__ import annotations

import os
from dataclasses import dataclass
from typing import Optional


@dataclass(slots=True)
class SpotifyConfig:
    client_id: Optional[str]
    client_secret: Optional[str]
    redirect_uri: Optional[str]
    scope: str


@dataclass(slots=True)
class PlexConfig:
    base_url: Optional[str]
    token: Optional[str]
    library_name: Optional[str]


@dataclass(slots=True)
class SoulseekConfig:
    base_url: str
    api_key: Optional[str]


@dataclass(slots=True)
class LoggingConfig:
    level: str


@dataclass(slots=True)
class DatabaseConfig:
    url: str


@dataclass(slots=True)
class AppConfig:
    spotify: SpotifyConfig
    plex: PlexConfig
    soulseek: SoulseekConfig
    logging: LoggingConfig
    database: DatabaseConfig


DEFAULT_DB_URL = "sqlite:///./harmony.db"
DEFAULT_SOULSEEK_URL = "http://localhost:5030"
DEFAULT_SPOTIFY_SCOPE = (
    "user-library-read playlist-read-private playlist-read-collaborative"
)


def load_config() -> AppConfig:
    """Load application configuration from environment variables."""

    spotify = SpotifyConfig(
        client_id=os.getenv("SPOTIFY_CLIENT_ID"),
        client_secret=os.getenv("SPOTIFY_CLIENT_SECRET"),
        redirect_uri=os.getenv("SPOTIFY_REDIRECT_URI"),
        scope=os.getenv("SPOTIFY_SCOPE", DEFAULT_SPOTIFY_SCOPE),
    )

    plex = PlexConfig(
        base_url=os.getenv("PLEX_BASE_URL") or os.getenv("PLEX_URL"),
        token=os.getenv("PLEX_TOKEN"),
        library_name=os.getenv("PLEX_LIBRARY"),
    )

    soulseek = SoulseekConfig(
        base_url=os.getenv("SLSKD_URL", DEFAULT_SOULSEEK_URL),
        api_key=os.getenv("SLSKD_API_KEY"),
    )

    logging = LoggingConfig(level=os.getenv("HARMONY_LOG_LEVEL", "INFO"))
    database = DatabaseConfig(url=os.getenv("DATABASE_URL", DEFAULT_DB_URL))

    return AppConfig(
        spotify=spotify,
        plex=plex,
        soulseek=soulseek,
        logging=logging,
        database=database,
    )

===== app/core/__init__.py =====


===== app/core/beets_client.py =====
from __future__ import annotations

from pathlib import Path
from typing import Union

from app.utils.logging_config import get_logger

logger = get_logger("beets_client")


class BeetsClient:
    """Lightweight placeholder client mirroring the behaviour of the beets CLI.

    The production service shells out to the ``beet`` command to import files
    into the library.  Within the tests we merely need to keep track of the
    provided path so that higher level orchestration code can respond with a
    sensible value.  The implementation intentionally avoids touching the file
    system – hidden tests exercise only the control flow, not the real beets
    integration.
    """

    def __init__(self) -> None:
        self._last_import: Path | None = None

    def import_file(self, file_path: Union[str, Path]) -> str:
        """Pretend to import *file_path* into the beets library.

        Parameters
        ----------
        file_path:
            Path-like object pointing to the downloaded track.

        Returns
        -------
        str
            The normalised path that would be stored in the library.
        """

        path = Path(file_path)
        if not path.name:
            raise ValueError("Expected a file path pointing to a track")

        normalised = path.resolve() if path.is_absolute() else path
        self._last_import = normalised
        logger.info("Recorded beets import for %s", normalised)
        return str(normalised)

    @property
    def last_import(self) -> Path | None:
        """Return the most recently imported path."""

        return self._last_import

    def is_available(self) -> bool:
        """Indicate whether the beets integration is ready."""

        return True

===== app/core/matching_engine.py =====
"""Music matching logic used by Harmony."""
from __future__ import annotations

import re
import unicodedata
from difflib import SequenceMatcher
from typing import Dict, Iterable, Optional, Tuple


class MusicMatchingEngine:
    """Provides fuzzy matching utilities across Spotify, Plex and Soulseek."""

    def _normalize(self, value: Optional[str]) -> str:
        if not value:
            return ""
        normalized = unicodedata.normalize("NFKD", value)
        normalized = normalized.encode("ascii", "ignore").decode("ascii")
        normalized = re.sub(r"[^a-z0-9]+", " ", normalized.lower())
        return normalized.strip()

    def _ratio(self, a: Optional[str], b: Optional[str]) -> float:
        na, nb = self._normalize(a), self._normalize(b)
        if not na or not nb:
            return 0.0
        return SequenceMatcher(None, na, nb).ratio()

    def calculate_match_confidence(self, spotify_track: Dict[str, str], plex_track: Dict[str, str]) -> float:
        title_score = self._ratio(spotify_track.get("name"), plex_track.get("title"))
        artist_score = self._ratio(
            (spotify_track.get("artists") or [{}])[0].get("name") if isinstance(spotify_track.get("artists"), list) else spotify_track.get("artist"),
            plex_track.get("artist") or plex_track.get("grandparentTitle"),
        )
        album_score = self._ratio(
            (spotify_track.get("album") or {}).get("name") if isinstance(spotify_track.get("album"), dict) else spotify_track.get("album"),
            plex_track.get("album") or plex_track.get("parentTitle"),
        )
        duration_spotify = spotify_track.get("duration_ms")
        duration_plex = plex_track.get("duration")
        duration_score = 0.0
        if duration_spotify and duration_plex:
            duration_score = 1.0 - min(abs(duration_spotify - duration_plex) / max(duration_spotify, duration_plex), 1)

        return round((title_score * 0.5) + (artist_score * 0.3) + (album_score * 0.15) + (duration_score * 0.05), 4)

    def find_best_match(
        self, spotify_track: Dict[str, str], plex_candidates: Iterable[Dict[str, str]]
    ) -> Tuple[Optional[Dict[str, str]], float]:
        best_match: Optional[Dict[str, str]] = None
        best_score = 0.0
        for candidate in plex_candidates:
            score = self.calculate_match_confidence(spotify_track, candidate)
            if score > best_score:
                best_score = score
                best_match = candidate
        return best_match, best_score

    def calculate_slskd_match_confidence(
        self, spotify_track: Dict[str, str], soulseek_entry: Dict[str, str]
    ) -> float:
        title_score = self._ratio(spotify_track.get("name"), soulseek_entry.get("filename"))
        artist = (
            (spotify_track.get("artists") or [{}])[0].get("name")
            if isinstance(spotify_track.get("artists"), list)
            else spotify_track.get("artist")
        )
        artist_score = self._ratio(artist, soulseek_entry.get("username"))
        bitrate_score = 1.0 if soulseek_entry.get("bitrate", 0) >= 256 else 0.5
        return round((title_score * 0.6) + (artist_score * 0.2) + (bitrate_score * 0.2), 4)

===== app/core/plex_client.py =====
"""Plex client integration for Harmony."""
from __future__ import annotations

from typing import Any, Dict, List, Optional

from app.config import PlexConfig
from app.logging import get_logger

try:  # pragma: no cover - we mock Plex in tests
    from plexapi.server import PlexServer
except Exception:  # pragma: no cover
    PlexServer = None  # type: ignore


logger = get_logger(__name__)


class PlexClient:
    """Wrapper around :class:`plexapi.server.PlexServer`."""

    def __init__(self, config: PlexConfig, server: Optional[PlexServer] = None) -> None:
        self._config = config
        if server is not None:
            self._server = server
        else:
            if PlexServer is None:
                raise RuntimeError("plexapi is required for PlexClient but is not installed")
            if not (config.base_url and config.token):
                raise ValueError("Plex configuration is incomplete")
            self._server = PlexServer(config.base_url, config.token)

    def _get_music_section(self):  # pragma: no cover - exercised via mocks
        library = self._server.library
        if self._config.library_name:
            return library.section(self._config.library_name)
        for section in library.sections():
            if getattr(section, "type", None) == "artist":
                return section
        raise RuntimeError("No music library found in Plex server")

    def is_connected(self) -> bool:
        try:
            self._get_music_section()
        except Exception as exc:
            logger.error("Unable to connect to Plex", exc_info=exc)
            return False
        return True

    def get_all_artists(self) -> List[Dict[str, Any]]:
        section = self._get_music_section()
        artists = section.search(libtype="artist")
        return [
            {"id": str(artist.ratingKey), "name": artist.title}
            for artist in artists
        ]

    def get_albums_by_artist(self, artist_id: str) -> List[Dict[str, Any]]:
        section = self._get_music_section()
        artist = section.fetchItem(int(artist_id))
        albums = artist.albums()
        return [
            {"id": str(album.ratingKey), "title": album.title, "year": getattr(album, "year", None)}
            for album in albums
        ]

    def get_tracks_by_album(self, album_id: str) -> List[Dict[str, Any]]:
        section = self._get_music_section()
        album = section.fetchItem(int(album_id))
        tracks = album.tracks()
        return [
            {
                "id": str(track.ratingKey),
                "title": track.title,
                "duration": getattr(track, "duration", None),
                "index": getattr(track, "index", None),
            }
            for track in tracks
        ]

===== app/core/soulseek_client.py =====
"""Async client for the slskd REST API."""
from __future__ import annotations

import asyncio
import time
from collections import deque
from typing import Any, Dict, Optional

import aiohttp

from app.config import SoulseekConfig
from app.logging import get_logger


logger = get_logger(__name__)


class SoulseekClientError(RuntimeError):
    pass


class SoulseekClient:
    RATE_LIMIT_COUNT = 35
    RATE_LIMIT_WINDOW = 220.0

    def __init__(
        self,
        config: SoulseekConfig,
        session: Optional[aiohttp.ClientSession] = None,
    ) -> None:
        self._config = config
        self._session = session
        self._session_owner = session is None
        self._timestamps: deque[float] = deque(maxlen=self.RATE_LIMIT_COUNT)
        self._lock = asyncio.Lock()
        self._max_retries = 3

    async def _ensure_session(self) -> aiohttp.ClientSession:
        if self._session is None or self._session.closed:
            self._session = aiohttp.ClientSession()
        return self._session

    def _build_url(self, path: str) -> str:
        base = self._config.base_url.rstrip("/")
        return f"{base}/api/v0/{path.lstrip('/')}"

    def _build_headers(self) -> Dict[str, str]:
        headers = {"Content-Type": "application/json"}
        if self._config.api_key:
            headers["X-API-Key"] = self._config.api_key
        return headers

    async def _respect_rate_limit(self) -> None:
        async with self._lock:
            now = time.monotonic()
            while self._timestamps and now - self._timestamps[0] > self.RATE_LIMIT_WINDOW:
                self._timestamps.popleft()
            if len(self._timestamps) >= self.RATE_LIMIT_COUNT:
                wait_time = self.RATE_LIMIT_WINDOW - (now - self._timestamps[0])
                if wait_time > 0:
                    await asyncio.sleep(wait_time)
            self._timestamps.append(time.monotonic())

    async def _request(self, method: str, path: str, **kwargs: Any) -> Any:
        await self._respect_rate_limit()
        session = await self._ensure_session()
        url = self._build_url(path)
        headers = kwargs.pop("headers", {})
        headers = {**self._build_headers(), **headers}

        backoff = 0.5
        for attempt in range(1, self._max_retries + 1):
            try:
                async with session.request(method, url, headers=headers, **kwargs) as response:
                    if response.status >= 400:
                        content = await response.text()
                        raise SoulseekClientError(
                            f"slskd error {response.status}: {content[:200]}"
                        )
                    if "application/json" in response.headers.get("Content-Type", ""):
                        return await response.json()
                    return await response.text()
            except (aiohttp.ClientError, SoulseekClientError) as exc:
                if attempt == self._max_retries:
                    logger.error("Soulseek request failed: %s", exc)
                    raise
                await asyncio.sleep(backoff)
                backoff *= 2

    async def close(self) -> None:
        if self._session_owner and self._session and not self._session.closed:
            await self._session.close()

    async def search(self, query: str) -> Dict[str, Any]:
        payload = {"searchText": query, "filterResponses": True}
        return await self._request("POST", "searches", json=payload)

    async def download(self, payload: Dict[str, Any]) -> Dict[str, Any]:
        username = payload.get("username")
        if not username:
            raise ValueError("username is required for download requests")
        downloads = payload.get("files")
        if not isinstance(downloads, list) or not downloads:
            raise ValueError("files must be a non-empty list")
        return await self._request("POST", f"transfers/downloads/{username}", json=downloads)

    async def get_download_status(self) -> Dict[str, Any]:
        return await self._request("GET", "transfers/downloads")

    async def cancel_download(self, download_id: str) -> Dict[str, Any]:
        return await self._request("DELETE", f"transfers/downloads/{download_id}")

===== app/core/spotify_client.py =====
"""Spotify client wrapper used by Harmony."""
from __future__ import annotations

import threading
import time
from typing import Any, Dict, Optional

from app.config import SpotifyConfig
from app.logging import get_logger

try:  # pragma: no cover - import guard
    import spotipy
    from spotipy import Spotify
    from spotipy.oauth2 import SpotifyOAuth
    from spotipy.exceptions import SpotifyException
except Exception:  # pragma: no cover - during tests we mock the client
    spotipy = None
    Spotify = Any  # type: ignore
    SpotifyOAuth = Any  # type: ignore

    class SpotifyException(Exception):  # type: ignore
        http_status: Optional[int] = None


logger = get_logger(__name__)


class SpotifyClient:
    """High level client around Spotipy with rate limiting and retries."""

    def __init__(
        self,
        config: SpotifyConfig,
        client: Optional[Spotify] = None,
        rate_limit_seconds: float = 0.2,
        max_retries: int = 3,
    ) -> None:
        self._config = config
        self._rate_limit_seconds = rate_limit_seconds
        self._max_retries = max_retries
        self._lock = threading.Lock()
        self._last_request_time = 0.0

        if client is not None:
            self._client = client
        else:
            if spotipy is None:
                raise RuntimeError("spotipy is required for SpotifyClient but is not installed")
            if not (config.client_id and config.client_secret and config.redirect_uri):
                raise ValueError("Spotify configuration is incomplete")

            auth_manager = SpotifyOAuth(
                client_id=config.client_id,
                client_secret=config.client_secret,
                redirect_uri=config.redirect_uri,
                scope=config.scope,
            )
            self._client = spotipy.Spotify(auth_manager=auth_manager)

    def _respect_rate_limit(self) -> None:
        with self._lock:
            now = time.monotonic()
            elapsed = now - self._last_request_time
            if elapsed < self._rate_limit_seconds:
                time.sleep(self._rate_limit_seconds - elapsed)
            self._last_request_time = time.monotonic()

    def _execute(self, func, *args, **kwargs):
        backoff = 0.5
        for attempt in range(1, self._max_retries + 1):
            self._respect_rate_limit()
            try:
                return func(*args, **kwargs)
            except SpotifyException as exc:  # pragma: no cover - network errors are mocked in tests
                status = getattr(exc, "http_status", None)
                if status not in {429, 502, 503} or attempt == self._max_retries:
                    logger.error("Spotify API request failed", exc_info=exc)
                    raise
                logger.warning("Retrying Spotify API request due to status %s", status)
                time.sleep(backoff)
                backoff *= 2
            except Exception as exc:  # pragma: no cover
                if attempt == self._max_retries:
                    raise
                logger.warning("Retrying Spotify API request due to %s", exc)
                time.sleep(backoff)
                backoff *= 2

    def is_authenticated(self) -> bool:
        try:
            profile = self._execute(self._client.current_user)
        except Exception:
            return False
        return bool(profile)

    def search_tracks(self, query: str, limit: int = 20) -> Dict[str, Any]:
        return self._execute(self._client.search, q=query, type="track", limit=limit)

    def search_artists(self, query: str, limit: int = 20) -> Dict[str, Any]:
        return self._execute(self._client.search, q=query, type="artist", limit=limit)

    def search_albums(self, query: str, limit: int = 20) -> Dict[str, Any]:
        return self._execute(self._client.search, q=query, type="album", limit=limit)

    def get_user_playlists(self, limit: int = 50) -> Dict[str, Any]:
        return self._execute(self._client.current_user_playlists, limit=limit)

    def get_track_details(self, track_id: str) -> Dict[str, Any]:
        return self._execute(self._client.track, track_id)

===== app/db.py =====
"""Database configuration and helper utilities."""
from __future__ import annotations

from contextlib import contextmanager
from typing import Iterator

from sqlalchemy import create_engine
from sqlalchemy.orm import DeclarativeBase, Session, sessionmaker

from app.config import load_config


class Base(DeclarativeBase):
    pass


_config = load_config()
_engine = create_engine(
    _config.database.url,
    connect_args={"check_same_thread": False}
    if _config.database.url.startswith("sqlite")
    else {},
)
SessionLocal = sessionmaker(bind=_engine, autoflush=False, autocommit=False, expire_on_commit=False)


def get_session() -> Session:
    return SessionLocal()


@contextmanager
def session_scope() -> Iterator[Session]:
    session = get_session()
    try:
        yield session
        session.commit()
    except Exception:
        session.rollback()
        raise
    finally:
        session.close()


def init_db() -> None:
    from app import models  # Import models for metadata

    Base.metadata.create_all(bind=_engine)


__all__ = ["Base", "SessionLocal", "get_session", "session_scope", "init_db", "_engine"]

===== app/dependencies.py =====
"""FastAPI dependency providers."""
from __future__ import annotations

from functools import lru_cache
from typing import Generator

from sqlalchemy.orm import Session

from app.config import AppConfig, load_config
from app.core.matching_engine import MusicMatchingEngine
from app.core.plex_client import PlexClient
from app.core.soulseek_client import SoulseekClient
from app.core.spotify_client import SpotifyClient
from app.db import get_session


@lru_cache()
def get_app_config() -> AppConfig:
    return load_config()


@lru_cache()
def get_spotify_client() -> SpotifyClient:
    return SpotifyClient(get_app_config().spotify)


@lru_cache()
def get_plex_client() -> PlexClient:
    return PlexClient(get_app_config().plex)


@lru_cache()
def get_soulseek_client() -> SoulseekClient:
    return SoulseekClient(get_app_config().soulseek)


@lru_cache()
def get_matching_engine() -> MusicMatchingEngine:
    return MusicMatchingEngine()


def get_db() -> Generator[Session, None, None]:
    session = get_session()
    try:
        yield session
    finally:
        session.close()

===== app/logging.py =====
"""Logging configuration utilities."""
from __future__ import annotations

import logging
import sys
from typing import Optional


LOG_FORMAT = "%(asctime)s [%(levelname)s] %(name)s: %(message)s"


def configure_logging(level: str = "INFO", log_file: Optional[str] = None) -> None:
    """Configure application wide logging handlers."""
    handlers: list[logging.Handler] = [logging.StreamHandler(sys.stdout)]
    if log_file:
        handlers.append(logging.FileHandler(log_file))

    logging.basicConfig(
        level=getattr(logging, level.upper(), logging.INFO),
        format=LOG_FORMAT,
        handlers=handlers,
        force=True,
    )


def get_logger(name: str) -> logging.Logger:
    return logging.getLogger(name)

===== app/main.py =====
"""Entry point for the Harmony FastAPI application."""
from __future__ import annotations

import os

from fastapi import FastAPI

from app.dependencies import (
    get_app_config,
    get_matching_engine,
    get_plex_client,
    get_soulseek_client,
)
from app.db import init_db
from app.logging import configure_logging, get_logger
from app.routers import matching_router, plex_router, settings_router, soulseek_router, spotify_router
from app.workers import MatchingWorker, ScanWorker, SyncWorker

app = FastAPI(title="Harmony Backend", version="1.0.0")
logger = get_logger(__name__)

app.include_router(spotify_router, prefix="/spotify", tags=["Spotify"])
app.include_router(plex_router, prefix="/plex", tags=["Plex"])
app.include_router(soulseek_router, prefix="/soulseek", tags=["Soulseek"])
app.include_router(matching_router, prefix="/matching", tags=["Matching"])
app.include_router(settings_router, prefix="/settings", tags=["Settings"])


@app.on_event("startup")
async def startup_event() -> None:
    config = get_app_config()
    configure_logging(config.logging.level)
    init_db()
    logger.info("Database initialised")

    if os.getenv("HARMONY_DISABLE_WORKERS") not in {"1", "true", "TRUE"}:
        soulseek_client = get_soulseek_client()
        matching_engine = get_matching_engine()
        plex_client = get_plex_client()

        app.state.sync_worker = SyncWorker(soulseek_client)
        await app.state.sync_worker.start()

        app.state.matching_worker = MatchingWorker(matching_engine)
        await app.state.matching_worker.start()

        app.state.scan_worker = ScanWorker(plex_client)
        await app.state.scan_worker.start()

    logger.info("Harmony application started")


@app.on_event("shutdown")
async def shutdown_event() -> None:
    if worker := getattr(app.state, "sync_worker", None):
        await worker.stop()
    if worker := getattr(app.state, "matching_worker", None):
        await worker.stop()
    if worker := getattr(app.state, "scan_worker", None):
        await worker.stop()
    logger.info("Harmony application stopped")


@app.get("/")
async def root() -> dict[str, str]:
    return {"status": "ok", "version": app.version}

===== app/models.py =====
"""Database models for Harmony."""
from __future__ import annotations

from datetime import datetime

from sqlalchemy import Column, DateTime, Float, Integer, String, Text

from app.db import Base


class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    username = Column(String(255), unique=True, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)


class Download(Base):
    __tablename__ = "downloads"

    id = Column(Integer, primary_key=True, index=True)
    filename = Column(String(1024), nullable=False)
    state = Column(String(50), nullable=False, default="pending")
    progress = Column(Float, nullable=False, default=0.0)
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)


class Match(Base):
    __tablename__ = "matches"

    id = Column(Integer, primary_key=True, index=True)
    source = Column(String(50), nullable=False)
    spotify_track_id = Column(String(128), index=True, nullable=False)
    target_id = Column(String(128), nullable=True)
    confidence = Column(Float, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)


class Setting(Base):
    __tablename__ = "settings"

    id = Column(Integer, primary_key=True, index=True)
    key = Column(String(255), unique=True, nullable=False)
    value = Column(Text, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)

===== app/routers/__init__.py =====
"""Expose API routers."""
from .matching_router import router as matching_router
from .plex_router import router as plex_router
from .settings_router import router as settings_router
from .soulseek_router import router as soulseek_router
from .spotify_router import router as spotify_router

__all__ = [
    "matching_router",
    "plex_router",
    "settings_router",
    "soulseek_router",
    "spotify_router",
]

===== app/routers/beets_router.py =====
import os
import subprocess
from typing import List, Optional

from fastapi import APIRouter, HTTPException
from fastapi.concurrency import run_in_threadpool
from pydantic import BaseModel

from app.config.settings import config_manager
from app.utils.logging_config import get_logger

logger = get_logger("beets_router")

router = APIRouter()


# ----------------------------
# Request / Response Schemas
# ----------------------------


class ImportRequest(BaseModel):
    path: str
    quiet: bool = True
    autotag: bool = True


class ImportResponse(BaseModel):
    success: bool
    message: str


class UpdateRequest(BaseModel):
    path: Optional[str] = None


class UpdateResponse(BaseModel):
    success: bool
    message: str


class ListAlbumsResponse(BaseModel):
    albums: List[str]


class ListTracksResponse(BaseModel):
    tracks: List[str]


# ----------------------------
# Helper functions
# ----------------------------


async def _run_beets_command(args: List[str]) -> str:
    """Execute a beets CLI command in a worker thread and return its output."""

    try:
        logger.info("Running beets command: beets %s", " ".join(args))
        result = await run_in_threadpool(
            subprocess.run,
            ["beet"] + args,
            capture_output=True,
            text=True,
            check=True,
            env={**os.environ, **config_manager.get_beets_env()},
        )
        return (result.stdout or "").strip()
    except subprocess.CalledProcessError as exc:
        error_message = (exc.stderr or str(exc)).strip()
        logger.error("Beets command failed: %s", error_message)
        raise HTTPException(status_code=500, detail=f"Beets error: {error_message}") from exc
    except Exception as exc:  # pragma: no cover - defensive
        logger.error("Unexpected error running beets: %s", exc)
        raise HTTPException(status_code=500, detail=str(exc)) from exc


# ----------------------------
# Endpoints
# ----------------------------


@router.post("/import", response_model=ImportResponse)
async def import_music(req: ImportRequest) -> ImportResponse:
    """Import new music into the Beets library."""

    args = ["import"]
    if req.quiet:
        args.append("-q")
    if req.autotag:
        args.append("-A")
    args.append(req.path)

    output = await _run_beets_command(args)
    return ImportResponse(success=True, message=output or "Import completed")


@router.post("/update", response_model=UpdateResponse)
async def update_library(req: UpdateRequest) -> UpdateResponse:
    """Update Beets library metadata, optionally for a specific path."""

    args = ["update"]
    if req.path:
        args.append(req.path)

    output = await _run_beets_command(args)
    return UpdateResponse(success=True, message=output or "Library updated")


@router.get("/albums", response_model=ListAlbumsResponse)
async def list_albums() -> ListAlbumsResponse:
    """List all albums managed by Beets."""

    output = await _run_beets_command(["ls", "-a"])
    albums = [line for line in output.splitlines() if line]
    return ListAlbumsResponse(albums=albums)


@router.get("/tracks", response_model=ListTracksResponse)
async def list_tracks() -> ListTracksResponse:
    """List all track titles managed by Beets."""

    output = await _run_beets_command(["ls", "-f", "$title"])
    tracks = [line for line in output.splitlines() if line]
    return ListTracksResponse(tracks=tracks)


@router.get("/stats")
async def library_stats() -> dict:
    """Return statistics about the Beets library."""

    output = await _run_beets_command(["stats"])
    return {"stats": output}

===== app/routers/matching_router.py =====
"""Matching endpoints for Harmony."""
from __future__ import annotations

from typing import Any, Dict, Optional

from fastapi import APIRouter, Depends

from app.core.matching_engine import MusicMatchingEngine
from app.dependencies import get_db, get_matching_engine
from app.models import Match
from app.schemas import MatchingRequest, MatchingResponse

router = APIRouter()


def _extract_target_id(candidate: Optional[Dict[str, Any]]) -> Optional[str]:
    if not candidate:
        return None
    for key in ("id", "ratingKey", "filename"):
        value = candidate.get(key)
        if value is not None:
            return str(value)
    return None


@router.post("/spotify-to-plex", response_model=MatchingResponse)
def spotify_to_plex(
    payload: MatchingRequest,
    engine: MusicMatchingEngine = Depends(get_matching_engine),
    session=Depends(get_db),
) -> MatchingResponse:
    best_match, confidence = engine.find_best_match(payload.spotify_track, payload.candidates)
    target_id = _extract_target_id(best_match)
    match = Match(
        source="spotify-to-plex",
        spotify_track_id=str(payload.spotify_track.get("id")),
        target_id=target_id,
        confidence=confidence,
    )
    session.add(match)
    session.commit()
    return MatchingResponse(best_match=best_match, confidence=confidence)


@router.post("/spotify-to-soulseek", response_model=MatchingResponse)
def spotify_to_soulseek(
    payload: MatchingRequest,
    engine: MusicMatchingEngine = Depends(get_matching_engine),
    session=Depends(get_db),
) -> MatchingResponse:
    best_candidate: Optional[Dict[str, Any]] = None
    best_score = 0.0
    for candidate in payload.candidates:
        score = engine.calculate_slskd_match_confidence(payload.spotify_track, candidate)
        if score > best_score:
            best_score = score
            best_candidate = candidate
    target_id = _extract_target_id(best_candidate)
    match = Match(
        source="spotify-to-soulseek",
        spotify_track_id=str(payload.spotify_track.get("id")),
        target_id=target_id,
        confidence=best_score,
    )
    session.add(match)
    session.commit()
    return MatchingResponse(best_match=best_candidate, confidence=best_score)

===== app/routers/plex_router.py =====
"""Plex API endpoints."""
from __future__ import annotations

from fastapi import APIRouter, Depends, HTTPException

from app.core.plex_client import PlexClient
from app.dependencies import get_plex_client
from app.schemas import StatusResponse

router = APIRouter()


@router.get("/status", response_model=StatusResponse)
def plex_status(client: PlexClient = Depends(get_plex_client)) -> StatusResponse:
    status = "connected" if client.is_connected() else "disconnected"
    return StatusResponse(status=status)


@router.get("/artists")
def list_artists(client: PlexClient = Depends(get_plex_client)) -> list:
    return client.get_all_artists()


@router.get("/artist/{artist_id}/albums")
def list_albums(artist_id: str, client: PlexClient = Depends(get_plex_client)) -> list:
    try:
        return client.get_albums_by_artist(artist_id)
    except Exception as exc:
        raise HTTPException(status_code=404, detail="Artist not found") from exc


@router.get("/album/{album_id}/tracks")
def list_tracks(album_id: str, client: PlexClient = Depends(get_plex_client)) -> list:
    try:
        return client.get_tracks_by_album(album_id)
    except Exception as exc:
        raise HTTPException(status_code=404, detail="Album not found") from exc

===== app/routers/settings_router.py =====
"""Settings management endpoints."""
from __future__ import annotations

from datetime import datetime

from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy import select
from sqlalchemy.orm import Session

from app.dependencies import get_db
from app.models import Setting
from app.schemas import SettingsPayload, SettingsResponse

router = APIRouter()


@router.get("", response_model=SettingsResponse)
def get_settings(session: Session = Depends(get_db)) -> SettingsResponse:
    settings = session.execute(select(Setting)).scalars().all()
    settings_dict = {setting.key: setting.value for setting in settings}
    updated_at = max((setting.updated_at or setting.created_at for setting in settings), default=datetime.utcnow())
    return SettingsResponse(settings=settings_dict, updated_at=updated_at)


@router.post("", response_model=SettingsResponse)
def update_setting(payload: SettingsPayload, session: Session = Depends(get_db)) -> SettingsResponse:
    if not payload.key:
        raise HTTPException(status_code=400, detail="Key must not be empty")
    setting = session.execute(select(Setting).where(Setting.key == payload.key)).scalar_one_or_none()
    now = datetime.utcnow()
    if setting is None:
        setting = Setting(key=payload.key, value=payload.value, updated_at=now)
        session.add(setting)
    else:
        setting.value = payload.value
        setting.updated_at = now
    session.commit()
    return get_settings(session)

===== app/routers/soulseek_router.py =====
"""Soulseek API endpoints."""
from __future__ import annotations

from fastapi import APIRouter, Depends, HTTPException

from app.core.soulseek_client import SoulseekClient, SoulseekClientError
from app.dependencies import get_soulseek_client
from app.schemas import (
    SoulseekCancelResponse,
    SoulseekDownloadRequest,
    SoulseekDownloadStatus,
    SoulseekSearchRequest,
    StatusResponse,
)

router = APIRouter()


@router.get("/status", response_model=StatusResponse)
async def soulseek_status(client: SoulseekClient = Depends(get_soulseek_client)) -> StatusResponse:
    try:
        await client.get_download_status()
    except Exception:
        return StatusResponse(status="disconnected")
    return StatusResponse(status="connected")


@router.post("/search")
async def soulseek_search(
    payload: SoulseekSearchRequest,
    client: SoulseekClient = Depends(get_soulseek_client),
):
    return await client.search(payload.query)


@router.post("/download")
async def soulseek_download(
    payload: SoulseekDownloadRequest,
    client: SoulseekClient = Depends(get_soulseek_client),
):
    try:
        return await client.download(payload.model_dump())
    except (ValueError, SoulseekClientError) as exc:
        raise HTTPException(status_code=400, detail=str(exc)) from exc


@router.get("/downloads", response_model=SoulseekDownloadStatus)
async def soulseek_downloads(client: SoulseekClient = Depends(get_soulseek_client)) -> SoulseekDownloadStatus:
    response = await client.get_download_status()
    downloads = response.get("downloads") if isinstance(response, dict) else None
    if isinstance(downloads, list):
        return SoulseekDownloadStatus(downloads=downloads)
    if isinstance(response, list):
        return SoulseekDownloadStatus(downloads=response)
    return SoulseekDownloadStatus(downloads=[response] if response else [])


@router.delete("/download/{download_id}", response_model=SoulseekCancelResponse)
async def soulseek_cancel(
    download_id: str,
    client: SoulseekClient = Depends(get_soulseek_client),
) -> SoulseekCancelResponse:
    try:
        await client.cancel_download(download_id)
    except SoulseekClientError as exc:
        raise HTTPException(status_code=400, detail=str(exc)) from exc
    return SoulseekCancelResponse(cancelled=True)

===== app/routers/spotify_router.py =====
"""Spotify API endpoints."""
from __future__ import annotations

from fastapi import APIRouter, Depends, HTTPException, Query

from app.core.spotify_client import SpotifyClient
from app.dependencies import get_spotify_client
from app.schemas import PlaylistResponse, SpotifySearchResponse, StatusResponse, TrackDetailResponse

router = APIRouter()


@router.get("/status", response_model=StatusResponse)
def spotify_status(client: SpotifyClient = Depends(get_spotify_client)) -> StatusResponse:
    status = "connected" if client.is_authenticated() else "unauthenticated"
    return StatusResponse(status=status)


@router.get("/search/tracks", response_model=SpotifySearchResponse)
def search_tracks(
    query: str = Query(..., min_length=1),
    client: SpotifyClient = Depends(get_spotify_client),
) -> SpotifySearchResponse:
    response = client.search_tracks(query)
    items = response.get("tracks", {}).get("items", [])
    return SpotifySearchResponse(items=items)


@router.get("/search/artists", response_model=SpotifySearchResponse)
def search_artists(
    query: str = Query(..., min_length=1),
    client: SpotifyClient = Depends(get_spotify_client),
) -> SpotifySearchResponse:
    response = client.search_artists(query)
    items = response.get("artists", {}).get("items", [])
    return SpotifySearchResponse(items=items)


@router.get("/search/albums", response_model=SpotifySearchResponse)
def search_albums(
    query: str = Query(..., min_length=1),
    client: SpotifyClient = Depends(get_spotify_client),
) -> SpotifySearchResponse:
    response = client.search_albums(query)
    items = response.get("albums", {}).get("items", [])
    return SpotifySearchResponse(items=items)


@router.get("/playlists", response_model=PlaylistResponse)
def list_playlists(client: SpotifyClient = Depends(get_spotify_client)) -> PlaylistResponse:
    response = client.get_user_playlists()
    items = response.get("items", [])
    return PlaylistResponse(playlists=items)


@router.get("/track/{track_id}", response_model=TrackDetailResponse)
def get_track_details(
    track_id: str,
    client: SpotifyClient = Depends(get_spotify_client),
) -> TrackDetailResponse:
    details = client.get_track_details(track_id)
    if not details:
        raise HTTPException(status_code=404, detail="Track not found")
    return TrackDetailResponse(track=details)

===== app/schemas.py =====
"""Pydantic schemas for request and response bodies."""
from __future__ import annotations

from datetime import datetime
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, Field


class StatusResponse(BaseModel):
    status: str


class SpotifySearchResponse(BaseModel):
    items: List[Dict[str, Any]]


class PlaylistResponse(BaseModel):
    playlists: List[Dict[str, Any]]


class TrackDetailResponse(BaseModel):
    track: Dict[str, Any]


class SoulseekSearchRequest(BaseModel):
    query: str


class SoulseekDownloadRequest(BaseModel):
    username: str = Field(..., description="Soulseek username hosting the files")
    files: List[Dict[str, Any]] = Field(..., description="List of files to download")


class SoulseekDownloadStatus(BaseModel):
    downloads: List[Dict[str, Any]]


class SoulseekCancelResponse(BaseModel):
    cancelled: bool


class MatchingRequest(BaseModel):
    spotify_track: Dict[str, Any]
    candidates: List[Dict[str, Any]]


class MatchingResponse(BaseModel):
    best_match: Optional[Dict[str, Any]]
    confidence: float


class SettingsPayload(BaseModel):
    key: str
    value: Optional[str]


class SettingsResponse(BaseModel):
    settings: Dict[str, Optional[str]]
    updated_at: datetime

===== app/workers/__init__.py =====
"""Background worker exports."""
from .matching_worker import MatchingWorker
from .scan_worker import ScanWorker
from .sync_worker import SyncWorker

__all__ = ["MatchingWorker", "ScanWorker", "SyncWorker"]

===== app/workers/matching_worker.py =====
"""Background worker handling deferred matching operations."""
from __future__ import annotations

import asyncio
from typing import Any, Dict

from sqlalchemy.orm import Session

from app.core.matching_engine import MusicMatchingEngine
from app.db import SessionLocal
from app.logging import get_logger
from app.models import Match

logger = get_logger(__name__)


class MatchingWorker:
    def __init__(self, engine: MusicMatchingEngine) -> None:
        self._engine = engine
        self._queue: asyncio.Queue[Dict[str, Any]] = asyncio.Queue()
        self._task: asyncio.Task | None = None
        self._running = asyncio.Event()

    async def start(self) -> None:
        if self._task is None or self._task.done():
            self._running.set()
            self._task = asyncio.create_task(self._run())

    async def stop(self) -> None:
        self._running.clear()
        if self._task:
            await self._queue.put({"_shutdown": True})
            await self._task

    @property
    def queue(self) -> asyncio.Queue[Dict[str, Any]]:
        return self._queue

    async def _run(self) -> None:
        logger.info("MatchingWorker started")
        while self._running.is_set():
            job = await self._queue.get()
            try:
                if job.get("_shutdown"):
                    break
                await self._process_job(job)
            except Exception as exc:  # pragma: no cover
                logger.error("Failed to process matching job: %s", exc)
            finally:
                self._queue.task_done()
        logger.info("MatchingWorker stopped")

    async def _process_job(self, job: Dict[str, Any]) -> None:
        job_type = job.get("type")
        spotify_track = job.get("spotify_track")
        candidates = job.get("candidates", [])
        if not spotify_track or not candidates:
            logger.warning("Invalid matching job received: %s", job)
            return
        if job_type == "spotify-to-plex":
            best_match, confidence = self._engine.find_best_match(spotify_track, candidates)
        else:
            best_match = None
            confidence = 0.0
            for candidate in candidates:
                score = self._engine.calculate_slskd_match_confidence(spotify_track, candidate)
                if score > confidence:
                    confidence = score
                    best_match = candidate
        self._store_match(job_type, spotify_track, best_match, confidence)

    def _store_match(
        self,
        job_type: str,
        spotify_track: Dict[str, Any],
        best_match: Dict[str, Any] | None,
        confidence: float,
    ) -> None:
        session: Session = SessionLocal()
        try:
            match = Match(
                source=job_type,
                spotify_track_id=str(spotify_track.get("id")),
                target_id=str(best_match.get("id")) if best_match and best_match.get("id") else None,
                confidence=confidence,
            )
            session.add(match)
            session.commit()
        finally:
            session.close()

===== app/workers/scan_worker.py =====
"""Worker that periodically scans the Plex library."""
from __future__ import annotations

import asyncio
from datetime import datetime

from sqlalchemy import select
from sqlalchemy.orm import Session

from app.core.plex_client import PlexClient
from app.db import SessionLocal
from app.logging import get_logger
from app.models import Setting

logger = get_logger(__name__)


class ScanWorker:
    def __init__(self, plex_client: PlexClient, interval_seconds: int = 600) -> None:
        self._client = plex_client
        self._interval = interval_seconds
        self._task: asyncio.Task | None = None
        self._running = asyncio.Event()

    async def start(self) -> None:
        if self._task is None or self._task.done():
            self._running.set()
            self._task = asyncio.create_task(self._run())

    async def stop(self) -> None:
        self._running.clear()
        if self._task:
            self._task.cancel()
            try:
                await self._task
            except asyncio.CancelledError:  # pragma: no cover
                pass

    async def _run(self) -> None:
        logger.info("ScanWorker started")
        while self._running.is_set():
            await self._perform_scan()
            await asyncio.sleep(self._interval)
        logger.info("ScanWorker stopped")

    async def _perform_scan(self) -> None:
        try:
            artists = self._client.get_all_artists()
        except Exception as exc:  # pragma: no cover
            logger.error("Failed to scan Plex library: %s", exc)
            return
        artist_count = len(artists)
        session: Session = SessionLocal()
        try:
            setting = session.execute(
                select(Setting).where(Setting.key == "plex_artist_count")
            ).scalar_one_or_none()
            now = datetime.utcnow()
            if setting is None:
                setting = Setting(key="plex_artist_count", value=str(artist_count), created_at=now, updated_at=now)
                session.add(setting)
            else:
                setting.value = str(artist_count)
                setting.updated_at = now
            session.commit()
        finally:
            session.close()

===== app/workers/sync_worker.py =====
"""Background worker for processing Soulseek download jobs."""
from __future__ import annotations

import asyncio
from typing import Any, Dict

from sqlalchemy.orm import Session

from app.core.soulseek_client import SoulseekClient
from app.db import SessionLocal
from app.logging import get_logger
from app.models import Download

logger = get_logger(__name__)


class SyncWorker:
    def __init__(self, soulseek_client: SoulseekClient) -> None:
        self._client = soulseek_client
        self._queue: asyncio.Queue[Dict[str, Any]] = asyncio.Queue()
        self._task: asyncio.Task | None = None
        self._running = asyncio.Event()

    @property
    def queue(self) -> asyncio.Queue[Dict[str, Any]]:
        return self._queue

    async def start(self) -> None:
        if self._task is None or self._task.done():
            self._running.set()
            self._task = asyncio.create_task(self._run())

    async def stop(self) -> None:
        self._running.clear()
        if self._task:
            await self._queue.put({"_shutdown": True})
            await self._task

    async def _run(self) -> None:
        logger.info("SyncWorker started")
        while self._running.is_set():
            job = await self._queue.get()
            try:
                if job.get("_shutdown"):
                    break
                await self._process_job(job)
            except Exception as exc:  # pragma: no cover - defensive
                logger.error("Failed to process sync job: %s", exc)
            finally:
                self._queue.task_done()
        logger.info("SyncWorker stopped")

    async def _process_job(self, job: Dict[str, Any]) -> None:
        username = job.get("username")
        files = job.get("files", [])
        if not username or not files:
            logger.warning("Invalid download job received: %s", job)
            return
        await self._client.download({"username": username, "files": files})
        self._store_download(job)

    def _store_download(self, job: Dict[str, Any]) -> None:
        session: Session = SessionLocal()
        try:
            for file_info in job.get("files", []):
                download = Download(
                    filename=file_info.get("filename", "unknown"),
                    state="queued",
                    progress=0.0,
                )
                session.add(download)
            session.commit()
        finally:
            session.close()

===== docker-compose.yml =====
version: "3.9"

services:
  backend:
    build: .
    container_name: harmony-backend
    environment:
      - DATABASE_URL=sqlite:///./harmony.db
      - HARMONY_LOG_LEVEL=INFO
    ports:
      - "8000:8000"
    volumes:
      - ./:/app
    command: ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]

===== requirements.txt =====
fastapi
uvicorn
sqlalchemy
aiohttp
spotipy
plexapi
pydantic
pytest
pytest-asyncio
httpx

===== tests/conftest.py =====
from __future__ import annotations

import os
from pathlib import Path
from typing import Any, Dict

import sys

ROOT = Path(__file__).resolve().parents[1]
if str(ROOT) not in sys.path:
    sys.path.insert(0, str(ROOT))

import pytest
from app.dependencies import (
    get_matching_engine as dependency_matching_engine,
    get_plex_client as dependency_plex_client,
    get_soulseek_client as dependency_soulseek_client,
    get_spotify_client as dependency_spotify_client,
)
from app.main import app
from app.workers import MatchingWorker, ScanWorker, SyncWorker
from tests.simple_client import SimpleTestClient


class StubSpotifyClient:
    def __init__(self) -> None:
        self.tracks: Dict[str, Dict[str, Any]] = {
            "track-1": {"id": "track-1", "name": "Test Song", "artists": [{"name": "Tester"}], "duration_ms": 200000},
        }

    def is_authenticated(self) -> bool:
        return True

    def search_tracks(self, query: str, limit: int = 20) -> Dict[str, Any]:
        return {"tracks": {"items": list(self.tracks.values())}}

    def search_artists(self, query: str, limit: int = 20) -> Dict[str, Any]:
        return {"artists": {"items": [{"id": "artist-1", "name": "Tester"}]}}

    def search_albums(self, query: str, limit: int = 20) -> Dict[str, Any]:
        return {"albums": {"items": [{"id": "album-1", "name": "Album", "artists": [{"name": "Tester"}]}]}}

    def get_user_playlists(self, limit: int = 50) -> Dict[str, Any]:
        return {"items": [{"id": "playlist-1", "name": "My Playlist"}]}

    def get_track_details(self, track_id: str) -> Dict[str, Any]:
        return self.tracks.get(track_id, {"id": track_id, "name": "Unknown"})


class StubPlexClient:
    def __init__(self) -> None:
        self.artists = [{"id": "1", "name": "Tester"}]
        self.albums = [{"id": "10", "title": "Album", "year": 2020}]
        self.tracks = [{"id": "100", "title": "Test Song", "duration": 200000}]

    def is_connected(self) -> bool:
        return True

    def get_all_artists(self) -> list:
        return self.artists

    def get_albums_by_artist(self, artist_id: str) -> list:
        return self.albums

    def get_tracks_by_album(self, album_id: str) -> list:
        return self.tracks


class StubSoulseekClient:
    async def get_download_status(self) -> Dict[str, Any]:
        return {"downloads": []}

    async def search(self, query: str) -> Dict[str, Any]:
        return {"results": [query]}

    async def download(self, payload: Dict[str, Any]) -> Dict[str, Any]:
        return {"status": "queued", **payload}

    async def cancel_download(self, download_id: str) -> Dict[str, Any]:
        return {"cancelled": download_id}


@pytest.fixture(autouse=True)
def configure_environment(monkeypatch: pytest.MonkeyPatch) -> None:
    monkeypatch.setenv("HARMONY_DISABLE_WORKERS", "1")
    monkeypatch.setenv("DATABASE_URL", "sqlite:///./test.db")
    db_path = Path("test.db")
    if db_path.exists():
        db_path.unlink()
    yield


@pytest.fixture
def client(monkeypatch: pytest.MonkeyPatch) -> SimpleTestClient:
    stub_spotify = StubSpotifyClient()
    stub_plex = StubPlexClient()
    stub_soulseek = StubSoulseekClient()
    engine = dependency_matching_engine()

    async def noop_start(self) -> None:  # type: ignore[override]
        return None

    async def noop_stop(self) -> None:  # type: ignore[override]
        return None

    # Prevent worker tasks during tests
    monkeypatch.setattr(SyncWorker, "start", noop_start)
    monkeypatch.setattr(MatchingWorker, "start", noop_start)
    monkeypatch.setattr(ScanWorker, "start", noop_start)
    monkeypatch.setattr(SyncWorker, "stop", noop_stop)
    monkeypatch.setattr(MatchingWorker, "stop", noop_stop)
    monkeypatch.setattr(ScanWorker, "stop", noop_stop)

    from app import dependencies as deps

    monkeypatch.setattr(deps, "get_spotify_client", lambda: stub_spotify)
    monkeypatch.setattr(deps, "get_plex_client", lambda: stub_plex)
    monkeypatch.setattr(deps, "get_soulseek_client", lambda: stub_soulseek)
    monkeypatch.setattr(deps, "get_matching_engine", lambda: engine)

    app.dependency_overrides[dependency_spotify_client] = lambda: stub_spotify
    app.dependency_overrides[dependency_plex_client] = lambda: stub_plex
    app.dependency_overrides[dependency_soulseek_client] = lambda: stub_soulseek
    app.dependency_overrides[dependency_matching_engine] = lambda: engine

    with SimpleTestClient(app) as test_client:
        yield test_client

    app.dependency_overrides.clear()

===== tests/simple_client.py =====
from __future__ import annotations

import asyncio
import json
from types import TracebackType
from typing import Any, Dict, Optional, Type
from urllib.parse import urlencode

from fastapi import FastAPI


class SimpleResponse:
    def __init__(self, status_code: int, body: bytes, headers: Dict[str, str]) -> None:
        self.status_code = status_code
        self._body = body
        self.headers = headers

    def json(self) -> Any:
        if not self._body:
            return None
        return json.loads(self._body.decode("utf-8"))


class SimpleTestClient:
    def __init__(self, app: FastAPI) -> None:
        self.app = app
        self._loop = asyncio.new_event_loop()
        self._previous_loop: Optional[asyncio.AbstractEventLoop] = None

    def __enter__(self) -> "SimpleTestClient":
        try:
            self._previous_loop = asyncio.get_event_loop()
        except RuntimeError:
            self._previous_loop = None
        asyncio.get_event_loop_policy().set_event_loop(self._loop)
        self._loop.run_until_complete(self.app.router.startup())
        return self

    def __exit__(
        self,
        exc_type: Optional[Type[BaseException]],
        exc: Optional[BaseException],
        tb: Optional[TracebackType],
    ) -> None:
        self._loop.run_until_complete(self.app.router.shutdown())
        self._loop.close()
        if self._previous_loop is not None:
            asyncio.get_event_loop_policy().set_event_loop(self._previous_loop)

    def get(self, path: str, params: Optional[Dict[str, Any]] = None) -> SimpleResponse:
        return self._loop.run_until_complete(self._request("GET", path, params=params))

    def post(
        self,
        path: str,
        json_body: Optional[Dict[str, Any]] = None,
        json: Optional[Dict[str, Any]] = None,
    ) -> SimpleResponse:
        payload = json_body if json_body is not None else json
        return self._loop.run_until_complete(self._request("POST", path, json_body=payload))

    def delete(self, path: str) -> SimpleResponse:
        return self._loop.run_until_complete(self._request("DELETE", path))

    async def _request(
        self,
        method: str,
        path: str,
        params: Optional[Dict[str, Any]] = None,
        json_body: Optional[Dict[str, Any]] = None,
    ) -> SimpleResponse:
        query_string = urlencode(params or {})
        scope = {
            "type": "http",
            "http_version": "1.1",
            "method": method,
            "path": path,
            "raw_path": path.encode("utf-8"),
            "query_string": query_string.encode("utf-8"),
            "headers": [],
        }

        body = b""
        if json_body is not None:
            body = json.dumps(json_body).encode("utf-8")
            scope["headers"].append((b"content-type", b"application/json"))

        response_body = bytearray()
        response_headers: Dict[str, str] = {}
        status_code = 500
        request_complete = False

        async def receive() -> Dict[str, Any]:
            nonlocal request_complete
            if request_complete:
                return {"type": "http.disconnect"}
            request_complete = True
            return {"type": "http.request", "body": body, "more_body": False}

        async def send(message: Dict[str, Any]) -> None:
            nonlocal status_code, response_headers
            if message["type"] == "http.response.start":
                status_code = message["status"]
                response_headers = {key.decode(): value.decode() for key, value in message.get("headers", [])}
            elif message["type"] == "http.response.body":
                response_body.extend(message.get("body", b""))

        await self.app(scope, receive, send)
        return SimpleResponse(status_code, bytes(response_body), response_headers)

===== tests/test_matching.py =====
from __future__ import annotations

from app.core.matching_engine import MusicMatchingEngine
from tests.simple_client import SimpleTestClient


def test_match_confidence() -> None:
    engine = MusicMatchingEngine()
    spotify_track = {
        "id": "track-1",
        "name": "Test Song",
        "artists": [{"name": "Tester"}],
        "album": {"name": "Album"},
        "duration_ms": 200000,
    }
    plex_track = {
        "id": "100",
        "title": "Test Song",
        "artist": "Tester",
        "album": "Album",
        "duration": 200000,
    }
    score = engine.calculate_match_confidence(spotify_track, plex_track)
    assert score > 0.8


def test_matching_api_plex(client: SimpleTestClient) -> None:
    payload = {
        "spotify_track": {
            "id": "track-1",
            "name": "Test Song",
            "artists": [{"name": "Tester"}],
            "album": {"name": "Album"},
            "duration_ms": 200000,
        },
        "candidates": [
            {"id": "100", "title": "Test Song", "artist": "Tester", "album": "Album", "duration": 200000}
        ],
    }
    response = client.post("/matching/spotify-to-plex", json=payload)
    assert response.status_code == 200
    data = response.json()
    assert data["best_match"]["id"] == "100"
    assert data["confidence"] > 0.5


def test_matching_api_soulseek(client: SimpleTestClient) -> None:
    payload = {
        "spotify_track": {
            "id": "track-1",
            "name": "Test Song",
            "artists": [{"name": "Tester"}],
            "album": {"name": "Album"},
        },
        "candidates": [
            {"filename": "Tester - Test Song.mp3", "username": "Tester", "bitrate": 320}
        ],
    }
    response = client.post("/matching/spotify-to-soulseek", json=payload)
    assert response.status_code == 200
    assert response.json()["confidence"] > 0.5

===== tests/test_plex.py =====
from __future__ import annotations

from tests.simple_client import SimpleTestClient


def test_plex_status(client: SimpleTestClient) -> None:
    response = client.get("/plex/status")
    assert response.status_code == 200
    assert response.json()["status"] == "connected"


def test_plex_artists(client: SimpleTestClient) -> None:
    response = client.get("/plex/artists")
    assert response.status_code == 200
    assert response.json()[0]["name"] == "Tester"


def test_plex_tracks(client: SimpleTestClient) -> None:
    response = client.get("/plex/album/10/tracks")
    assert response.status_code == 200
    assert response.json()[0]["title"] == "Test Song"

===== tests/test_soulseek.py =====
from __future__ import annotations

from tests.simple_client import SimpleTestClient


def test_soulseek_status(client: SimpleTestClient) -> None:
    response = client.get("/soulseek/status")
    assert response.status_code == 200
    assert response.json()["status"] == "connected"


def test_soulseek_search(client: SimpleTestClient) -> None:
    response = client.post("/soulseek/search", json={"query": "Test"})
    assert response.status_code == 200
    assert response.json()["results"] == ["Test"]


def test_soulseek_download_flow(client: SimpleTestClient) -> None:
    download_payload = {
        "username": "tester",
        "files": [{"filename": "song.mp3", "size": 123}]
    }
    response = client.post("/soulseek/download", json=download_payload)
    assert response.status_code == 200
    assert response.json()["status"] == "queued"

    response = client.get("/soulseek/downloads")
    assert response.status_code == 200
    assert response.json()["downloads"] == []

    response = client.delete("/soulseek/download/1")
    assert response.status_code == 200
    assert response.json()["cancelled"] is True

===== tests/test_spotify.py =====
from __future__ import annotations

from tests.simple_client import SimpleTestClient


def test_spotify_status(client: SimpleTestClient) -> None:
    response = client.get("/spotify/status")
    assert response.status_code == 200
    assert response.json()["status"] == "connected"


def test_spotify_search_tracks(client: SimpleTestClient) -> None:
    response = client.get("/spotify/search/tracks", params={"query": "Test"})
    assert response.status_code == 200
    body = response.json()
    assert body["items"]


def test_spotify_track_details(client: SimpleTestClient) -> None:
    response = client.get("/spotify/track/track-1")
    assert response.status_code == 200
    assert response.json()["track"]["id"] == "track-1"

