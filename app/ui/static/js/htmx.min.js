/*! Harmony HTMX runtime v1.0.0 (compatible subset inspired by HTMX 1.9.x) */
(function () {
  "use strict";

  var REQUEST_CLASS = "htmx-request";
  var processedElements = new WeakSet();
  var elementConfigs = new WeakMap();
  var timers = new WeakMap();

  function getAttr(element, name) {
    if (!element || element.nodeType !== 1) {
      return null;
    }
    return element.getAttribute(name) || element.getAttribute("data-" + name);
  }

  function parseSwapStyle(value) {
    if (!value) {
      return "innerHTML";
    }
    var token = value.split(/\s+/)[0].toLowerCase();
    switch (token) {
      case "outerhtml":
        return "outerHTML";
      case "afterbegin":
        return "afterbegin";
      case "beforebegin":
        return "beforebegin";
      case "afterend":
        return "afterend";
      case "beforeend":
        return "beforeend";
      case "none":
        return "none";
      default:
        return "innerHTML";
    }
  }

  function parseTriggers(value, element) {
    if (!value || !value.trim()) {
      if (element instanceof HTMLFormElement) {
        return ["submit"];
      }
      return ["click"];
    }
    return value
      .split(",")
      .map(function (token) {
        return token.trim();
      })
      .filter(function (token) {
        return token.length > 0;
      });
  }

  function resolveTarget(element, selector) {
    if (!selector || selector === "this") {
      return element;
    }
    if (selector.indexOf("closest ") === 0) {
      return element.closest(selector.slice(8).trim());
    }
    if (selector.indexOf("find ") === 0) {
      return element.querySelector(selector.slice(5).trim());
    }
    try {
      return document.querySelector(selector) || element;
    } catch (_err) {
      return element;
    }
  }

  function appendParams(url, params) {
    if (!params) {
      return url;
    }
    var parts = url.split("#");
    var base = parts[0];
    var hash = parts.length > 1 ? "#" + parts[1] : "";
    var separator = base.indexOf("?") === -1 ? "?" : "&";
    return base + (params ? separator + params : "") + hash;
  }

  function formDataToJson(formData) {
    var result = {};
    formData.forEach(function (value, key) {
      if (Object.prototype.hasOwnProperty.call(result, key)) {
        if (!Array.isArray(result[key])) {
          result[key] = [result[key]];
        }
        result[key].push(value);
      } else {
        result[key] = value;
      }
    });
    return result;
  }

  function collectFormData(element, event) {
    var data = new FormData();
    if (element instanceof HTMLFormElement) {
      new FormData(element).forEach(function (value, key) {
        data.append(key, value);
      });
    } else {
      var form = element.closest("form");
      if (form) {
        new FormData(form).forEach(function (value, key) {
          data.append(key, value);
        });
      }
    }
    if (event && event.submitter && event.submitter.name) {
      data.append(event.submitter.name, event.submitter.value || "");
    }
    var hxVals = getAttr(element, "hx-vals");
    if (hxVals) {
      try {
        var extra = JSON.parse(hxVals);
        Object.keys(extra).forEach(function (key) {
          var value = extra[key];
          if (Array.isArray(value)) {
            value.forEach(function (entry) {
              data.append(key, entry);
            });
          } else {
            data.append(key, value);
          }
        });
      } catch (err) {
        console.warn("Failed to parse hx-vals", err);
      }
    }
    return data;
  }

  function buildRequest(element, method, url, event) {
    var headers = {};
    var body = null;
    var formData = collectFormData(element, event);
    var isGetLike = method === "GET" || method === "DELETE";
    if (isGetLike) {
      var params = new URLSearchParams();
      formData.forEach(function (value, key) {
        if (value !== undefined && value !== null) {
          params.append(key, value);
        }
      });
      var query = params.toString();
      if (query) {
        url = appendParams(url, query);
      }
    } else {
      var encoding = getAttr(element, "hx-encoding");
      if (encoding && encoding.toLowerCase() === "application/json") {
        headers["Content-Type"] = "application/json";
        body = JSON.stringify(formDataToJson(formData));
      } else {
        body = formData;
      }
    }
    return { url: url, headers: headers, body: body };
  }

  function extractSelectedHtml(element, responseText) {
    var selector = getAttr(element, "hx-select");
    if (!selector) {
      return responseText;
    }
    var temp = document.createElement("div");
    temp.innerHTML = responseText;
    var match = temp.querySelector(selector);
    return match ? match.outerHTML : "";
  }

  function dispatchEvent(element, name, detail) {
    var event = new CustomEvent(name, {
      bubbles: true,
      cancelable: name === "htmx:beforeRequest" || name === "htmx:beforeSwap",
      detail: detail || {}
    });
    var cancelled = !element.dispatchEvent(event);
    return { event: event, cancelled: cancelled };
  }

  function addRequestClasses(element, target, indicators) {
    if (element) {
      element.classList.add(REQUEST_CLASS);
    }
    if (target && target !== element) {
      target.classList.add(REQUEST_CLASS);
    }
    indicators.forEach(function (indicator) {
      indicator.classList.add(REQUEST_CLASS);
    });
  }

  function removeRequestClasses(element, target, indicators) {
    if (element) {
      element.classList.remove(REQUEST_CLASS);
    }
    if (target && target !== element) {
      target.classList.remove(REQUEST_CLASS);
    }
    indicators.forEach(function (indicator) {
      indicator.classList.remove(REQUEST_CLASS);
    });
  }

  function gatherIndicators(element) {
    var selector = getAttr(element, "hx-indicator");
    if (!selector) {
      return [];
    }
    try {
      return Array.prototype.slice.call(document.querySelectorAll(selector));
    } catch (_err) {
      return [];
    }
  }

  function performSwap(target, html, style) {
    if (!target || style === "none") {
      return [];
    }
    var newNodes = [];
    if (style === "innerHTML") {
      target.innerHTML = html;
      newNodes = Array.prototype.slice.call(target.children);
      return newNodes;
    }
    var wrapper = document.createElement("div");
    wrapper.innerHTML = html;
    var nodes = [];
    while (wrapper.firstChild) {
      nodes.push(wrapper.firstChild);
      wrapper.removeChild(wrapper.firstChild);
    }
    var parent = target.parentNode;
    if (!parent) {
      return [];
    }
    if (style === "outerHTML") {
      var fragment = document.createDocumentFragment();
      nodes.forEach(function (node) {
        fragment.appendChild(node);
      });
      parent.replaceChild(fragment, target);
      newNodes = nodes.filter(function (node) {
        return node.nodeType === Node.ELEMENT_NODE;
      });
      return newNodes;
    }
    if (style === "beforebegin" || style === "afterend") {
      nodes.forEach(function (node) {
        if (style === "beforebegin") {
          parent.insertBefore(node, target);
        } else {
          parent.insertBefore(node, target.nextSibling);
        }
      });
      return nodes.filter(function (node) {
        return node.nodeType === Node.ELEMENT_NODE;
      });
    }
    if (style === "afterbegin" || style === "beforeend") {
      nodes.forEach(function (node) {
        if (style === "afterbegin") {
          target.insertBefore(node, target.firstChild);
        } else {
          target.appendChild(node);
        }
      });
      return nodes.filter(function (node) {
        return node.nodeType === Node.ELEMENT_NODE;
      });
    }
    target.innerHTML = html;
    return Array.prototype.slice.call(target.children);
  }

  function scanForHx(root) {
    if (!root) {
      return;
    }
    var elements = [];
    if (root.nodeType === Node.ELEMENT_NODE) {
      elements.push(root);
      elements = elements.concat(Array.prototype.slice.call(root.querySelectorAll("[hx-get],[data-hx-get],[hx-post],[data-hx-post],[hx-put],[data-hx-put],[hx-patch],[data-hx-patch],[hx-delete],[data-hx-delete]")));
    } else if (root === document) {
      elements = Array.prototype.slice.call(document.querySelectorAll("[hx-get],[data-hx-get],[hx-post],[data-hx-post],[hx-put],[data-hx-put],[hx-patch],[data-hx-patch],[hx-delete],[data-hx-delete]"));
    }
    elements.forEach(initializeElement);
  }

  function scheduleInterval(element, config, descriptor) {
    var match = descriptor.match(/^every\s+(\d+)(ms|s)?$/i);
    if (!match) {
      return;
    }
    var amount = parseInt(match[1], 10);
    if (Number.isNaN(amount) || amount <= 0) {
      return;
    }
    var unit = match[2] || "s";
    var delay = unit === "ms" ? amount : amount * 1000;
    var handle = setInterval(function () {
      sendRequest(config, null);
    }, delay);
    var existing = timers.get(element) || [];
    existing.push(handle);
    timers.set(element, existing);
  }

  function clearTimers(element) {
    var handles = timers.get(element);
    if (handles) {
      handles.forEach(function (handle) {
        clearInterval(handle);
      });
      timers.delete(element);
    }
  }

  function sendRequest(config, triggerEvent) {
    var element = config.element;
    if (!element || (document.body && !document.body.contains(element))) {
      return;
    }
    var target = resolveTarget(element, config.targetSelector);
    var indicators = gatherIndicators(element);
    addRequestClasses(element, target, indicators);
    var requestDetail = {
      elt: element,
      event: triggerEvent || null,
      target: target
    };
    var beforeRequest = dispatchEvent(element, "htmx:beforeRequest", requestDetail);
    if (beforeRequest.cancelled) {
      removeRequestClasses(element, target, indicators);
      return;
    }
    var payload = buildRequest(element, config.method, config.url, triggerEvent);
    var headers = payload.headers;
    headers["HX-Request"] = "true";
    if (element.id) {
      headers["HX-Trigger"] = element.id;
    }
    var configEvent = new CustomEvent("htmx:configRequest", {
      bubbles: true,
      cancelable: false,
      detail: {
        headers: headers,
        elt: element,
        event: triggerEvent || null
      }
    });
    element.dispatchEvent(configEvent);
    var finalHeaders = new Headers(configEvent.detail && configEvent.detail.headers ? configEvent.detail.headers : headers);
    var abortController = new AbortController();
    config.inFlight = abortController;
    fetch(payload.url, {
      method: config.method,
      credentials: "same-origin",
      headers: finalHeaders,
      body: payload.body,
      signal: abortController.signal
    })
      .then(function (response) {
        config.inFlight = null;
        var redirect = response.headers.get("HX-Redirect");
        if (redirect) {
          window.location.href = redirect;
          return null;
        }
        var refresh = response.headers.get("HX-Refresh");
        if (refresh && refresh.toLowerCase() === "true") {
          window.location.reload();
          return null;
        }
        return response.text().then(function (text) {
          return { response: response, text: text };
        });
      })
      .then(function (result) {
        if (!result) {
          return;
        }
        var response = result.response;
        var rawHtml = extractSelectedHtml(element, result.text);
        var swapDetail = {
          elt: element,
          target: target,
          response: response
        };
        var beforeSwap = dispatchEvent(element, "htmx:beforeSwap", swapDetail);
        if (!beforeSwap.cancelled) {
          var newNodes = performSwap(target || element, rawHtml, config.swapStyle);
          dispatchEvent(element, "htmx:afterSwap", swapDetail);
          newNodes.forEach(function (node) {
            scanForHx(node);
          });
        }
        dispatchEvent(element, "htmx:afterRequest", {
          elt: element,
          target: target,
          response: response
        });
      })
      .catch(function (error) {
        if (error && error.name === "AbortError") {
          return;
        }
        dispatchEvent(element, "htmx:responseError", {
          elt: element,
          error: error
        });
      })
      .finally(function () {
        removeRequestClasses(element, target, indicators);
      });
  }

  function initializeElement(element) {
    if (processedElements.has(element)) {
      return;
    }
    var url =
      getAttr(element, "hx-get") ||
      getAttr(element, "hx-post") ||
      getAttr(element, "hx-put") ||
      getAttr(element, "hx-patch") ||
      getAttr(element, "hx-delete");
    if (!url) {
      return;
    }
    var method = "GET";
    if (getAttr(element, "hx-post")) {
      method = "POST";
    } else if (getAttr(element, "hx-put")) {
      method = "PUT";
    } else if (getAttr(element, "hx-patch")) {
      method = "PATCH";
    } else if (getAttr(element, "hx-delete")) {
      method = "DELETE";
    }
    var config = {
      element: element,
      method: method,
      url: url,
      targetSelector: getAttr(element, "hx-target"),
      swapStyle: parseSwapStyle(getAttr(element, "hx-swap")),
      triggers: parseTriggers(getAttr(element, "hx-trigger"), element),
      inFlight: null
    };
    elementConfigs.set(element, config);
    processedElements.add(element);
    clearTimers(element);
    config.triggers.forEach(function (trigger) {
      if (trigger === "load") {
        if (document.readyState === "loading") {
          document.addEventListener("DOMContentLoaded", function handler() {
            document.removeEventListener("DOMContentLoaded", handler);
            sendRequest(config, null);
          });
        } else {
          setTimeout(function () {
            sendRequest(config, null);
          }, 0);
        }
        return;
      }
      if (trigger.indexOf("every ") === 0) {
        scheduleInterval(element, config, trigger);
        return;
      }
      element.addEventListener(trigger, function (event) {
        if (trigger === "submit") {
          event.preventDefault();
        }
        sendRequest(config, event);
      });
    });
  }

  function cancelInFlight(element) {
    var config = elementConfigs.get(element);
    if (config && config.inFlight) {
      config.inFlight.abort();
      config.inFlight = null;
    }
  }

  function destroyElement(element) {
    cancelInFlight(element);
    clearTimers(element);
    elementConfigs.delete(element);
    processedElements.delete(element);
  }

  document.addEventListener("htmx:afterCleanupElement", function (event) {
    if (event && event.detail && event.detail.el) {
      destroyElement(event.detail.el);
    }
  });

  document.addEventListener("DOMContentLoaded", function () {
    scanForHx(document);
  });

  window.htmx = {
    version: "1.9.12-lite",
    trigger: function (element, name, detail) {
      if (!element) {
        return;
      }
      element.dispatchEvent(new CustomEvent(name, { bubbles: true, detail: detail || {} }));
    },
    find: function (selector) {
      return document.querySelector(selector);
    },
    findAll: function (selector) {
      return Array.prototype.slice.call(document.querySelectorAll(selector));
    },
    ajax: function (options) {
      var url = options.url || "";
      var method = (options.method || "GET").toUpperCase();
      var headers = options.headers || {};
      var body = options.body || null;
      return fetch(url, {
        method: method,
        headers: headers,
        body: body,
        credentials: "same-origin"
      }).then(function (response) {
        if (options.target) {
          return response.text().then(function (text) {
            var target = resolveTarget(options.target, options.targetSelector);
            performSwap(target, text, parseSwapStyle(options.swap || "innerHTML"));
            return response;
          });
        }
        return response;
      });
    }
  };
})();
